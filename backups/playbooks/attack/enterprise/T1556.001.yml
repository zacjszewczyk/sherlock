name: T1556.001: Domain Controller Authentication
id: 3a1b9e0c-8d3f-4e6a-9b4c-2f7d1e5a8b6f
description: An adversary may patch the authentication process on a domain controller to maintain persistence, evade defenses, and access credentials. This involves modifying critical system components, such as the LSA Security Packages registry key, to load malicious DLLs. These DLLs can implement backdoors like skeleton keys, allowing the adversary to authenticate with any password or even with disabled accounts. This playbook provides investigative questions to detect such activity by monitoring for specific registry modifications, suspicious process executions (like Mimikatz), anomalous logon events (e.g., logons from disabled accounts, first-time interactive logons), unauthorized access to lsass.exe memory, tampering with critical system files, and discrepancies in MFA-related logon events.
type: technique
related:
  - TA0003: Persistence
  - TA0005: Defense Evasion
  - TA0006: Credential Access
contributors:
  - Zachary Szewczyk
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: How can we symbolically detect malicious modifications to the 'Security Packages' registry value on domain controllers?
    context: Adversaries may modify the 'HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages' registry key on a domain controller to load a malicious Security Support Provider (SSP). This allows them to intercept and manipulate authentication data, effectively creating a backdoor. This question focuses on creating a high-fidelity rule to detect such modifications by checking for changes to this specific key and verifying if the newly added DLL is a known malicious package (like mimilib.dll) or if it lacks a valid Microsoft signature.
    answer_sources:
      - Windows Event ID 4657
      - Sysmon Event ID 13
      - Domain Controllers' registry
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          SEARCH (EventID:4657 OR SysmonID:13) AND RegistryKey:"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages"
          WHERE host.role = "domain_controller"
          FILTER new_dll_name IN known_malicious_dll_list OR new_dll_signature != "Microsoft"
          ALERT
  - question: How can we statistically identify anomalous modifications to the 'Security Packages' registry value on domain controllers?
    context: While symbolic detection is effective against known threats, adversaries may use novel or custom tools. This question aims to find unknown threats by establishing a baseline of the DLLs normally present in the 'Security Packages' key across all domain controllers. A DLL that is a statistical outlier—for instance, appearing on only one DC—is highly suspicious. Monitoring the rate of change for this key and flagging modifications outside of normal maintenance cycles also helps uncover unexpected and potentially malicious activity.
    answer_sources:
      - Windows Event ID 4657
      - Sysmon Event ID 13
      - Domain Controllers' registry
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          // Baseline Phase
          BASELINE dll_list from "HKLM\\...\\Security Packages" on all domain_controllers
          CALCULATE prevalence of each dll

          // Detection Phase
          SEARCH registry_modifications to "HKLM\\...\\Security Packages"
          IF added_dll.prevalence < 1% OR modification_time NOT IN maintenance_window
          ALERT
  - question: How can machine learning be used to detect malicious DLLs added to the 'Security Packages' registry value?
    context: Machine learning can enhance detection by learning the normal rhythm of system updates and the characteristics of benign files. This question proposes a two-pronged ML approach. First, a time-series model learns the normal patching schedule for the 'Security Packages' key, flagging any modifications that occur at an unexpected time. Second, a classification model analyzes the properties of the newly added DLL itself—such as its entropy or signature status—to determine if it has malicious characteristics, providing an independent line of evidence.
    answer_sources:
      - Windows Event ID 4657
      - Sysmon Event ID 13
      - Domain Controllers' registry
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          // Time-Series Anomaly
          MODEL = train_arima_model(historical_registry_mod_events)
          PREDICT expected_mods for current_time
          IF actual_mod is outlier THEN ALERT

          // File Classification
          MODEL = train_classifier(dll_file_features)
          SCORE = model.predict(new_dll_file)
          IF SCORE > malicious_threshold THEN ALERT
  - question: How can we symbolically detect the use of Mimikatz skeleton key functionality on domain controllers?
    context: Adversaries often use tools like Mimikatz to execute a "skeleton key" attack, which patches the domain controller's authentication process in memory. This question focuses on detecting this activity by searching for specific command-line strings, such as 'misc::skeleton' or 'sekurlsa::', in process creation events on domain controllers. The presence of these keywords is a strong indicator of a compromise attempt.
    answer_sources:
      - Windows Event ID 4688
      - Sysmon Event ID 1
      - Domain Controllers' process execution logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          SEARCH (EventID:4688 OR SysmonID:1) on host.role="domain_controller"
          WHERE command_line CONTAINS ("misc::skeleton" OR "privilege::debug" OR "sekurlsa::")
          ALERT
  - question: How can we statistically identify anomalous command-line activity on domain controllers?
    context: Adversaries may obfuscate commands to evade simple keyword matching. This question addresses this by using statistical methods. By calculating the Shannon entropy of command strings, we can identify unusually complex or encoded commands. Additionally, analyzing parent-child process relationships can reveal anomalous behavior, such as a web server process spawning PowerShell, which is a common pattern in web shell attacks.
    answer_sources:
      - Windows Event ID 4688
      - Sysmon Event ID 1
      - Domain Controllers' process execution logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          // Entropy Check
          SEARCH process_creation on host.role="domain_controller"
          CALCULATE entropy(command_line)
          IF entropy > baseline_95th_percentile THEN ALERT

          // Parent-Child Check
          SEARCH process_creation on host.role="domain_controller"
          IF parent_child_relationship IS RARE THEN ALERT
  - question: How can machine learning be used to classify command lines on domain controllers as benign or malicious?
    context: This question proposes using a machine learning classifier to provide a more robust and adaptive detection method for malicious commands. By training a model on features extracted from command lines (such as length, character types, and n-gram frequency), the system can learn to distinguish between normal administrative activity and adversary commands, even if they are novel or obfuscated. This allows for real-time scoring of all new commands.
    answer_sources:
      - Windows Event ID 4688
      - Sysmon Event ID 1
      - Domain Controllers' process execution logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          MODEL = train_classifier(command_line_features)
          FOR new_command in process_creation_events
            SCORE = model.predict(new_command)
            IF SCORE > malicious_threshold THEN ALERT
  - question: How can we symbolically detect successful logons from disabled accounts?
    context: A successful logon from an account that is known to be disabled in Active Directory is a high-fidelity indicator of a skeleton key attack. This question outlines a method to create a watchlist of all disabled accounts and correlate it with successful logon events (Windows Event ID 4624). Any match represents a severe security event that requires immediate investigation.
    answer_sources:
      - Windows Event ID 4624
      - Active Directory User Account Attributes
      - Domain Controllers
      - Active Directory Database
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          WATCHLIST = get_disabled_accounts_from_AD()
          SEARCH EventID:4624 AND LogonStatus:Success
          IF TargetUserName IN WATCHLIST THEN ALERT
  - question: How can we statistically detect and quantify successful logons from disabled accounts?
    context: The expected number of successful logons for any disabled account is zero. Therefore, any logon event for such an account is a significant statistical anomaly. This question focuses on monitoring for this zero-to-one transition. By also tracking the rate of these events, analysts can quickly gauge the scope of the compromise if an adversary is using the skeleton key backdoor to access multiple accounts.
    answer_sources:
      - Windows Event ID 4624
      - Active Directory User Account Attributes
      - Domain Controllers
      - Active Directory Database
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          SEARCH EventID:4624 AND user.account_status = "disabled"
          COUNT successful_logons
          IF successful_logons > 0 THEN ALERT
  - question: How can machine learning help analyze the pattern of successful logons from disabled accounts?
    context: This question suggests using a time-series model to monitor the volume and variety of disabled accounts that are successfully authenticating. A sudden spike from zero would confirm the initial compromise. A subsequent increase in the number of distinct disabled accounts being used could indicate that the adversary is actively using the backdoor for lateral movement or privilege escalation, providing valuable insight into the progression of the attack.
    answer_sources:
      - Windows Event ID 4624
      - Active Directory User Account Attributes
      - Domain Controllers
      - Active Directory Database
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          MODEL = train_timeseries_model(distinct_disabled_user_logons_per_hour)
          OBSERVE current_logons
          IF current_logons IS ANOMALY (spike from zero or increase in variety) THEN ALERT
  - question: How can we symbolically detect unauthorized interactive logons to domain controllers?
    context: Interactive logons (e.g., Remote Desktop) to domain controllers should be restricted to a small, authorized set of administrative accounts. This question proposes a straightforward detection method: maintain an explicit allow-list of these authorized accounts and generate an alert for any interactive logon (Logon Type 2, 7, or 10) to a DC by an account not on that list. This is a simple but effective way to enforce policy and detect potential misuse.
    answer_sources:
      - Windows Event ID 4624
      - Domain Controllers' authentication logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          ALLOW_LIST = get_authorized_dc_interactive_users()
          SEARCH EventID:4624 AND LogonType IN (2, 7, 10) on host.role="domain_controller"
          IF TargetUserName NOT IN ALLOW_LIST THEN ALERT
  - question: How can we statistically detect anomalous interactive logons to domain controllers?
    context: This question focuses on user behavior analytics (UBA) to find suspicious logons without a pre-defined allow-list. By building a historical profile for each user's logon behavior on domain controllers, the system can identify when a user performs an action that is abnormal for them. A "first-time seen" interactive logon by an account that has never done so before (e.g., a service account) is a strong statistical anomaly that warrants investigation.
    answer_sources:
      - Windows Event ID 4624
      - Domain Controllers' authentication logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          For each user, BASELINE historical logon_types over 90 days
          SEARCH EventID:4624 AND LogonType IN (2, 7, 10) on host.role="domain_controller"
          IF historical_frequency for this user and logon_type is 0 THEN ALERT
  - question: How can machine learning be used to detect anomalous user logon behavior on domain controllers?
    context: This question proposes using clustering algorithms to group users based on their typical logon patterns (types, times, sources). This creates a data-driven model of "normal" behavior for different user cohorts (e.g., service accounts, domain admins, regular users). An account suddenly shifting from one behavior cluster to another—for example, a service account suddenly exhibiting behavior typical of an interactive admin—is a significant anomaly that points to credential misuse or compromise.
    answer_sources:
      - Windows Event ID 4624
      - Domain Controllers' authentication logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          CLUSTERS = create_user_behavior_clusters(logon_types, frequency, time_of_day)
          For each new logon, CHECK if user has moved to a new cluster
          IF user_moves_from_service_acct_cluster_to_interactive_admin_cluster THEN ALERT
  - question: How can we symbolically detect the execution of known malicious tools on domain controllers?
    context: Adversaries often use well-known tools for credential dumping and authentication patching. This question focuses on detecting these tools by their names or original filenames as recorded in process creation events (Sysmon Event ID 1). By matching these against a constantly updated threat intelligence feed of malicious tool names and hashes, we can catch low-effort attempts to run these tools on domain controllers.
    answer_sources:
      - Windows Event ID 4688
      - Sysmon Event ID 1
      - Domain Controllers' process execution logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          THREAT_FEED = get_malicious_tool_names_and_hashes()
          SEARCH SysmonID:1 on host.role="domain_controller"
          IF Image IN THREAT_FEED.names OR OriginalFileName IN THREAT_FEED.names OR Hash IN THREAT_FEED.hashes THEN ALERT
  - question: How can we statistically detect rare or unusual processes executing on domain controllers?
    context: Adversaries may use custom-compiled or renamed tools to evade name-based detection. This question proposes a statistical approach to find them. By establishing a baseline of all processes that normally run on domain controllers, any process that is exceptionally rare (e.g., seen only once across the entire fleet) becomes suspicious, especially if it is not signed by a trusted software publisher. This helps uncover novel or unknown tools.
    answer_sources:
      - Windows Event ID 4688
      - Sysmon Event ID 1
      - Domain Controllers' process execution logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          BASELINE process names on all domain_controllers and calculate frequency
          SEARCH process_creation on host.role="domain_controller"
          IF process_name.frequency < 1st_percentile AND process.is_signed = false THEN ALERT
  - question: How can machine learning be used to detect renamed or slightly altered malicious tool names?
    context: To bypass simple blocklists, adversaries may make minor modifications to tool names (e.g., 'm1m1katz.exe' instead of 'mimikatz.exe'). This question suggests using a machine learning model trained on lexical features of process names, such as character-level n-grams. Such a model can learn the general "shape" of malicious tool names and detect these variations, which would be missed by exact string matching.
    answer_sources:
      - Windows Event ID 4688
      - Sysmon Event ID 1
      - Domain Controllers' process execution logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          MODEL = train_classifier(character_n_grams_of_process_names)
          FOR new_process in process_creation_events
            SCORE = model.predict(new_process.name)
            IF SCORE > malicious_threshold THEN ALERT
  - question: How can we symbolically detect unauthorized processes accessing LSASS memory on domain controllers?
    context: The Local Security Authority Subsystem Service (LSASS) process stores credentials in memory, making it a prime target for adversaries. This question focuses on using Sysmon Event ID 10 to monitor for any process that attempts to read LSASS memory. By maintaining a whitelist of legitimate processes that are allowed to perform this action (e.g., system processes, EDR agents), any access from a non-whitelisted process can be treated as a high-confidence alert for credential dumping.
    answer_sources:
      - Sysmon Event ID 10
      - Domain Controllers' process memory access logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          WHITELIST = [wininit.exe, services.exe, edr.exe]
          SEARCH SysmonID:10 AND TargetImage:"lsass.exe" on host.role="domain_controller"
          IF SourceImage NOT IN WHITELIST THEN ALERT
  - question: How can we statistically detect anomalous access to LSASS memory?
    context: Beyond simple whitelisting, this question proposes analyzing access to LSASS memory statistically. A process that has never accessed LSASS before performing this action for the first time is a significant behavioral anomaly. Furthermore, even legitimate processes request specific access rights; if a process suddenly requests a higher-privilege access mask (like read/write) than it normally does, this deviation from its own baseline behavior is highly suspicious.
    answer_sources:
      - Sysmon Event ID 10
      - Domain Controllers' process memory access logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          // First-time access check
          BASELINE processes that access lsass.exe
          IF new_process_accessing_lsass NOT IN BASELINE THEN ALERT

          // Unusual access rights check
          BASELINE GrantedAccess rights per process
          IF new_access_request has unusual GrantedAccess mask THEN ALERT
  - question: How can machine learning be used to detect attack sequences leading to LSASS memory access?
    context: Credential dumping is often the culmination of a series of actions. This question suggests using a sequence anomaly detection model, such as an LSTM autoencoder, to learn the normal sequences of events that precede legitimate system activity. An attack sequence—such as a process being created from a strange directory, loading suspicious DLLs, and then accessing LSASS—would deviate from these learned normal patterns and be flagged as a multi-stage anomaly.
    answer_sources:
      - Sysmon Event ID 10
      - Domain Controllers' process memory access logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          MODEL = train_lstm_autoencoder(sequences_of_events_before_lsass_access)
          For each new sequence leading to lsass access
            RECONSTRUCTION_ERROR = model.compare(sequence)
            IF RECONSTRUCTION_ERROR > threshold THEN ALERT
  - question: How can we symbolically detect unauthorized modifications to critical authentication DLLs?
    context: Adversaries may patch critical authentication-related DLLs on disk (e.g., msv1_0.dll, samsrv.dll) to create a persistent backdoor. This question proposes using file system auditing to monitor for any write or delete events on these specific files within the System32 directory. By whitelisting the legitimate 'TrustedInstaller.exe' process, any modification by another process becomes a high-fidelity indicator of tampering.
    answer_sources:
      - Sysmon Event ID 11
      - Windows Event ID 4663
      - Domain Controllers' C:\Windows\System32 directory
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          CRITICAL_DLLS = [msv1_0.dll, samsrv.dll, cryptdll.dll]
          SEARCH (SysmonID:11 OR EventID:4663) for file_modifications in System32
          WHERE TargetFile IN CRITICAL_DLLS AND ProcessName != "TrustedInstaller.exe"
          ALERT
  - question: How can we statistically detect the tampering of critical authentication DLLs?
    context: To detect subtle or offline tampering, this question suggests a statistical approach based on file integrity monitoring. By establishing a baseline hash (e.g., SHA256) for every critical authentication DLL on all domain controllers, we can periodically re-calculate the hashes and compare them. Any mismatch against the known-good baseline is a definitive sign of modification. Additionally, a sudden spike in file modifications in the System32 directory outside a patch window is a statistical anomaly worth investigating.
    answer_sources:
      - Sysmon Event ID 11
      - Windows Event ID 4663
      - Domain Controllers' C:\Windows\System32 directory
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          BASELINE hashes of critical DLLs on all domain_controllers
          PERIODICALLY re-hash DLLs and compare to baseline
          IF hash_mismatch THEN ALERT
  - question: How can machine learning be used to assess the risk of file modifications in System32?
    context: This question proposes using machine learning to add context to file modification events. A time-series model can predict normal patching cycles, flagging any modification in System32 that occurs at an anomalous time. Concurrently, a classification model can analyze the process that performed the modification, scoring it for maliciousness based on its name, parent process, and signature status. This combination helps distinguish between benign updates and malicious tampering.
    answer_sources:
      - Sysmon Event ID 11
      - Windows Event ID 4663
      - Domain Controllers' C:\Windows\System32 directory
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          // Time-series for event timing
          MODEL_TIME = train_timeseries_model(file_mod_events_in_system32)
          IF current_mod_event is anomaly in time-series THEN ALERT

          // Classifier for actor process
          MODEL_ACTOR = train_classifier(process_features)
          SCORE = MODEL_ACTOR.predict(modifying_process)
          IF SCORE > malicious_threshold THEN ALERT
  - question: How can we symbolically detect a potential MFA bypass?
    context: If an adversary has patched the authentication process (e.g., with a skeleton key), they may be able to bypass multi-factor authentication (MFA). This question focuses on detecting this by correlating remote logon events with MFA provider logs. For every successful remote Windows logon, there must be a corresponding successful MFA event from the same user and IP address within a short time window. The absence of this MFA event is a critical alert for a potential bypass.
    answer_sources:
      - Windows Event ID 4624
      - MFA Provider Logs
      - Zeek conn.log
      - VPN Logs
      - Domain Controllers
      - VPN Concentrators
      - MFA Authentication Servers
      - Network Gateway
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          SEARCH EventID:4624 AND LogonType IN (3, 10)
          For each event, LOOKUP in mfa_logs for successful_auth
          WHERE user=event.user AND ip=event.ip AND time is within 2 mins
          IF no_mfa_event_found THEN ALERT
  - question: How can we statistically detect a potential MFA bypass?
    context: This question proposes a statistical method to find MFA bypasses at scale. For each user, the ratio of successful remote Windows logons to successful MFA authentications should be approximately $$ 1.0 $$. By monitoring this ratio over a rolling window, a sudden drop—indicating many Windows logons are occurring without corresponding MFA events—serves as a strong statistical indicator that an MFA bypass mechanism is being exploited.
    answer_sources:
      - Windows Event ID 4624
      - MFA Provider Logs
      - Zeek conn.log
      - VPN Logs
      - Domain Controllers
      - VPN Concentrators
      - MFA Authentication Servers
      - Network Gateway
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          For each user, CALCULATE ratio = count(remote_windows_logons) / count(mfa_success_logons) over 24h
          IF ratio << 1.0 THEN ALERT
  - question: How can machine learning detect MFA bypass through sequence analysis?
    context: A normal remote logon sequence has a predictable flow: VPN connection, followed by Windows authentication, followed by an MFA success event. This question suggests training a time-series or sequence model on these event streams. The model learns the expected order and timing of events for a valid session. An observed sequence that deviates from this pattern, such as a missing MFA event or an unusual delay, would be flagged by the model as a sequence anomaly indicative of a bypass.
    answer_sources:
      - Windows Event ID 4624
      - MFA Provider Logs
      - Zeek conn.log
      - VPN Logs
      - Domain Controllers
      - VPN Concentrators
      - MFA Authentication Servers
      - Network Gateway
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          MODEL = train_sequence_model(vpn_connect, windows_logon, mfa_success)
          OBSERVE live event streams for user sessions
          IF observed_sequence deviates from learned_pattern (e.g., missing MFA event) THEN ALERT
  - question: How can we symbolically detect the use of honey-token accounts?
    context: A honey-token account is a high-privilege but disabled account created specifically as a tripwire. It should never be used. This question outlines a simple, high-fidelity detection: create a rule that generates an immediate, critical alert for any successful logon event (Windows Event ID 4624) where the target username matches one of the predefined honey-token accounts. Any such logon is a definitive sign of compromise.
    answer_sources:
      - Windows Event ID 4624
      - Active Directory User Account Attributes
      - Domain Controllers
      - Active Directory Database
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          HONEY_TOKENS = [acct1, acct2, acct3]
          SEARCH EventID:4624 AND LogonStatus:Success
          WHERE TargetUserName IN HONEY_TOKENS
          TRIGGER CRITICAL ALERT
  - question: How can we statistically analyze the use of honey-token accounts?
    context: The baseline logon frequency for any disabled honey-token account is zero. Therefore, any successful logon represents an infinite statistical deviation from the norm and is a clear indicator of compromise. This question focuses on not just the initial event, but also tracking the number of unique honey-token accounts that are successfully used over time. An increase in this count suggests the adversary is actively exploring the network and discovering these deceptive accounts.
    answer_sources:
      - Windows Event ID 4624
      - Active Directory User Account Attributes
      - Domain Controllers
      - Active Directory Database
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          SEARCH EventID:4624 AND TargetUserName IN honey_token_list
          COUNT distinct TargetUserName over time
          IF count > 0 THEN ALERT
          IF rate_of_new_honey_tokens_used increases THEN ESCALATE
  - question: How can machine learning enrich alerts from honey-token usage?
    context: While a honey-token logon is itself a critical alert, machine learning can automatically add valuable context to aid the response. This question suggests using a classification model to analyze the source of the logon (IP address, hostname). The model can instantly classify the source as internal or external, trusted or untrusted, or even match it against known adversary infrastructure, helping security analysts to immediately understand the nature of the threat and prioritize their actions.
    answer_sources:
      - Windows Event ID 4624
      - Active Directory User Account Attributes
      - Domain Controllers
      - Active Directory Database
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          ON honey_token_logon_alert:
            SOURCE_IP = alert.source_ip
            MODEL = train_ip_classifier(ip_features)
            CLASSIFICATION = model.predict(SOURCE_IP)
            ENRICH alert with CLASSIFICATION (e.g., "internal", "TOR exit node")
  - question: How can we symbolically detect the 'fail-then-succeed' logon pattern indicative of a skeleton key?
    context: A classic behavioral signature for a skeleton key attack is a failed logon attempt due to a bad password (Event ID 4625), immediately followed by a successful logon (Event ID 4624) for the same user from the same source. The adversary first tries a random password which fails, then uses the skeleton key which succeeds. This question proposes a correlation rule to detect this specific sequence within a very short time window (e.g., 5 seconds), which is a strong indicator of this attack.
    answer_sources:
      - Windows Event ID 4624
      - Windows Event ID 4625
      - Domain Controllers' authentication logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          SEARCH for EventID:4625 with Status:0xc000006d
          CORRELATE with EventID:4624 within 5 seconds
          WHERE user and source_ip are the same
          IF match found THEN ALERT
  - question: How can we statistically detect the 'fail-then-succeed' logon pattern?
    context: Normal users who mistype a password might wait a few seconds before re-entering it. An automated skeleton key attack, however, will show a near-instantaneous transition from failure to success. This question suggests analyzing the time delay between a user's failed and subsequent successful logon. A distribution of these time deltas clustered very close to zero for a particular user or source IP is a statistical anomaly compared to normal human behavior and could indicate an automated attack.
    answer_sources:
      - Windows Event ID 4624
      - Windows Event ID 4625
      - Domain Controllers' authentication logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          CALCULATE time_delta between EventID:4625 and EventID:4624 for same user/IP
          ANALYZE distribution of time_delta
          IF distribution is clustered near 0 seconds THEN ALERT
  - question: How can machine learning detect the 'fail-then-succeed' logon pattern?
    context: This question proposes using a sequence analysis model to more robustly identify the malicious 'fail-then-succeed' pattern in the authentication log stream. The model can be trained to distinguish the specific, rapid pattern of a skeleton key attack from benign behavior, such as a user quickly correcting a password typo. It can do this by incorporating additional context, such as the frequency of the behavior, the source IP's reputation, and the user account's typical activity.
    answer_sources:
      - Windows Event ID 4624
      - Windows Event ID 4625
      - Domain Controllers' authentication logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          MODEL = train_sequence_model(logon_event_streams)
          DETECT specific sequence [4625(bad_pass), 4624(success)] with minimal time delta
          IF model identifies malicious pattern THEN ALERT
  - question: How can we symbolically detect anomalous lateral movement following a network logon?
    context: After a successful logon, an adversary may use the compromised account to access sensitive resources. This question focuses on a symbolic approach to detecting this. By predefining a list of "crown jewel" assets (e.g., critical servers, databases) and the users authorized to access them, an alert can be triggered if a newly logged-on user immediately attempts to connect to a crown jewel asset they are not authorized to access.
    answer_sources:
      - Windows Event ID 4624
      - Zeek conn.log
      - Member Servers
      - User Workstations
      - Network Segments
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          CROWN_JEWELS_ACL = define_access_controls_for_assets()
          ON successful logon:
            TRACK subsequent network connections from user
            IF connection_destination IN CROWN_JEWELS AND user NOT IN CROWN_JEWELS_ACL
            THEN ALERT
  - question: How can we statistically detect anomalous lateral movement using User Behavior Analytics (UBA)?
    context: This question proposes a User Behavior Analytics (UBA) approach to detect abnormal lateral movement. For each user account, a baseline is established for the number of distinct destination hosts they typically access within an hour. If, after a logon, the account's activity dramatically exceeds its own historical norm (e.g., surpasses the 99th percentile), it indicates a significant deviation from normal behavior, such as rapid lateral movement or network scanning.
    answer_sources:
      - Windows Event ID 4624
      - Zeek conn.log
      - Member Servers
      - User Workstations
      - Network Segments
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          For each user, BASELINE distinct_hosts_accessed_per_hour over 30 days
          MONITOR user activity post-logon
          IF distinct_hosts_accessed_in_hour > user.baseline_99th_percentile
          THEN ALERT
  - question: How can machine learning detect anomalous lateral movement using graph analysis?
    context: User access patterns can be modeled as a graph where nodes are users and hosts, and edges represent logons. This question suggests using graph-based clustering to identify communities of normal access (e.g., the "Finance team" cluster, the "DevOps" cluster). If a user, after logging in, suddenly starts creating connections (edges) to a cluster of hosts they have never interacted with before, it represents a community-based anomaly, strongly suggesting the account is compromised and being used for lateral movement.
    answer_sources:
      - Windows Event ID 4624
      - Zeek conn.log
      - Member Servers
      - User Workstations
      - Network Segments
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          GRAPH = build_user_to_host_access_graph()
          CLUSTERS = detect_communities(GRAPH)
          ON new logon/connection:
            IF new_edge connects user to a new_community
            THEN ALERT
  - question: How can we symbolically detect impossible travel using geographic blocklists?
    context: A simple method for detecting suspicious remote logons is to use a geographic blocklist. This question focuses on this symbolic approach. For every successful remote logon, the source IP address is geolocated. If the source country is on a predefined list of high-risk or prohibited countries, an alert is generated immediately. This provides a basic but effective filter against obvious threats from unauthorized regions.
    answer_sources:
      - Windows Event ID 4624
      - Zeek conn.log
      - VPN Logs
      - Domain Controllers
      - VPN Concentrators
      - Network Gateway
      - Cloud Service Authentication Logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          BLOCKED_COUNTRIES = [CountryA, CountryB]
          ON successful remote logon:
            COUNTRY = geolocate(source_ip)
            IF COUNTRY IN BLOCKED_COUNTRIES THEN ALERT
  - question: How can we statistically detect impossible travel by calculating travel velocity?
    context: This question describes the classic "impossible travel" detection. For each new successful user logon, the system looks up the location of the previous logon. It then calculates the distance and time elapsed between the two events. If the implied travel velocity required to cover that distance in that time is physically impossible (e.g., faster than a commercial jet), it is a high-confidence statistical indicator that the same user's credentials are being used from two different locations simultaneously.
    answer_sources:
      - Windows Event ID 4624
      - Zeek conn.log
      - VPN Logs
      - Domain Controllers
      - VPN Concentrators
      - Network Gateway
      - Cloud Service Authentication Logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          ON successful logon:
            PREV_LOGON = get_user_previous_logon_location_and_time()
            DISTANCE = great_circle_distance(current_location, PREV_LOGON.location)
            TIME_DELTA = current_time - PREV_LOGON.time
            VELOCITY = DISTANCE / TIME_DELTA
            IF VELOCITY > 600 mph THEN ALERT
  - question: How can machine learning detect anomalous geographic logon locations?
    context: Beyond simple velocity checks, machine learning can build a more nuanced understanding of a user's normal geographic behavior. This question suggests using a clustering algorithm like DBSCAN to identify a user's typical logon locations (e.g., "Office," "Home," "Local Coffee Shop"). A new logon that falls far outside of any of these established clusters is flagged as a spatial anomaly, even if it doesn't trigger a velocity alert. This can detect an adversary logging in from a new, unexpected location.
    answer_sources:
      - Windows Event ID 4624
      - Zeek conn.log
      - VPN Logs
      - Domain Controllers
      - VPN Concentrators
      - Network Gateway
      - Cloud Service Authentication Logs
    range: Last 90 days
    queries:
      - technology: pseudocode
        query: |
          For each user, CLUSTERS = dbscan(historical_logon_geolocations)
          ON successful logon:
            NEW_LOCATION = geolocate(source_ip)
            IF NEW_LOCATION is noise (not in any cluster) THEN ALERT