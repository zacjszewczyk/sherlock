name: T1562.003: Impair Command History Logging
id: 5a8e0f9c-7b1d-4e2a-8f6c-9a0b3d1e4f5a
description: This playbook focuses on detecting if an adversary is actively impairing command history logging on enterprise endpoints or servers to evade detection. This involves identifying processes matching known history-clearing tools, command-line arguments that disable or clear shell history, anomalous execution contexts for such commands, suspicious sequences of TTPs following history impairment, and direct manipulation of shell history files (e.g., deletion, truncation, or linking to /dev/null).
type: technique
related:
  - TA0005: Defense Evasion
contributors:
  - Zachary Szewczyk
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags:
  - none
investigative_questions:
  - question: Are processes being created that match known threat intelligence indicators for tools designed to impair command history?
    context: This question seeks to identify the execution of known malicious tools used for defense evasion. By continuously monitoring process creation events and comparing file hashes (SHA256) and script block content hashes against a curated threat intelligence feed, analysts can detect the presence of specific history-clearing utilities. A match indicates a high-confidence attempt to cover tracks and should be treated as a high-priority alert.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE), osquery process_events. Data should be sourced from a SIEM/EDR log repository aggregating process execution data from all Windows, Linux, and macOS endpoints and servers, correlated with a Threat Intelligence Platform.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH process_creation_events WHERE (process_hash IN threat_intel_hashes) OR (script_block_hash IN threat_intel_hashes)
  - question: Are rare or uncommon processes, known to be history-impairment tools, running in the environment?
    context: This question aims to find adversary tools that are not part of standard software deployments. By calculating the prevalence of every executed process hash across the enterprise, analysts can identify tools that are outliers. Flagging a process that both matches a history-impairment signature and has a very low prevalence (e.g., running on less than 1% of hosts) helps distinguish targeted attacker activity from potentially widespread but benign tools.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE), osquery process_events. Data should be sourced from a SIEM/EDR log repository aggregating process execution data from all Windows, Linux, and macOS endpoints and servers, correlated with a Threat Intelligence Platform.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: CALCULATE prevalence for each process_hash over 30 days. ALERT where (process_hash IN history_impairment_hashes) AND (prevalence < 1%)
  - question: Can we use machine learning to predictively identify processes intended to impair command history based on their execution characteristics?
    context: This question leverages machine learning to detect novel or obfuscated history-impairment tools that might not have known signatures. By training a classifier on features like process name entropy, argument count, parent process, user context, and network activity, the model can learn the behavioral profile of such tools. This allows for the detection of suspicious processes even if their hash is unknown, providing a more resilient detection strategy.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE), osquery process_events. Data should be sourced from a SIEM/EDR log repository aggregating process execution data from all Windows, Linux, and macOS endpoints and servers, correlated with a Threat Intelligence Platform.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: PREDICT is_history_impairment using classifier with features (process_name_entropy, arg_count, parent_process, user_context, network_connections)
  - question: Are command lines or script blocks containing specific strings, arguments, or patterns known to disable or clear shell history being executed?
    context: This question focuses on detecting the explicit commands used to manipulate shell history. By creating a watchlist of known commands and regex patterns (e.g., `Set-PSReadLineOption -HistorySaveStyle SaveNothing`, `unset HISTFILE`, `history -c`), analysts can scan command-line logs for direct evidence of this technique. A match is a strong indicator of intentional evasion and should trigger a high-severity alert.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE), osquery shell_history, Syslog from network devices. Data should be sourced from a SIEM platform aggregating command-line logs from all enterprise endpoints, servers, and network devices with command logging capabilities.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH command_line_logs WHERE command_line MATCHES REGEX ('Set-PSReadLineOption -HistorySaveStyle SaveNothing'|'unset HISTFILE'|'history -c'|'export HISTFILESIZE=0'|...)
  - question: Is any user executing history-manipulation commands at a statistically anomalous rate?
    context: This question aims to identify abnormal usage of commands that can impair history, even if those commands have legitimate use cases. By establishing a baseline of normal execution frequency for these sensitive commands per user, a sudden, statistically significant spike (e.g., an outlier in a Poisson distribution model) can indicate malicious activity, such as an adversary repeatedly clearing their tracks during an interactive session.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE), osquery shell_history, Syslog from network devices. Data should be sourced from a SIEM platform aggregating command-line logs from all enterprise endpoints, servers, and network devices with command logging capabilities.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FOR each user, BASELINE frequency of sensitive_commands. ALERT if daily_count is a statistical outlier (p_value < 0.01) from baseline.
  - question: Can a natural language model detect obfuscated or semantically similar history evasion commands that static rules might miss?
    context: This question addresses the challenge of adversaries obfuscating their commands to evade simple regex or string matching. A fine-tuned language model can understand the semantic intent behind a command, allowing it to identify variations like `('Save' + 'Nothing')` or those using environment variables. This provides a more advanced and robust method for detecting command-line based evasion techniques.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE), osquery shell_history, Syslog from network devices. Data should be sourced from a SIEM platform aggregating command-line logs from all enterprise endpoints, servers, and network devices with command logging capabilities.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: PREDICT is_evasive_command using fine_tuned_BERT_model on command_line_text.
  - question: Is a history impairment command being executed in a suspicious context, such as by a non-standard parent process or immediately after a remote login from a new location?
    context: This question adds context to the execution of a history impairment command to reduce false positives and increase confidence in findings. An adversary's actions often deviate from normal user behavior. Correlating a history-clearing command with an unusual parent process (not a typical shell) or a recent remote login from a previously unseen country strongly suggests malicious activity, as it combines the 'what' (evasion) with the 'how' (anomalous session context).
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4624, Zeek conn.log, osquery logged_in_users, Linux auditd logs. Data should be sourced from a SIEM platform capable of correlating authentication logs (Windows, Zeek), process logs (Windows, Linux), and IP geolocation enrichment data.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: ALERT on history_impairment_command IF (parent_process NOT IN [common_shells]) OR (time_since_remote_login_from_new_geo < 5_minutes).
  - question: Are user sessions that contain a history impairment command also exhibiting an unusually high degree of command randomness or variety?
    context: This question seeks to identify sessions where an adversary is performing reconnaissance or executing a wide variety of tools, a pattern distinct from typical, focused user activity. By calculating the Shannon entropy of commands executed early in a session, we can quantify this randomness. A high entropy value combined with the presence of a history impairment command suggests an exploratory, and likely malicious, session that the actor is trying to hide.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4624, Zeek conn.log, osquery logged_in_users, Linux auditd logs. Data should be sourced from a SIEM platform capable of correlating authentication logs (Windows, Zeek), process logs (Windows, Linux), and IP geolocation enrichment data.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FOR each user_session, CALCULATE command_sequence_entropy in first 10 minutes. ALERT IF (history_impairment_command is present) AND (entropy is in top 5th percentile for user).
  - question: Can a time-series model detect anomalous user sessions where a spike in abnormal activity coincides with a history impairment command?
    context: This question uses an unsupervised machine learning model to learn the normal sequence of a user's session activity, including process execution, network connections, and file modifications. An LSTM autoencoder, for example, can identify when a user's current actions deviate significantly from their learned normal behavior (high reconstruction error). If this deviation occurs immediately after a history impairment command is used, it provides a strong, behavior-based signal of a compromised session.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4624, Zeek conn.log, osquery logged_in_users, Linux auditd logs. Data should be sourced from a SIEM platform capable of correlating authentication logs (Windows, Zeek), process logs (Windows, Linux), and IP geolocation enrichment data.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FOR each user_session, MODEL activity with LSTM autoencoder. ALERT if reconstruction_error spikes after a history_impairment_command is observed.
  - question: Are history impairment commands being followed by commands associated with discovery, credential access, or execution within the same user session?
    context: This question looks for a common attacker tradecraft sequence: first, disable logging, then perform malicious actions. By using a stateful detection rule that tracks user sessions, an analyst can specifically alert when a history clearing command is followed by known reconnaissance (`whoami`, `net user`), credential access (`cat /etc/shadow`), or execution (`psexec`) commands. This chaining of TTPs is a powerful indicator of an active adversary.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE). Data should be sourced from critical servers (Domain Controllers, file servers), administrator workstations, and developer endpoints.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: TRACK user_sessions by Logon ID. SET state=suspicious on history_impairment_command. ALERT if subsequent command is on discovery/credential_access/execution watchlist while state is suspicious. Timeout state after 1 hour.
  - question: Are we observing rare sequences of MITRE ATT&CK techniques that begin with history impairment?
    context: This question abstracts individual commands into their corresponding MITRE ATT&CK techniques to identify suspicious high-level behaviors. By calculating the probability of all observed sequences of three techniques (trigrams), analysts can flag those that are extremely rare in the organization. A sequence starting with Impair Defenses (T1562.003) followed by other techniques that has a very low probability is a strong statistical indicator of an unusual and potentially malicious attack chain.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE). Data should be sourced from critical servers (Domain Controllers, file servers), administrator workstations, and developer endpoints.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: TOKENIZE command sequences into MITRE technique trigrams. CALCULATE probability of each trigram. ALERT if trigram starts with T1562.003 and probability < 0.05%.
  - question: Can a sequence prediction model identify when a user's command sequence deviates from normal behavior immediately after a history impairment command is used?
    context: This question uses predictive modeling to spot attacks. A Seq2Seq model is trained on vast amounts of known benign command sequences to learn what a 'normal next command' looks like for different users. When a live command sequence is analyzed, the model predicts what should come next. If a user issues a history impairment command, and their subsequent actions significantly diverge from the model's predictions, it signals a strong anomaly, suggesting the user (or an attacker impersonating them) has broken their normal pattern of behavior to perform malicious actions.
    answer_sources:
      - Windows Event ID 4688, Windows Event ID 4104, Linux auditd logs (type=EXECVE). Data should be sourced from critical servers (Domain Controllers, file servers), administrator workstations, and developer endpoints.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: PREDICT next_command using Seq2Seq model on user's command history. ALERT if history_impairment_command is seen AND actual_next_command deviates significantly from predicted_next_command.
  - question: Are default shell history files being deleted, truncated, or symbolically linked to /dev/null?
    context: This question focuses on direct file-level manipulation of history logs. By using File Integrity Monitoring (FIM) or native OS auditing (like auditd) to watch specific history files (e.g., `.bash_history`, `ConsoleHost_history.txt`), analysts can get high-fidelity alerts on destructive actions. Events like deletion, truncation to zero bytes, or symlinking to `/dev/null` are unambiguous attempts to destroy evidence and should be investigated immediately.
    answer_sources:
      - Windows Event ID 4663, Windows Event ID 4688, Linux auditd logs (type=SYSCALL, syscall=unlink,truncate,symlink), osquery file_events. Data should be sourced from a File Integrity Monitoring (FIM) system and SIEM, monitoring user profile directories (`~`, `%APPDATA%`) on all endpoints and servers.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: ALERT on FIM/auditd event IF (event_type IN [delete, truncate, symlink]) AND (target_file_path IS a_default_history_file).
  - question: Is a user's shell history file failing to update despite ongoing interactive shell activity?
    context: This question identifies a more subtle form of history impairment where the file itself isn't deleted, but logging is silently disabled. By correlating process execution logs (showing shell commands are being run) with file metadata, analysts can detect a discrepancy. If a user is actively running commands but their history file's timestamp and size remain static, it's a strong statistical anomaly indicating that history saving has been disabled in memory for that session.
    answer_sources:
      - Windows Event ID 4663, Windows Event ID 4688, Linux auditd logs (type=SYSCALL, syscall=unlink,truncate,symlink), osquery file_events. Data should be sourced from a File Integrity Monitoring (FIM) system and SIEM, monitoring user profile directories (`~`, `%APPDATA%`) on all endpoints and servers.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FOR active users, IF (count(shell_commands_in_last_15m) > 5) AND (history_file_last_modified_time is unchanged), FLAG as anomaly.
  - question: Can a time-series forecasting model detect anomalous changes in the size of a user's shell history file?
    context: This question uses a forecasting model to predict the expected growth of a history file based on the user's past activity and recent command volume. A model like ARIMA can create a forecast with a confidence interval. An anomaly is detected if the actual file size suddenly drops to zero or flatlines during an active session, falling outside this predicted range. This provides a quantitative, model-driven method for detecting file tampering that goes beyond simple static rules.
    answer_sources:
      - Windows Event ID 4663, Windows Event ID 4688, Linux auditd logs (type=SYSCALL, syscall=unlink,truncate,symlink), osquery file_events. Data should be sourced from a File Integrity Monitoring (FIM) system and SIEM, monitoring user profile directories (`~`, `%APPDATA%`) on all endpoints and servers.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FORECAST expected_history_file_size using ARIMA model based on command volume. ALERT if actual_file_size deviates significantly from forecast (e.g., drops to zero).