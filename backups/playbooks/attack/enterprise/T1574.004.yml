name: T1574.004: Dylib Hijacking
id: f47ac10b-58cc-4372-a567-0e02b2c3d479
description: This playbook helps investigate potential Dylib Hijacking (T1574.004) on macOS endpoints. Adversaries may use this technique to achieve persistence by placing malicious dylibs in the search paths of auto-starting applications. It can also be used for privilege escalation by targeting SUID/GUID binaries or for defense evasion by injecting code into trusted, signed processes. The investigation focuses on identifying suspicious dylib file creations, unusual process-dylib relationships, and anomalous network behavior from processes that may have been hijacked. Evidence includes unsigned or ad-hoc signed dylibs, dylibs loaded from user-writable or rare locations, and trusted processes making unexpected network connections or spawning shells.
type: technique
related:
  - TA0003: Persistence
  - TA0004: Privilege Escalation
  - TA0005: Defense Evasion
contributors:
  - Zachary Szewczyk
  - Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Is a newly created dylib malicious based on its hash or signature?
    context: Adversaries often use custom-compiled dylibs for hijacking. These dylibs may be unsigned, ad-hoc signed to bypass basic checks, or signed with a non-trusted developer certificate. Checking the hash against threat intelligence feeds and validating the signature are crucial first steps to identify known-bad or suspicious libraries at the time of creation.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE)
      - osquery file table (path, sha256)
      - osquery authenticode table
      - macOS endpoints, specifically LaunchAgent/LaunchDaemon plists in /Library/LaunchDaemons, /Library/LaunchAgents, ~/Library/LaunchAgents, and application bundles in /Applications/, ~/Applications/, and user-writable library paths like ~/Library/.
    range: last 90 days
    queries:
      - pseudocode: ON file_create WHERE file.extension == 'dylib' | LOOKUP file.sha256 in threat_intel | JOIN file.path with osquery_authenticode | ALERT IF threat_intel.match OR authenticode.result IN ('unsigned', 'adhoc', 'untrusted')
  - question: Has an auto-starting application loaded a new or unusual set of dylibs compared to its historical baseline?
    context: Legitimate auto-starting applications typically load a consistent set of dynamic libraries. A significant deviation from this baseline, such as the introduction of a new dylib, can indicate a hijacking attempt. Using a Jaccard similarity index provides a quantitative measure of this change, allowing for automated detection of anomalies.
    answer_sources:
      - osquery process_open_files table
      - macOS endpoints, specifically LaunchAgent/LaunchDaemon plists in /Library/LaunchDaemons, /Library/LaunchAgents, ~/Library/LaunchAgents, and application bundles in /Applications/, ~/Applications/, and user-writable library paths like ~/Library/.
    range: last 30 days
    queries:
      - pseudocode: FOR each auto_start_app | BASELINE = get_loaded_dylibs(app, last 30 days) | CURRENT = get_loaded_dylibs(app, now) | SIMILARITY = jaccard_index(BASELINE, CURRENT) | ALERT IF SIMILARITY < 0.95
  - question: Can a machine learning model predict if a dylib file write event is malicious based on its context?
    context: This question moves beyond simple rules to a predictive model. By analyzing features like file path entropy (randomness), the creating process (e.g., a browser vs. a trusted installer), user-writability, and timing, a machine learning model can learn the subtle patterns of malicious dylib placement and score new events in real-time, catching novel threats.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE)
      - macOS endpoints, specifically LaunchAgent/LaunchDaemon plists in /Library/LaunchDaemons, /Library/LaunchAgents, ~/Library/LaunchAgents, and application bundles in /Applications/, ~/Applications/, and user-writable library paths like ~/Library/.
    range: last 90 days
    queries:
      - pseudocode: ON file_create WHERE file.extension == 'dylib' | FEATURES = [entropy(file.path), process.name, is_user_writable(file.path), time_delta_to_app_launch] | SCORE = random_forest_model.predict(FEATURES) | ALERT IF SCORE > 0.9
  - question: Is a system process launched at startup loading a dynamic library from a user-writable directory?
    context: Processes spawned by `launchd` (PID 1) are core to the macOS startup sequence and often run with elevated privileges. These processes should only load libraries from protected system locations. Loading a dylib from a user-writable directory like `/Users/Shared/` or `/tmp/` is highly suspicious and a common pattern for persistence, as it allows an adversary to place malicious code where it will be executed by a trusted process.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_MMAP)
      - osquery process_open_files table
      - osquery processes table (for parent PID)
      - macOS endpoints, focusing on processes spawned by launchd (PID 1) and their file open/memory map events, specifically monitoring user-writable locations like /tmp/, /Users/Shared/, and user home directories.
    range: last 90 days
    queries:
      - pseudocode: ON dylib_load | GET process.ppid | IF process.ppid == 1 AND dylib.path IN ('/Users/Shared/*', '/tmp/*', '/Users/*/*') AND process.name NOT IN (allowlist) | ALERT
  - question: Is an auto-starting process loading a dylib from a statistically rare file path?
    context: Adversaries may place malicious dylibs in obscure but technically valid locations to evade simple path-based detections. By calculating the frequency of all dylib load paths across the entire environment, we can identify outliers. A dylib loaded by a startup process from a path that is rarely used by any application is a strong indicator of an anomaly that warrants investigation.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_MMAP)
      - osquery process_open_files table
      - osquery processes table (for parent PID)
      - macOS endpoints, focusing on processes spawned by launchd (PID 1) and their file open/memory map events, specifically monitoring user-writable locations like /tmp/, /Users/Shared/, and user home directories.
    range: last 30 days
    queries:
      - pseudocode: GLOBAL_PATHS = frequency_count(all_dylib_paths, last 30 days) | ON dylib_load WHERE process.ppid == 1 | RARITY = get_percentile(GLOBAL_PATHS, dylib.path) | ALERT IF RARITY < 5
  - question: Does a graph-based model show a new, high-risk relationship between an auto-starting process and a dylib?
    context: This approach models the system's behavior as a graph of interconnected entities (processes, dylibs, paths). Legitimate operations form a stable, predictable graph structure. A dylib hijack creates a new, anomalous edge, such as a trusted `CalendarAgent` process suddenly loading a dylib from a user's `Downloads` folder. Detecting these new, high-risk connections can uncover sophisticated hijacking attempts.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_MMAP)
      - osquery process_open_files table
      - osquery processes table (for parent PID)
      - macOS endpoints, focusing on processes spawned by launchd (PID 1) and their file open/memory map events, specifically monitoring user-writable locations like /tmp/, /Users/Shared/, and user home directories.
    range: last 90 days
    queries:
      - pseudocode: BASELINE_GRAPH = build_graph(process, dylib, path, last 90 days) | ON dylib_load | NEW_EDGE = (process, dylib, path) | IF NEW_EDGE not in BASELINE_GRAPH AND path is user_writable | ALERT
  - question: Is an auto-starting process, which normally does not use the network, making external connections?
    context: Many system utilities and agents that run at startup have no legitimate reason to communicate over the network. If such a process is observed making external connections, it is a strong signal that its functionality has been co-opted, possibly through dylib hijacking, to establish a command-and-control channel or exfiltrate data.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC)
      - Zeek conn.log
      - Zeek dns.log
      - Network egress points, DNS servers, and macOS endpoints (for process context).
    range: last 90 days
    queries:
      - pseudocode: ON network_connection WHERE dest.ip is not private | GET source_process from endpoint_logs | IF source_process in (non_network_allowlist) | ALERT
  - question: Does the network traffic from an auto-starting process deviate significantly from its established baseline?
    context: Even for processes that legitimately use the network, their behavior is often predictable. A baseline can be created using features like destination ASN, port, protocol, and TLS fingerprint (JA3). A sudden change, such as connecting to a new ASN or using an unusual port, can indicate that the process has been hijacked and is now communicating with an adversary-controlled server.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC)
      - Zeek conn.log
      - Zeek dns.log
      - Network egress points, DNS servers, and macOS endpoints (for process context).
    range: last 90 days
    queries:
      - pseudocode: FOR each auto_start_app | BASELINE = build_network_profile(app, last 90 days) | ON network_connection from app | DEVIATION = calculate_std_dev(connection, BASELINE) | ALERT IF DEVIATION > 4
  - question: Is an auto-starting application exhibiting an anomalous spike in network traffic volume?
    context: This analytic uses time-series forecasting (like ARIMA) to predict the expected network traffic volume for an application. A significant, unexpected spike in data transfer, especially shortly after boot or login, could signify malicious activity like data exfiltration or downloading a second-stage payload, triggered by a dylib hijack.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC)
      - Zeek conn.log
      - Zeek dns.log
      - Network egress points, DNS servers, and macOS endpoints (for process context).
    range: last 90 days
    queries:
      - pseudocode: FOR each auto_start_app | MODEL = train_arima_model(app.traffic, last 90 days) | FORECAST = MODEL.predict(next_hour) | OBSERVED = get_traffic(app, current_hour) | ALERT IF OBSERVED > FORECAST.confidence_interval
  - question: Was a dylib created in a world-writable directory just before a known-vulnerable SUID binary was executed?
    context: This is a classic privilege escalation pattern. An attacker, as a standard user, places a malicious dylib in a location like `/tmp`. They then trigger a privileged (SUID) application that is known to insecurely load libraries from that location. The privileged application inadvertently loads and executes the attacker's code with elevated rights. Correlating these two events in a short time window is a high-fidelity indicator of this attack.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE, ES_EVENT_TYPE_NOTIFY_EXEC)
      - osquery suid_bin table
      - system.log
      - macOS endpoints, focusing on SUID/GUID binaries, privileged helper tools, and world-writable directories such as /tmp/ and /Users/Shared/.
    range: last 90 days
    queries:
      - pseudocode: ON process_exec WHERE process.name in (vulnerable_suid_list) | LOOKUP file_create events in last 60s on same host | IF file.extension == 'dylib' AND file.path is world_writable AND file.owner_uid > 500 | ALERT
  - question: Is a root-level process loading a dylib from a path not seen in its historical baseline?
    context: Processes running as root are the ultimate prize. Their dylib loading behavior should be extremely stable. By creating a strict baseline of which dylibs each root process is allowed to load, any deviation can be flagged. This is particularly critical if the new dylib is loaded from a user-writable path or was recently created, suggesting a live exploit.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE, ES_EVENT_TYPE_NOTIFY_EXEC)
      - osquery suid_bin table
      - system.log
      - macOS endpoints, focusing on SUID/GUID binaries, privileged helper tools, and world-writable directories such as /tmp/ and /Users/Shared/.
    range: last 90 days
    queries:
      - pseudocode: FOR each root_process | BASELINE_PATHS = get_loaded_dylib_paths(process, last 90 days) | ON dylib_load WHERE process.euid == 0 | IF dylib.path not in BASELINE_PATHS | ALERT
  - question: Does a sequence of system events, ending in a privileged execution, match a pattern indicative of dylib hijacking?
    context: This analytic uses an LSTM model, which excels at understanding sequences, to learn the 'grammar' of normal system operations. An attack, such as a user writing a dylib and then running a SUID binary, creates an anomalous sequence that violates this learned grammar. This allows for the detection of the entire attack chain rather than just isolated events.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE, ES_EVENT_TYPE_NOTIFY_EXEC)
      - osquery suid_bin table
      - system.log
      - macOS endpoints, focusing on SUID/GUID binaries, privileged helper tools, and world-writable directories such as /tmp/ and /Users/Shared/.
    range: last 90 days
    queries:
      - pseudocode: ON event_stream (file_creates, process_execs) | SEQUENCE = get_events_for_session() | SCORE = lstm_model.predict(SEQUENCE) | IF SCORE is anomalous AND sequence contains (dylib_write -> suid_exec) | ALERT
  - question: Has a non-root user successfully created a dylib file in a SIP-protected or restricted system directory?
    context: System Integrity Protection (SIP) and standard Unix permissions are designed to prevent non-root users from writing to critical system directories like `/System/Library`. A successful dylib creation in one of these locations by a user process (euid > 0) is a critical security failure. It implies that a vulnerability has been exploited to bypass these fundamental OS protections, almost certainly for privilege escalation.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE)
      - osquery file_events table
      - Protected macOS directories such as /System/, /Library/, /usr/bin/, /usr/sbin/, and privileged Application bundles in /Applications/.
    range: last 90 days
    queries:
      - pseudocode: ON file_create WHERE file.extension == 'dylib' | IF file.path in protected_dirs AND process.euid > 0 | CRITICAL_ALERT
  - question: Did a user process write a dylib to a directory that is statistically rare for that user?
    context: This analytic builds a profile of normal user behavior by tracking which directories each user typically writes to. An adversary attempting to escalate privileges might drop a dylib in an unusual but writable system-adjacent path. An alert is triggered when a user writes a dylib to a location that is an outlier for them, catching behavior that deviates from their personal baseline.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE)
      - osquery file_events table
      - Protected macOS directories such as /System/, /Library/, /usr/bin/, /usr/sbin/, and privileged Application bundles in /Applications/.
    range: last 90 days
    queries:
      - pseudocode: FOR each user | BASELINE_DIRS = frequency_count(user.write_paths, last 90 days) | ON file_create WHERE file.extension == 'dylib' | RARITY = get_percentile(BASELINE_DIRS, file.path) | ALERT IF RARITY < 1
  - question: Does a machine learning model classify a dylib creation event by a user in a system path as anomalous?
    context: A One-Class Support Vector Machine (SVM) is an ideal algorithm for anomaly detection. By training it exclusively on legitimate file write events from non-root users, it learns a precise boundary of what constitutes 'normal' behavior. Any dylib creation that falls outside this boundary, especially in a sensitive system path, is flagged as a high-confidence anomaly, indicating a probable exploit.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_CREATE)
      - osquery file_events table
      - Protected macOS directories such as /System/, /Library/, /usr/bin/, /usr/sbin/, and privileged Application bundles in /Applications/.
    range: last 90 days
    queries:
      - pseudocode: MODEL = train_one_class_svm(legit_file_writes) | ON file_create WHERE file.extension == 'dylib' | FEATURES = [file.path, process.name, user.id] | IF MODEL.predict(FEATURES) == 'anomaly' | ALERT
  - question: Is a trusted, signed macOS process communicating with a known command-and-control (C2) server?
    context: This is a high-fidelity indicator of defense evasion. Adversaries hijack trusted processes (like Safari or even security tools) to blend in their C2 traffic. By correlating network logs against a C2 threat intelligence feed, we can immediately identify when a trusted process on an endpoint is communicating with a known-malicious destination, strongly suggesting it has been hijacked.
    answer_sources:
      - Zeek conn.log (id.resp_h, ja3, ja3s)
      - Zeek dns.log (query, answers)
      - macOS Endpoint Security Framework logs (for process name and path)
      - Network egress points, DNS servers, and macOS endpoints running trusted, signed applications.
    range: last 90 days
    queries:
      - pseudocode: ON network_connection | IF dest.ip in c2_threat_intel_feed | GET source_process from endpoint_logs | IF source_process is trusted_and_signed | CRITICAL_ALERT
  - question: Is the network activity from a trusted process statistically abnormal compared to its multi-featured baseline?
    context: This analytic uses the Mahalanobis distance to score the abnormality of a network connection based on a profile of normal behavior (port, protocol, JA3 hash, etc.). Unlike checking one feature at a time, this method considers correlations between features, making it highly effective at detecting sophisticated C2 traffic that might look normal on the surface but is anomalous in combination.
    answer_sources:
      - Zeek conn.log (id.resp_h, ja3, ja3s)
      - Zeek dns.log (query, answers)
      - macOS Endpoint Security Framework logs (for process name and path)
      - Network egress points, DNS servers, and macOS endpoints running trusted, signed applications.
    range: last 90 days
    queries:
      - pseudocode: FOR each trusted_process | PROFILE = build_mahalanobis_profile(process.net_traffic) | ON network_connection from trusted_process | SCORE = mahalanobis_distance(connection, PROFILE) | ALERT IF SCORE is high
  - question: Does an autoencoder model detect a trusted process's network connection as a high-error reconstruction, indicating an anomaly?
    context: An autoencoder is trained to compress and then reconstruct normal network connection data with minimal error. When a hijacked process generates traffic that deviates from this learned norm, the model will struggle to reconstruct it, resulting in a high reconstruction error. This signals a novel or unusual connection pattern that is likely malicious.
    answer_sources:
      - Zeek conn.log (id.resp_h, ja3, ja3s)
      - Zeek dns.log (query, answers)
      - macOS Endpoint Security Framework logs (for process name and path)
      - Network egress points, DNS servers, and macOS endpoints running trusted, signed applications.
    range: last 90 days
    queries:
      - pseudocode: MODEL = train_autoencoder(legit_network_connections) | ON network_connection | ERROR = MODEL.reconstruction_error(connection) | ALERT IF ERROR is high
  - question: Is a legitimate macOS application (e.g., Safari) being executed from an unusual location like the Downloads folder?
    context: Adversaries may copy a legitimate, trusted application to a user-writable directory. This allows them to place a malicious dylib in the same folder, ensuring the copied application loads it upon execution (a technique called 'sideloading'). Detecting a trusted application running from a non-standard path is a key indicator of this setup for dylib hijacking.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC)
      - osquery process_events table (path, cmdline)
      - User-writable directories on macOS endpoints, such as ~/Downloads, ~/Documents, /Users/Shared/, and /tmp/.
    range: last 90 days
    queries:
      - pseudocode: KNOWN_APPS = get_apps_in('/System/Applications/') | ON process_exec | IF process.name in KNOWN_APPS AND process.path not in KNOWN_APPS.paths AND process.path is user_writable | ALERT
  - question: Is a trusted process running from a path with unusually high entropy (randomness)?
    context: To evade simple path-based detections, adversaries may place their hijacked application bundles in deeply nested or randomized directory structures. Calculating the Shannon entropy of the execution path quantifies this randomness. A trusted process like 'Safari' executing from a path with abnormally high entropy is suspicious and suggests an attempt to hide the malicious payload.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC)
      - osquery process_events table (path, cmdline)
      - User-writable directories on macOS endpoints, such as ~/Downloads, ~/Documents, /Users/Shared/, and /tmp/.
    range: last 90 days
    queries:
      - pseudocode: FOR each process_name | BASELINE_ENTROPY = 99th_percentile(path_entropy, last 90 days) | ON process_exec | CURRENT_ENTROPY = shannon_entropy(process.path) | IF CURRENT_ENTROPY > BASELINE_ENTROPY | ALERT
  - question: Can clustering algorithms identify small, anomalous groups of process executions, such as a trusted app running from a strange location?
    context: DBSCAN is a density-based clustering algorithm that is excellent at finding outliers that don't belong to any cluster. By feeding it features like process path, parent process, and user, it can automatically group normal activity into large clusters. Small, isolated clusters or noise points often represent rare and suspicious events, such as a handful of instances where a trusted app was run from a user's home directory to facilitate a hijack.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC)
      - osquery process_events table (path, cmdline)
      - User-writable directories on macOS endpoints, such as ~/Downloads, ~/Documents, /Users/Shared/, and /tmp/.
    range: last 90 days
    queries:
      - pseudocode: DATA = get_process_exec_features(last 90 days) | CLUSTERS = dbscan(DATA) | FOR each point in CLUSTERS.noise | ALERT
  - question: Is a typically offline application, like Calculator or TextEdit, making network connections or spawning a shell?
    context: Some applications have a very clear and limited purpose and should never perform certain actions. For example, Calculator.app should not make network connections or spawn a shell. If such an event is observed, it is a very strong signal that the process has been hijacked, likely via dylib injection, and is being used for malicious purposes like C2 communication or further command execution.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_FORK)
      - Zeek conn.log
      - Zeek dns.log
      - macOS endpoints and network egress points.
    range: last 90 days
    queries:
      - pseudocode: OFFLINE_APPS = ['Calculator.app', 'TextEdit.app'] | ON event | IF process.name in OFFLINE_APPS AND (event is network_connection OR event is spawn_shell) | ALERT
  - question: Has a non-network-facing application spawned a child process that is statistically rare for it?
    context: While a simple rule can check for shell processes, a more advanced approach is to baseline all parent-child process relationships. A non-network-facing application like TextEdit spawning any child process is unusual, but spawning a network utility like `curl` or `nc` is a particularly strong indicator of compromise. This method detects a wider range of post-hijack activity.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_FORK)
      - Zeek conn.log
      - Zeek dns.log
      - macOS endpoints and network egress points.
    range: last 30 days
    queries:
      - pseudocode: FOR each parent_process | BASELINE_CHILDREN = frequency_count(child_processes, last 30 days) | ON process_fork | IF parent_process in OFFLINE_APPS and frequency(child_process, BASELINE_CHILDREN) < 0.01 | ALERT
  - question: Does a graph-based model of process relationships detect the creation of an anomalous edge, such as TextEdit spawning zsh?
    context: This analytic models the entire system's process lineage as a graph. Legitimate parent-child relationships form the known, trusted edges of this graph. A hijacking event that causes a process to spawn an unusual child creates a new edge that did not exist in the baseline (e.g., an edge from `TextEdit` to `zsh`). Graph-based models can immediately flag the creation of these new, high-risk edges as anomalies.
    answer_sources:
      - macOS Endpoint Security Framework (ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_FORK)
      - Zeek conn.log
      - Zeek dns.log
      - macOS endpoints and network egress points.
    range: last 90 days
    queries:
      - pseudocode: MODEL = train_graph_model(process_lineage) | ON process_fork | IF new_edge(parent, child) not in MODEL | ALERT