name: T1036.011: Overwrite Process Arguments
id: f8a4b2c1-9e7d-4f1a-8c3b-5d6e7f0a9b8c
description: This playbook focuses on detecting adversaries who evade defenses by overwriting in-memory process arguments to masquerade as a legitimate process (T1036.011). It provides investigative questions to identify this activity by looking for the use of known malicious binaries, mismatches between initial and current command-line arguments, anomalous network behavior from seemingly benign processes, unusual process parentage or file paths, and processes with suspiciously short or empty command lines.
type: technique
related:
- TA0005: Defense Evasion
contributors:
- Zachary Szewczyk
- Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
- question: Are there any process creation events where the binary's file hash matches a known malicious hash associated with argument-spoofing malware?
  context: This question aims to identify the execution of known malicious tools like BPFDoor or XorDdos, which are capable of overwriting their own process arguments to evade detection. By comparing file hashes of newly created processes against a threat intelligence feed of known IOCs, we can directly detect the presence of these specific malware families.
  answer_sources: Sysmon for Linux Event ID 1, Linux Auditd logs (type=EXECVE), EDR Process Creation Telemetry, and Threat Intelligence Feeds. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - symbolic: SEARCH process_creation_events | JOIN process.hash with threat_intel_feed on hash | WHERE match_found
- question: Have any unsigned, statistically rare binaries been executed recently?
  context: This question helps uncover potentially unknown or novel malware that uses argument overwriting. Since attackers often use custom or packed binaries, their file hashes will be rare in the environment. By focusing on rare and unsigned executables, we can surface suspicious processes that warrant further investigation, especially when correlated with other indicators like unusual network activity.
  answer_sources: Sysmon for Linux Event ID 1, Linux Auditd logs (type=EXECVE), and EDR Process Creation Telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - statistical: SEARCH process_creation_events | CALCULATE prevalence of process.hash | FILTER is_rare AND is_unsigned
- question: Can a machine learning model identify process executions that are highly likely to be malicious based on features associated with argument spoofing?
  context: This question leverages a supervised machine learning model to proactively score and identify suspicious process executions. By training on a rich feature set including hash prevalence, parent process, and user context from both known-good and known-bad examples, the model can learn the subtle patterns of malicious behavior and detect novel threats that may not match specific rules or signatures.
  answer_sources: Sysmon for Linux Event ID 1, Linux Auditd logs (type=EXECVE), and EDR Process Creation Telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - machine_learning: INPUT process_creation_events | EXTRACT features (hash_prevalence, parent_process, user, etc.) | APPLY ML_model | FILTER score > threshold
- question: Has a process's command line been altered shortly after its creation?
  context: This question directly targets the core of the technique. By capturing the command line at process creation and then re-checking it from /proc/[pid]/cmdline a moment later, we can detect a mismatch. This is a high-fidelity indicator that the process arguments were deliberately overwritten post-launch to hide the true execution parameters.
  answer_sources: Sysmon for Linux Event ID 1, Linux Auditd logs (type=EXECVE), osquery process table snapshots, and EDR agent telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - symbolic: ON process_creation(pid, initial_cmdline) | DELAY 1s | GET current_cmdline from /proc/pid/cmdline | IF initial_cmdline != current_cmdline THEN ALERT
- question: Is there a consistent time delay between process creation and argument modification across multiple events?
  context: This question aims to build a behavioral profile for the overwriting technique. Malicious tools often perform the overwrite within a specific, narrow time window after launch. By analyzing the distribution of these time deltas, we can establish a high-confidence signature for the technique, helping to differentiate it from benign in-memory modifications that might happen at other times.
  answer_sources: Sysmon for Linux Event ID 1, Linux Auditd logs (type=EXECVE), osquery process table snapshots, and EDR agent telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - statistical: FOR each cmdline_modification_event | CALCULATE delta = modification_time - creation_time | ANALYZE distribution of deltas
- question: Does the sequence of system calls immediately following a process's creation deviate from normal behavior, particularly involving memory modification calls?
  context: This question uses an anomaly detection model to find suspicious startup behavior. A process intending to overwrite its arguments will make specific system calls (like prctl) to modify its memory. An ML model trained on legitimate process startup sequences can identify these anomalous call patterns, providing a way to detect the technique even without observing the command-line state directly.
  answer_sources: Sysmon for Linux Event ID 1, Linux Auditd logs (type=EXECVE), osquery process table snapshots, and EDR agent telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - machine_learning: INPUT syscall_sequence post-creation | APPLY RNN_anomaly_model | FILTER anomaly_score > threshold
- question: Is a process with a commonly spoofed name (e.g., rsyslogd, sshd) making network connections to known malicious IP addresses?
  context: This question seeks to uncover a masquerading process by its network behavior. An adversary may spoof a common process name, but the process still needs to communicate with its C2 server. By correlating process information with network logs and threat intelligence, we can flag instances where a trusted-looking process is communicating with a known-bad destination.
  answer_sources: Sysmon for Linux Event ID 1, Sysmon for Linux Event ID 3, Zeek conn.log, Zeek dns.log, and Linux Auditd logs (type=SYSCALL, syscall=connect). Focus on: Network egress points (e.g., internet gateway), DNS resolvers, and critical Linux servers.
  range: last 90 days
  queries:
  - symbolic: SEARCH process_creation_events AND network_connection_events | JOIN by host | WHERE process.name IN (spoof_watchlist) AND destination.ip IN (c2_blocklist)
- question: Is a common system process exhibiting abnormal network behavior, such as connecting to unusual ports or rare geographic locations?
  context: This question establishes a baseline of normal network activity for legitimate system processes and looks for outliers. A spoofed process used for C2 will likely deviate from this baseline by connecting to non-standard ports or geographically anomalous IPs. Calculating metrics like destination port frequency and connection entropy can quantitatively identify these suspicious deviations.
  answer_sources: Sysmon for Linux Event ID 1, Sysmon for Linux Event ID 3, Zeek conn.log, Zeek dns.log, and Linux Auditd logs (type=SYSCALL, syscall=connect). Focus on: Network egress points (e.g., internet gateway), DNS resolvers, and critical Linux servers.
  range: last 90 days
  queries:
  - statistical: FOR each process.name | BUILD baseline of destination_ports, destination_geo | FIND process instances where connection deviates from baseline
- question: Can a time-series model detect anomalous periodic network traffic (beaconing) from a specific process?
  context: This question is designed to detect the rhythmic 'heartbeat' of C2 communications. Malware often beacons out to its controller at regular intervals. A time-series analysis model (like ARIMA or LSTM) can learn the normal traffic patterns for a given process and host, and then flag the emergence of a new, periodic signal indicative of C2 beaconing from a masquerading process.
  answer_sources: Sysmon for Linux Event ID 1, Sysmon for Linux Event ID 3, Zeek conn.log, Zeek dns.log, and Linux Auditd logs (type=SYSCALL, syscall=connect). Focus on: Network egress points (e.g., internet gateway), DNS resolvers, and critical Linux servers.
  range: last 90 days
  queries:
  - machine_learning: AGGREGATE network_traffic by process.name, host, time | APPLY time-series_model | DETECT anomalous periodic patterns
- question: Is a critical system process (e.g., [kworker], sshd) running with an incorrect parent process or from a non-standard file path?
  context: This question leverages the predictable lineage and location of legitimate system processes. A process like 'sshd' should only be launched by 'systemd' and run from /usr/sbin/sshd. A violation, such as 'sshd' being launched by a web server process ('apache2') or running from /tmp, is a strong indicator of compromise. This rule-based approach provides high-fidelity alerts for known-good processes.
  answer_sources: Sysmon for Linux Event ID 1 and Linux Auditd logs (type=EXECVE). Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - symbolic: SEARCH process_creation_events | FILTER (process.name='sshd' AND parent.process.name!='systemd') OR (process.name='sshd' AND process.path!='/usr/sbin/sshd')
- question: Are there any statistically rare parent-child process relationships occurring in the environment?
  context: This question aims to find suspicious process execution chains by identifying what is uncommon. While an adversary might use a novel process name, the relationship between the parent (e.g., 'bash') and the child (e.g., a newly compiled binary) might be unique across the entire enterprise. Surfacing these rare relationships for analyst review can uncover attacker execution chains that would otherwise be missed.
  answer_sources: Sysmon for Linux Event ID 1 and Linux Auditd logs (type=EXECVE). Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - statistical: SEARCH process_creation_events | CALCULATE frequency of (parent.process.name, child.process.name) pairs | FILTER frequency is rare
- question: Can a graph-based model detect anomalous process lineage structures?
  context: This question treats process execution history as a graph and looks for structural anomalies. Attackers often create unusual execution chains (e.g., a web server spawning a shell). A graph-based model trained on legitimate process trees can learn what normal structures look like and flag new, anomalous subgraphs that represent suspicious activity.
  answer_sources: Sysmon for Linux Event ID 1 and Linux Auditd logs (type=EXECVE). Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - machine_learning: MODEL process lineage as a graph | APPLY graph_anomaly_detection_model | IDENTIFY anomalous subgraphs
- question: Are there any running processes with an empty command line, excluding known exceptions?
  context: This question targets a common artifact of argument overwriting; the complete erasure of the command line. While some kernel threads legitimately have empty command lines, it is highly unusual for user-space processes. A simple rule to find processes where /proc/[pid]/cmdline is empty can be a very effective way to find malware that has wiped its arguments.
  answer_sources: osquery process table snapshots and EDR agent telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - symbolic: SEARCH running_processes | FILTER cmdline is empty AND process.name NOT IN (exception_list)
- question: Are there any running processes whose command-line length is statistically anomalous (i.e., too short) compared to their historical baseline?
  context: This question establishes a baseline for the normal command-line length for each process and then looks for outliers on the low end. An attacker might not completely erase the arguments but might shorten them significantly. By identifying processes whose cmdline length falls below a statistical low-water mark (e.g., the 1st percentile), we can catch this more subtle form of argument tampering.
  answer_sources: osquery process table snapshots and EDR agent telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - statistical: FOR each process.name | BUILD baseline of cmdline_length | FIND running instances where length < 1st_percentile
- question: Can a clustering algorithm identify groups of anomalous processes characterized by short or empty command lines?
  context: This question uses an unsupervised machine learning approach to find outliers without pre-defined rules. By clustering running processes based on features like command-line length, process name, and user context, an algorithm can automatically group normal processes into large, dense clusters. Processes that have been tampered with will likely have abnormal feature combinations and will be flagged as noise or outliers.
  answer_sources: osquery process table snapshots and EDR agent telemetry. Focus on: Critical Linux servers (e.g., web servers, database servers, authentication servers), container environments, and developer workstations.
  range: last 90 days
  queries:
  - machine_learning: INPUT running_processes with features (cmdline_length, name, user) | APPLY DBSCAN clustering | IDENTIFY outlier points