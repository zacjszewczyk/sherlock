name: 'T1575: Native API'
id: f47ac10b-58cc-4372-a567-0e02b2c3d479
description: This playbook focuses on detecting adversaries using native code (via the Native API) on mobile devices for defense evasion and execution. It addresses the use of native libraries (.so files) to obscure malicious activity through packing, obfuscation, and dynamic loading from non-standard locations. It also covers the execution of malicious commands, either through embedded functions within the native code itself, by establishing covert command and control (C2) channels, or by spawning suspicious child processes. Indicators include high-entropy libraries, unusual JNI function exports, dynamic loading via Java Reflection, use of command execution functions like 'system' or 'execve', network beaconing, and anomalous process creation.
type: technique
related:
  - 'TA0030: Defense Evasion'
  - 'TA0041: Execution'
contributors:
  - Zachary Szewczyk
  - Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Are any mobile applications in our environment using native libraries with hashes that match known malicious or packed libraries in our threat intelligence feeds?
    context: This question aims to identify overtly malicious code by checking the digital fingerprint (hash) of native libraries against a curated list of known threats. A match provides high-confidence evidence that a compromised application is present on a device, bypassing simpler detection methods that don't inspect native code.
    answer_sources:
      - APK static analysis reports (JSON/XML)
      - MDM application inventory logs
      - Static analysis tool raw output
      - Corporate application vetting system (static analysis sandbox), MDM server application inventory database, and file systems of enrolled mobile devices.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each app IN mdm_inventory GET static_analysis_report.native_library_hashes; FOR each hash IN native_library_hashes CHECK against threat_intel_feed; IF match ALERT device, user, app_details;
  - question: Are any native libraries exhibiting statistical signs of packing or dynamic function hiding, such as unusually high entropy or a minimal set of exported JNI functions including 'JNI_OnLoad'?
    context: This question targets sophisticated evasion techniques. High entropy suggests data is compressed or encrypted, a common trait of packed malware. A minimal export list featuring only 'JNI_OnLoad' is a classic pattern used to dynamically register and hide malicious functions from static analysis tools. Detecting these indicators helps uncover malware designed to be stealthy.
    answer_sources:
      - APK static analysis reports (JSON/XML)
      - MDM application inventory logs
      - Static analysis tool raw output
      - Corporate application vetting system (static analysis sandbox), MDM server application inventory database, and file systems of enrolled mobile devices.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: CALCULATE entropy_99th_percentile FROM all_libraries; FOR each library IN static_analysis_reports; IF library.entropy > entropy_99th_percentile ALERT; IF library.exports_count <= 3 AND 'JNI_OnLoad' IN library.exports ALERT;
  - question: Can we use a machine learning model to predict which new or updated native libraries are likely malicious based on a combination of features like entropy, function counts, and specific imports?
    context: This question leverages machine learning to automate the detection of suspicious libraries that may not trigger simple, single-indicator rules. By training a model on a wide range of features (file size, entropy, function counts, etc.), it can identify complex patterns associated with malware, allowing analysts to focus their manual reverse engineering efforts on the highest-risk targets.
    answer_sources:
      - APK static analysis reports (JSON/XML)
      - MDM application inventory logs
      - Static analysis tool raw output
      - Corporate application vetting system (static analysis sandbox), MDM server application inventory database, and file systems of enrolled mobile devices.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each new_or_updated_library; EXTRACT features (size, entropy, imports, exports, etc.); PREDICT score using classification_model; IF score > 0.85 ESCALATE for manual_analysis;
  - question: Are any mobile devices downloading executable libraries from known-bad domains and then immediately loading them from a non-standard directory?
    context: This question seeks to identify the full attack chain of a 'dropper' application. Adversaries often use a seemingly benign app to download a malicious payload from a C2 server and then dynamically load it. Correlating network traffic (DNS, file download) with on-device activity (library loading) within a short time window provides strong evidence of this behavior.
    answer_sources:
      - Android Logcat streams from MDM
      - Zeek conn.log
      - Zeek files.log
      - Zeek dns.log
      - Mobile EDR file modification events
      - Enterprise wireless and VPN network traffic inspection points, DNS resolvers, and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: JOIN dns_logs, file_logs, logcat_logs ON device_ip within 120s; IF dns_log.domain IN blocklist AND file_log.extension IN ['.so', '.dex', '.jar'] AND logcat_log.message CONTAINS 'System.load' AND logcat_log.path NOT IN standard_paths; THEN ALERT;
  - question: Is any application suddenly loading native libraries from unusual, world-writable directories at a rate that deviates significantly from its normal behavior?
    context: This question uses behavioral analytics to detect anomalies. Most applications consistently load libraries from a standard, secure location. A sudden shift to loading from a non-standard, writable path (like a downloads folder) is highly suspicious and could indicate that the application has been compromised or is loading a malicious payload.
    answer_sources:
      - Android Logcat streams from MDM
      - Zeek conn.log
      - Zeek files.log
      - Zeek dns.log
      - Mobile EDR file modification events
      - Enterprise wireless and VPN network traffic inspection points, DNS resolvers, and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each app; BASELINE normal_library_load_paths over 30 days; MONITOR new_library_loads; IF load_path IS non-standard AND load_rate > (baseline_mean + 3 * baseline_stdev) OR is_first_time_event; THEN ALERT;
  - question: Can we use a sequence analysis model (like an HMM or RNN) to identify chains of events on a device that match known malicious patterns of behavior involving dynamic code loading?
    context: This question applies advanced machine learning to detect attack sequences that might be missed by simple correlation rules. By training a model on the order of events (e.g., a DNS query to a rare domain, followed by a JAR download, followed by a library load from an odd path), it can identify complex, multi-step malicious activities with higher accuracy.
    answer_sources:
      - Android Logcat streams from MDM
      - Zeek conn.log
      - Zeek files.log
      - Zeek dns.log
      - Mobile EDR file modification events
      - Enterprise wireless and VPN network traffic inspection points, DNS resolvers, and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each device; CREATE event_sequence (dns, file_download, library_load, etc.); FEED sequence into sequence_analysis_model; IF model_output_probability > threshold; THEN FLAG for review;
  - question: Are any applications dynamically loading a native library and then immediately using Java Reflection to call a method whose name appears to be obfuscated or generated at runtime?
    context: This question targets a specific, advanced evasion technique. Malware often loads a native library and then uses Java Reflection to execute a function within it. To hide the function's purpose, the name is not stored as a plain string but is deobfuscated just before the call. Detecting this tight sequence of 'loadLibrary' followed by 'invoke' with a non-static method name is a strong indicator of malicious behavior.
    answer_sources:
      - Mobile EDR API monitoring logs
      - Android Logcat streams from MDM
      - Dynamic analysis sandbox logs (e.g., Frida traces)
      - Mobile EDR/MTP agent data feeds and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: CORRELATE edr_logs where api_call is 'loadLibrary' and 'Method.invoke' within 100ms on same_thread; IF invoke_method_name_arg NOT IN original_apk_strings; THEN ESCALATE ALERT;
  - question: Are any applications passing unusually high-entropy (i.e., likely obfuscated) strings as arguments to Java Reflection methods like 'Class.forName' or 'Method.invoke'?
    context: This question focuses on identifying obfuscated arguments used in reflection. Benign applications typically use clear, readable string names for classes and methods. Malware, however, often encrypts or encodes these names to hide its functionality, resulting in high-entropy strings. A spike in the entropy of a reflection argument for a specific app is a red flag for runtime deobfuscation.
    answer_sources:
      - Mobile EDR API monitoring logs
      - Android Logcat streams from MDM
      - Dynamic analysis sandbox logs (e.g., Frida traces)
      - Mobile EDR/MTP agent data feeds and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each app; PROFILE entropy of string_args to reflection_methods; CALCULATE 98th_percentile_entropy for each app; IF new_reflection_call.arg_entropy > 98th_percentile; THEN ALERT;
  - question: Can a machine learning classifier be trained on dynamic API call traces to automatically identify suspicious sequences involving both native code loading and Java Reflection?
    context: This question proposes using a supervised ML model to learn the difference between benign and malicious API call sequences. By analyzing features like the order of calls, the use of reflection, and the entropy of arguments, the model can automatically flag complex behaviors that are difficult to define with static rules, helping to scale the analysis process.
    answer_sources:
      - Mobile EDR API monitoring logs
      - Android Logcat streams from MDM
      - Dynamic analysis sandbox logs (e.g., Frida traces)
      - Mobile EDR/MTP agent data feeds and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each api_trace from sandbox; EXTRACT features (api_sequence, reflection_use, arg_entropy, etc.); CLASSIFY trace as benign/suspicious using trained_model; IF suspicious, FLAG for investigation;
  - question: Are any non-allowlisted mobile applications shipping with native libraries that import known command execution functions (like 'system' or 'execve') or contain suspicious shell-related strings?
    context: This question aims to find potential backdoors or execution capabilities embedded directly in native code. While some legitimate tools need these functions, their presence in a typical application is highly suspect. By scanning for these indicators and filtering out known-good apps, analysts can quickly identify applications with dangerous, built-in capabilities.
    answer_sources:
      - APK static analysis reports (JSON/XML)
      - MDM application inventory logs
      - Corporate application vetting system (static analysis sandbox) and MDM application inventory database.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each app in static_analysis; IF app.package_name NOT IN allowlist; IF app.native_library IMPORTS ('system', 'execve') OR CONTAINS ('/bin/sh', 'su'); THEN ALERT;
  - question: Can we prioritize our investigation of native libraries by assigning them a risk score based on the rarity of the suspicious indicators they contain?
    context: This question addresses the problem of alert fatigue. Some suspicious indicators might be common in benign libraries. By scoring indicators based on their rarity (inversely proportional to frequency), this method highlights libraries containing truly unusual and therefore riskier combinations of functions and strings, allowing analysts to focus on the most probable threats.
    answer_sources:
      - APK static analysis reports (JSON/XML)
      - MDM application inventory logs
      - Corporate application vetting system (static analysis sandbox) and MDM application inventory database.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: CALCULATE prevalence of each indicator (e.g., 'system' import); FOR each indicator, score = 1 / prevalence; FOR each library, total_score = SUM(scores of its indicators); IF library.total_score > 98th_percentile_score; THEN FLAG for review;
  - question: Can we use a machine learning model, trained on static analysis features, to automatically classify applications as likely being able to execute native commands?
    context: This question proposes using a supervised ML model to automate the classification of applications based on a holistic view of their static properties. By combining features like suspicious imports, string counts, permissions, and file section ratios, the model can learn complex patterns that indicate an application is a 'potential native executor' with greater accuracy than simple rule-based checks.
    answer_sources:
      - APK static analysis reports (JSON/XML)
      - MDM application inventory logs
      - Corporate application vetting system (static analysis sandbox) and MDM application inventory database.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each app; EXTRACT static_features (imports, strings, permissions, etc.); PREDICT class using trained_model; IF class is 'potential_native_executor' with confidence > 0.90; THEN ESCALATE to sandbox;
  - question: Are any mobile devices, which use applications with native libraries, communicating with known command and control (C2) servers identified by our threat intelligence feeds?
    context: This question focuses on detecting active C2 communications using high-confidence indicators. By matching network connection details (IP, domain, TLS fingerprint) against a blocklist of known malicious infrastructure, we can identify compromised devices with a high degree of certainty. Correlating this back to the specific application responsible is a critical step in the response process.
    answer_sources:
      - Zeek conn.log
      - Zeek ssl.log
      - Zeek dns.log
      - MDM application inventory logs
      - Mobile EDR network connection logs
      - Network egress points (Firewall/Proxy), Enterprise DNS servers, VPN concentrators, and mobile endpoint network logs.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each network_connection; IF connection.dest_ip OR connection.domain OR connection.ja3_hash IN c2_blocklist; GET process_name from mobile_edr using device_ip and timestamp; THEN ALERT;
  - question: Are we observing any network traffic from mobile devices that exhibits the characteristics of automated C2 beaconing, such as highly regular time intervals and consistent, small payload sizes?
    context: This question aims to find C2 channels that are not yet on a blocklist by analyzing the traffic's behavior. Malware beacons are often automated, resulting in very low 'jitter' (variance in time between connections) and consistent packet sizes. Detecting this machine-like regularity helps uncover previously unknown C2 infrastructure.
    answer_sources:
      - Zeek conn.log
      - Zeek ssl.log
      - Zeek dns.log
      - MDM application inventory logs
      - Mobile EDR network connection logs
      - Network egress points (Firewall/Proxy), Enterprise DNS servers, VPN concentrators, and mobile endpoint network logs.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: GROUP connections by src_ip, dst_ip, dst_port, protocol over 24h; CALCULATE stdev(time_delta) and stdev(payload_size); IF stdev(time_delta) < 2s AND stdev(payload_size) < 100b AND dest NOT IN allowlist; THEN ALERT;
  - question: Can an unsupervised machine learning model (like DBSCAN) help us discover anomalous clusters of network activity that could represent previously unknown C2 channels?
    context: This question leverages unsupervised ML to find the 'needle in the haystack.' Most network traffic clusters into large groups representing popular services. Malicious C2 traffic often forms its own small, distinct cluster. By using algorithms to automatically group flows by their characteristics, we can isolate these outlier clusters for investigation, revealing covert C2 channels.
    answer_sources:
      - Zeek conn.log
      - Zeek ssl.log
      - Zeek dns.log
      - MDM application inventory logs
      - Mobile EDR network connection logs
      - Network egress points (Firewall/Proxy), Enterprise DNS servers, VPN concentrators, and mobile endpoint network logs.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: EXTRACT features from network_flows (duration, bytes, protocol, etc.); APPLY DBSCAN clustering algorithm; INVESTIGATE small, dense clusters that are outliers;
  - question: Are any of our non-system, non-allowlisted mobile applications spawning shell processes ('sh'), attempting to gain root access ('su'), or manipulating packages ('pm')?
    context: This question targets a clear and dangerous indicator of compromise. A standard mobile application should almost never need to spawn a shell or the package manager. Such an action strongly implies that the application is attempting to execute arbitrary commands, escalate privileges, or sideload other malicious software on the device.
    answer_sources:
      - Mobile EDR process event logs
      - Android SELinux audit logs
      - Android Logcat
      - Mobile EDR/MTP agent data feeds, and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: FOR each process_creation_event; IF parent_app NOT IN [system_apps, allowlist] AND child_process IN ['sh', 'su', 'pm']; THEN ALERT;
  - question: Has any application spawned a child process or executed a command that is completely new and has never been seen for that specific application across our entire environment?
    context: This question uses 'first seen in fleet' logic to detect highly anomalous behavior. While an application might have legitimate reasons to spawn a child process, if it suddenly spawns a new type of process that neither it nor any other instance of it has ever spawned before, it's a strong signal that the application's behavior has changed, possibly due to compromise or a malicious update.
    answer_sources:
      - Mobile EDR process event logs
      - Android SELinux audit logs
      - Android Logcat
      - Mobile EDR/MTP agent data feeds, and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: MAINTAIN baseline of all (app, child_process) pairs seen in fleet; FOR each new process_creation_event; IF (event.app, event.child_process) NOT IN baseline; THEN ALERT as 'first_seen_in_fleet';
  - question: Can an anomaly detection model, like an Isolation Forest, identify suspicious process creation events by learning the normal patterns of parent-child process relationships and command-line arguments?
    context: This question proposes using an unsupervised anomaly detection model to find unusual process events without pre-defined rules. The model learns what 'normal' process creation looks like across the environment and then flags any event that deviates significantly. This is effective for catching novel or subtle attacks that don't match known bad patterns.
    answer_sources:
      - Mobile EDR process event logs
      - Android SELinux audit logs
      - Android Logcat
      - Mobile EDR/MTP agent data feeds, and real-time log streams from enrolled mobile endpoints.
    range: last 90 days
    queries:
      - tech: Pseudocode
        query: TRAIN isolation_forest_model on features (parent_pkg, child_name, arg_count, keywords); FOR each new process_creation_event; SCORE event with model; IF score indicates anomaly; THEN FLAG for investigation;