[
  {
    "information_requirement": "Is the adversary maintaining persistence using Systemd services?",
    "tactic_id": "TA0003",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1543.002",
        "name": "Systemd Service",
        "evidence": [
          {
            "description": "A new file with a `.service` extension is created in a systemd unit directory (`/etc/systemd/system/`, `/usr/lib/systemd/system/`, `~/.config/systemd/user/`) and the command specified in the `ExecStart` directive matches a known malicious file hash, path, or command-line argument.",
            "data_sources": [
              "auditd logs",
              "File Integrity Monitoring (FIM) logs",
              "Endpoint File Content"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Linux servers (e.g., web servers, application servers, database servers), Linux developer workstations",
            "action": [
              "1. Monitor auditd or FIM logs for file creation events with a `.service` extension in systemd unit directories. 2. Upon detection, extract the command string from the `ExecStart` directive. 3. Compare the executable's file hash, full path, and command-line arguments against a threat intelligence feed of known Indicators of Compromise (IOCs). 4. Generate an alert for any match.",
              "1. For all `ExecStart` commands in existing `.service` files, calculate the Shannon entropy of the command string to establish a baseline distribution for your environment. 2. For each newly created `.service` file, calculate the entropy of its `ExecStart` command string. 3. Flag any new command whose entropy score exceeds the 95th percentile of the established baseline, as this suggests the use of obfuscation or encoding.",
              "1. Develop a feature set for `ExecStart` commands including: command length, character class ratios (alphabetic, numeric, special), presence of keywords (e.g., `/tmp`, `dev/shm`, `curl`, `wget`), and file path depth. 2. Train a classification model (e.g., Random Forest) on a labeled dataset of benign and malicious service commands. 3. Apply the trained model to all newly created service commands to generate a suspicion score and alert on commands classified as malicious."
            ]
          },
          {
            "description": "A `.service` file's `ExecStart` directive invokes a scripting interpreter (e.g., `bash`, `python`, `perl`) with arguments characteristic of obfuscation (e.g., `base64 -d`, `eval`) or network-based execution (e.g., `/dev/tcp`).",
            "data_sources": [
              "auditd logs",
              "Endpoint File Content"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Linux servers (e.g., web servers, application servers, database servers), Linux developer workstations",
            "action": [
              "1. On new or modified `.service` files, scan the `ExecStart` directive using regular expressions. 2. The patterns should detect scripting interpreters (`sh`, `bash`, `python`, `perl`) followed by indicators of obfuscation (`base64`, `eval`) or in-memory network connections (`/dev/tcp/`, `curl -s`, `wget -qO-`). 3. Generate an alert for any match.",
              "1. For all `ExecStart` commands that invoke a scripting interpreter, calculate the ratio of non-alphanumeric characters to the total character count. 2. Establish a baseline distribution of this ratio from known-good service files. 3. Flag any new service command where this ratio exceeds the 98th percentile of the baseline, indicating an abnormally high density of special characters often used in obfuscated payloads.",
              "1. Tokenize `ExecStart` commands into sequences of arguments and operators. 2. Train a sequence-based model, such as an LSTM autoencoder, on command sequences from legitimate service files installed by package managers. 3. Use the trained model to calculate the reconstruction error for new command sequences. 4. Flag commands with a high reconstruction error, as they represent novel or unusual command structures not seen in the benign training data."
            ]
          },
          {
            "description": "A process with parent process ID 1 (`systemd`) initiates an outbound network connection to a destination IP or domain with a low reputation score, or the connection pattern exhibits a fixed periodicity (beaconing).",
            "data_sources": [
              "auditd logs",
              "Zeek conn.log",
              "Zeek dns.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Network egress points, DNS resolvers, Linux servers",
            "action": [
              "1. From auditd logs, identify all processes executed with a parent process ID (PPID) of 1. 2. Correlate these processes by host IP and timestamp with outbound network connections in `Zeek conn.log`. 3. For each connection, resolve the destination domain using `Zeek dns.log`. 4. Compare the destination IP and domain against a C2 threat intelligence feed and generate an alert on any match.",
              "1. Isolate all outbound network connections in `Zeek conn.log` originating from processes with PPID 1. 2. For each source-destination IP pair, calculate the time deltas between consecutive connections and flag pairs where the standard deviation of the time delta is below a small threshold (e.g., < 1 second), indicating robotic beaconing. 3. For DNS queries associated with these connections from `Zeek dns.log`, calculate the Shannon entropy of the queried domain name and flag connections to domains with entropy scores indicative of DGA.",
              "1. For all connections from processes with PPID 1, extract a feature vector from `Zeek conn.log` including: `duration`, `orig_bytes`, `resp_bytes`, `proto`, destination port, and `conn_state`. 2. Use a clustering algorithm like DBSCAN or an Isolation Forest to model normal connection patterns for system services. 3. Identify and alert on connections that are flagged as outliers or form their own small, distinct clusters, representing anomalous network behavior."
            ]
          },
          {
            "description": "A `systemctl enable` or `systemctl start` command is executed, and the target `.service` file was not installed by a trusted software package manager (e.g., yum, apt) or configuration management system (e.g., Ansible, Puppet).",
            "data_sources": [
              "auditd logs",
              "Package manager logs (e.g., dpkg.log, yum.log)",
              "Configuration management logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Linux servers and workstations, Configuration Management servers",
            "action": [
              "1. Monitor `execve` syscalls in auditd logs for `systemctl` commands with `enable` or `start` arguments. 2. For the target service file, check package manager logs (e.g., `/var/log/dpkg.log`, `/var/log/yum.log`) and configuration management logs to verify the file is part of a known package or deployment. 3. If the service file is not attributable to a legitimate installation source, generate an alert.",
              "1. From auditd logs, profile the parent processes that execute `systemctl`. 2. Create a frequency distribution of these parent process names (e.g., `sshd`, `bash`, `ansible-playbook`). 3. Alert on any `systemctl enable` or `systemctl start` execution where the parent process is statistically rare (e.g., in the bottom 5th percentile of frequency), such as `httpd`, `nginx`, or a compiled binary in `/tmp`.",
              "1. Collect timestamps of all `systemctl enable` and `systemctl start` commands from auditd logs. 2. Apply a time-series decomposition or forecasting model (e.g., SARIMA) to learn the typical daily and weekly patterns of administrative activity (e.g., 9-5 weekdays, Sunday night patch windows). 3. Generate an alert when a `systemctl` execution occurs at a time with a very low probability according to the model, indicating anomalous off-hours activity."
            ]
          }
        ]
      }
    ],
    "last_updated": "2025-09-30",
    "version": "2.3",
    "date_created": "2025-05-04",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is the adversary escalating privileges using Systemd services?",
    "tactic_id": "TA0004",
    "tactic_name": "Privilege Escalation",
    "indicators": [
      {
        "technique_id": "T1543.002",
        "name": "Systemd Service",
        "evidence": [
          {
            "description": "An executable is run from a systemd generator directory (`/etc/systemd/system-generators/`, `/usr/local/lib/systemd/system-generators/`, `/usr/lib/systemd/system-generators/`) and its file hash is malicious, or system logs contain signatures of a known systemd privilege escalation vulnerability.",
            "data_sources": [
              "auditd logs",
              "Systemd journal logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Critical Linux servers, Authentication servers",
            "action": [
              "1. Monitor `execve` syscalls in auditd for any execution from a systemd generator directory. 2. Calculate the hash of the executed file and compare it against a threat intelligence feed of malicious generators. 3. Separately, scan Systemd journal logs for text patterns matching exploitation of known systemd privilege escalation CVEs (e.g., CVE-2018-19396). 4. Generate an alert on any match.",
              "1. Create and maintain a baseline set of file hashes for all executables present in systemd generator directories across all hosts. 2. Monitor for any new executable file creation in these directories. 3. Alert when a file is created whose hash is not in the established baseline, indicating a rare and potentially unauthorized generator.",
              "1. Using auditd data, record the sequence of system calls made by known-good systemd generators during system boot. 2. Train a sequence-based anomaly detection model (e.g., LSTM autoencoder) on these legitimate syscall sequences. 3. During system boot, capture the syscall sequence of each executed generator and flag any generator whose syscall sequence has a high reconstruction error from the model, indicating anomalous behavior."
            ]
          },
          {
            "description": "A file modification event on an existing `.service` file results in one of the following changes: the `User=` directive is added or changed to `root`, or the command in the `ExecStart` directive is modified to an executable located in a world-writable directory (`/tmp`, `/var/tmp`, `/dev/shm`).",
            "data_sources": [
              "auditd logs",
              "File Integrity Monitoring (FIM) logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Systemd service file directories on all Linux hosts (/etc/systemd/system/, /usr/lib/systemd/system/)",
            "action": [
              "1. Use a File Integrity Monitoring (FIM) tool to monitor all `.service` files in system-level systemd directories. 2. On a modification alert, perform a content diff against a known-good version. 3. Generate a high-priority alert if the diff shows the `User=` directive was changed to `root` or removed (which defaults to root), or if the `ExecStart` path was changed to a world-writable directory.",
              "1. For each `.service` file, store its `ExecStart` command string as a baseline. 2. Upon a modification event from FIM, calculate the Levenshtein distance between the old and new `ExecStart` strings. 3. Flag modifications where the distance exceeds a tuned threshold, indicating a substantial change to the command (e.g., a hijack) rather than a minor argument tweak.",
              "1. From FIM and auditd logs, create a feature set for each `.service` file modification event: modifying user, parent process of modifying process, and a one-hot encoded vector representing which directives were changed (`User=`, `ExecStart=`, etc.). 2. Train an anomaly detection model (e.g., Isolation Forest) on these features from a period of normal operation. 3. Apply the model to new modification events to flag those that are inconsistent with legitimate patching or administrative behavior."
            ]
          },
          {
            "description": "A `.service` file is created by a non-root user (UID > 1000) in a temporary or user-writable directory (e.g., `/tmp`, `/dev/shm`, `/home/*`), and is subsequently moved by a privileged process into a system-level systemd directory (`/etc/systemd/system/`).",
            "data_sources": [
              "auditd logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Staging directories (`/tmp`, `/dev/shm`), User home directories, Systemd system directories (`/etc/systemd/system/`)",
            "action": [
              "1. Monitor auditd for file creation events (`creat`, `openat`) for files ending in `.service` created by a non-root user (EUID > 1000) in a non-systemd directory. 2. Monitor for file rename/move events (`renameat`) where this newly created file is moved into a systemd system directory (`/etc/systemd/system/`). 3. Correlate these two events happening within a short time window and generate a high-priority alert.",
              "1. Using auditd data, create a baseline set of user accounts that are authorized to create or modify `.service` files (e.g., `root`, service accounts, configuration management users). 2. Monitor all `.service` file creation events across the filesystem. 3. Alert any time a user not in the baseline set creates a `.service` file, as this is a statistically rare and unauthorized action.",
              "1. Develop a model to score the risk of file system event sequences. 2. Create features for a sequence of events (e.g., `create` -> `move`) including: creating user's UID, initial file path, final file path, time delta between events, and the process name that performed the move. 3. Train a classification model on labeled sequences of benign (package installs) and malicious (privilege escalation) service file placements. 4. Apply the model to real-time event sequences to detect suspicious service file staging."
            ]
          },
          {
            "description": "A `.timer` and a corresponding `.service` file with the same base name are created in a user-controllable directory (e.g., `~/.config/systemd/user/`), and the service is configured to exploit a sudo rule or SUID binary to execute commands as root.",
            "data_sources": [
              "auditd logs",
              "Endpoint File Content"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "User-level systemd directories on all Linux hosts (~/.config/systemd/user/)",
            "action": [
              "1. Monitor for the creation of `.timer` and `.service` file pairs in any user's systemd directory (`~/.config/systemd/user/`). 2. Upon creation, scan the `ExecStart` command in the `.service` file. 3. Alert if the command uses `sudo` to run a command that the user is permitted to run as root, or if it executes a known SUID binary with arguments that can lead to privilege escalation.",
              "1. Establish a baseline count of user-level `.timer` files (`~/.config/systemd/user/*.timer`) per user across the environment; this count is typically zero for most users. 2. Monitor for the creation of new `.timer` files in any user's directory. 3. Alert on the creation of any new user-level timer, as this is a statistically rare event often associated with user-level persistence or privilege escalation setup.",
              "1. Build a graph representation of all systemd units and their dependencies (e.g., `Wants`, `Requires`) on each host. 2. Monitor for the addition of new nodes (units) to the graph. 3. Use graph algorithms to detect the creation of new, small, disconnected components, particularly those consisting of a user-level `.timer` and `.service` pair. Such isolated subgraphs are highly anomalous and suspicious."
            ]
          }
        ]
      }
    ],
    "last_updated": "2025-09-30",
    "version": "2.3",
    "date_created": "2025-05-04",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]