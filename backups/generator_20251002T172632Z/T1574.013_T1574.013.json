[
  {
    "information_requirement": "Is the adversary maintaining persistence by hijacking process execution flow via KernelCallbackTable?",
    "tactic_id": "TA0003",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1574.013",
        "name": "KernelCallbackTable",
        "evidence": [
          {
            "description": "A process is created and its computed file hash (e.g., SHA256) matches an entry on a threat intelligence feed specifically tagged with malware families known to employ KernelCallbackTable hijacking (e.g., FinFisher, Lazarus tooling).",
            "data_sources": [
              "Windows Event ID 4688"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "All Windows Endpoints and Servers",
            "action": [
              "Configure a SIEM rule to ingest all process creation events (Windows Event ID 4688). For each event, compare the file hash of the 'NewProcessName' against a continuously updated threat intelligence feed of hashes for malware and tools known to use KernelCallbackTable hijacking. Generate a high-severity alert for any match.",
              "For each new executable hash observed via Windows Event ID 4688, calculate its enterprise-wide prevalence (e.g., percentage of hosts it has run on) over a 30-day rolling window. Flag any hash that is both extremely rare (e.g., seen on < 0.1% of endpoints) and has high file entropy (e.g., > 7.5), suggesting it is packed or encrypted. A combination of low prevalence and high entropy warrants investigation for novel threats.",
              "Train a binary classification model (e.g., XGBoost, Random Forest) on features from Windows Event ID 4688, including parent process name, command line arguments, and file properties (e.g., signing status, entropy, prevalence). Use this model to score new process creation events in real-time, alerting on those classified as malicious with a high probability score, which can detect variants that do not match known hashes."
            ]
          },
          {
            "description": "A process commonly associated with GUI interaction (e.g., explorer.exe, chrome.exe, winword.exe) is observed as the parent process for an action that creates or modifies a system persistence mechanism, such as creating a scheduled task or modifying a registry autorun key.",
            "data_sources": [
              "Windows Event ID 4688",
              "Windows Event ID 4698",
              "Windows Event ID 4657"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "User Workstations, Domain Controllers, Member Servers, Terminal Servers",
            "action": [
              "Create a SIEM rule that triggers when a process creation event (Windows Event ID 4688) for 'schtasks.exe' or 'reg.exe' has a parent process name from a watchlist of common GUI applications (e.g., 'explorer.exe', 'chrome.exe', 'outlook.exe'). Additionally, monitor for registry modification events (Windows Event ID 4657) to common autorun locations (e.g., HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run) where the subject process name is a GUI application. Alert on any such occurrence.",
              "For each parent process name on a watchlist of common GUI applications, maintain a statistical baseline of its child process frequencies over a 30-day rolling window. Generate an alert if a GUI process spawns a child process associated with persistence (like 'schtasks.exe') that falls below a rarity threshold (e.g., in the 1st percentile of child process frequencies for that parent) or has never been observed before.",
              "Model process-persistence event chains as sequences (e.g., <'explorer.exe', 'schtasks.exe', '/create'>). Use an unsupervised clustering algorithm (e.g., DBSCAN) to group these sequences based on features like parent, child, and command-line arguments. Investigate sequences that are identified as outliers or part of very small clusters, as they represent anomalous persistence establishment methods not conforming to typical administrative behavior."
            ]
          },
          {
            "description": "A process object handle with write access (e.g., PROCESS_VM_WRITE) is granted for a target GUI process (Windows Event ID 4656), and within a short time window (e.g., 5 minutes), that same GUI process PID initiates a persistence action (e.g., creates a scheduled task via Event ID 4698).",
            "data_sources": [
              "Windows Event ID 4656",
              "Windows Event ID 4698",
              "Windows Event ID 4657"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "User Workstations, Application Servers, Terminal Servers",
            "action": [
              "Create a stateful correlation rule that triggers when a handle request event (Windows Event ID 4656) with write access rights (e.g., 0x20 for PROCESS_VM_WRITE, 0x40 for PROCESS_VM_OPERATION, or 0x1FFFFF for PROCESS_ALL_ACCESS) targeting a GUI process is followed within 5 minutes by a persistence event (e.g., Windows Event ID 4698, 4657) initiated by the same target GUI process's PID. This sequence is a high-fidelity indicator of process hijacking for persistence.",
              "For each source process that requests a handle to a GUI process, track the rate at which the target process subsequently performs a persistence action. Establish a baseline of these rates across the environment. Alert when a specific source process causes a target's persistence rate to exceed a statistical threshold (e.g., 3 standard deviations above its mean or the global mean), indicating an anomalous causal relationship.",
              "Train a sequence-based anomaly detection model, such as an LSTM Autoencoder, on streams of security events grouped by host. A normal sequence might be an admin tool requesting a handle and performing a benign action. The model learns these normal sequences. Flag event sequences with high reconstruction error, such as a non-standard process requesting write access to explorer.exe followed by a registry run key modification, as anomalous and requiring investigation."
            ]
          }
        ]
      }
    ],
    "version": "2.3",
    "date_created": "2025-05-04",
    "last_updated": "2025-09-30",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is the adversary elevating privileges by hijacking process execution flow via KernelCallbackTable?",
    "tactic_id": "TA0004",
    "tactic_name": "Privilege Escalation",
    "indicators": [
      {
        "technique_id": "T1574.013",
        "name": "KernelCallbackTable",
        "evidence": [
          {
            "description": "A process running at a Low or Medium integrity level successfully requests a handle (Windows Event ID 4656) with write-access permissions (e.g., PROCESS_VM_WRITE) to a target GUI process running at a High or System integrity level.",
            "data_sources": [
              "Windows Event ID 4656"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "User Workstations, Terminal Servers",
            "action": [
              "After enabling 'Audit Handle Manipulation' policy, create a SIEM rule that triggers on Windows Event ID 4656 where the 'Object Type' is 'Process', the 'Accesses' field contains 'PROCESS_VM_WRITE' or 'PROCESS_ALL_ACCESS', and enriched event data shows the 'Subject/Client' process integrity level is lower than the 'Object/Target' process integrity level. Alert on every instance of this behavior.",
              "Create a matrix of all observed (Source Integrity Level, Target Integrity Level, Target Process Name) tuples from Event ID 4656 data. Calculate the frequency of each tuple. Any request from a lower to a higher integrity level is inherently suspicious; rank the anomaly score based on the statistical rarity of the specific process tuple (e.g., a (Medium, High, lsass.exe) tuple is a higher-scored anomaly than a more common UAC-related elevation).",
              "Model process interactions as a directed graph where nodes are processes (with attributes like integrity level) and edges are handle requests (with attributes like access rights). Train a Graph Neural Network (GNN) on benign interaction graphs. Use the trained model to score new handle requests in real-time, flagging edges that represent a low-to-high integrity write as highly anomalous, as they violate the learned security boundaries."
            ]
          },
          {
            "description": "A GUI process, after being accessed by another process, spawns a child process with an integrity level higher than its own (e.g., a Medium integrity 'explorer.exe' spawns a High integrity 'cmd.exe') without a corresponding UAC consent event.",
            "data_sources": [
              "Windows Event ID 4656",
              "Windows Event ID 4688"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "User Workstations, Servers with GUI access",
            "action": [
              "Create a correlation rule that triggers on a process creation event (Windows Event ID 4688) where the 'Creator Process' integrity level is lower than the 'New Process' integrity level, the 'Creator Process Name' is a common GUI application, and the 'Creator Process Name' is not 'consent.exe'. This specifically filters out normal UAC-prompted elevations.",
              "For each parent process, profile the distribution of its child processes' integrity levels. For a parent like 'explorer.exe', the expected integrity level is almost always 'Medium'. Alert if a child process is created with an integrity level that is a statistical outlier (e.g., 'High' or 'System'), as this indicates an abnormal, non-interactive elevation.",
              "Train a supervised classification model (e.g., Decision Tree) to predict if a process creation event represents legitimate or illegitimate privilege escalation. Features should include: Parent Process Name, Parent Integrity Level, Child Process Name, Child Integrity Level, and a binary feature for Parent is 'consent.exe'. The model will learn to flag non-UAC elevations originating from hijacked GUI processes as malicious."
            ]
          }
        ]
      }
    ],
    "version": "2.3",
    "date_created": "2025-05-04",
    "last_updated": "2025-09-30",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is the adversary evading defenses by hijacking process execution flow via KernelCallbackTable?",
    "tactic_id": "TA0005",
    "tactic_name": "Defense Evasion",
    "indicators": [
      {
        "technique_id": "T1574.013",
        "name": "KernelCallbackTable",
        "evidence": [
          {
            "description": "A GUI process with typically limited network activity (e.g., notepad.exe) or a browser process initiates an outbound network connection to a destination IP/domain that is a known C2 server, is newly registered, or uses a non-standard TLS fingerprint (JA3/JA3S).",
            "data_sources": [
              "Zeek conn.log",
              "Zeek dns.log",
              "Zeek ssl.log",
              "Windows Event ID 5156"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Network Egress Points, User Workstations, DNS Servers",
            "action": [
              "Correlate endpoint network events (Windows Event ID 5156) with network gateway logs (Zeek conn.log) to link a process name to a destination IP. Create a SIEM rule to alert if the process is a GUI application and the destination IP/domain matches an IOC feed of known C2 servers, or if the domain was registered within the last 30 days.",
              "For each GUI process, establish a multi-faceted network behavior baseline. This includes: 1) Set of common destination ports; 2) Entropy of requested domain names (from Zeek dns.log); 3) Set of common JA3/JA3S hashes (from Zeek ssl.log). Alert when a new connection from a process deviates by a significant margin (e.g., >99th percentile of rarity) on any of these metrics.",
              "For each critical GUI process, model its outbound data volume (bytes_out from Zeek conn.log) as a time series. Apply a forecasting model like ARIMA or Prophet to predict the expected traffic volume for the next time interval. Generate an alert if the actual observed traffic volume significantly exceeds the predicted volume's confidence interval, indicating potential data exfiltration masked by a legitimate process."
            ]
          },
          {
            "description": "A trusted GUI process (e.g., winword.exe, outlook.exe, explorer.exe) is observed as the parent process for a command-line interpreter or a built-in system reconnaissance tool, often with obfuscated command-line arguments.",
            "data_sources": [
              "Windows Event ID 4688"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "All Windows Endpoints and Servers",
            "action": [
              "Create a SIEM rule to generate a high-priority alert on any process creation event (Windows Event ID 4688) where the 'Parent Process Name' is in a watchlist of GUI applications (e.g., 'explorer.exe', 'chrome.exe', 'winword.exe') and the 'New Process Name' is in a watchlist of shells or reconnaissance tools (e.g., 'cmd.exe', 'powershell.exe', 'whoami.exe', 'net.exe', 'systeminfo.exe').",
              "Analyze historical process creation events (Windows Event ID 4688) to build a probabilistic model of parent-child relationships. Calculate the conditional probability P(Child | Parent). Alert on any observed parent-child pair where this probability is below a rarity threshold (e.g., <0.0001) or where the pair has never been seen in the environment's history. Also calculate the entropy of the command line; a high entropy value for a common process may indicate obfuscation.",
              "Train a One-Class SVM or an Isolation Forest model using only benign parent-child process pairs as the training data. The model learns a boundary that encapsulates normal process creation behavior. In production, score each new parent-child pair; any pair that falls outside this learned boundary is flagged as a novel and potentially malicious anomaly."
            ]
          },
          {
            "description": "A single process instance of a common GUI application exhibits a cluster of low-prevalence behaviors within a short time window, such as spawning a rare child process, writing a file to an unusual directory, and initiating an external network connection.",
            "data_sources": [
              "Windows Event ID 4688",
              "Windows Event ID 5156",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "User Workstations, Network Egress Points, File Servers",
            "action": [
              "Define a multi-stage correlation rule in the SIEM that looks for a sequence of events tied to the same process instance: 1) A handle request with write access to a GUI process (Event ID 4656); 2) Followed by the GUI process spawning a shell (Event ID 4688); 3) Followed by that shell making an external network connection (Event ID 5156 and Zeek conn.log). This multi-event chain is a strong indicator of compromise.",
              "Implement a dynamic risk scoring system for process instances. For each process, increment a score based on observed anomalous behaviors: +5 for spawning a shell, +3 for a network connection to a rare IP (based on historical traffic), +2 for a rare child process (based on parent-child frequency), +1 for high-entropy command line arguments. If a process's cumulative score exceeds a threshold derived from the 99th percentile of scores from benign processes, generate an alert.",
              "Define a 'process session' as a feature vector summarizing all activities attributed to a single process instance (e.g., count of child processes, count of network connections, total bytes sent). Use an unsupervised clustering algorithm like DBSCAN to group these session vectors. Normal GUI processes will form large, dense clusters. Hijacked processes, with their unique combination of activities, will be flagged as noise points or form very small, distinct clusters, which should be prioritized for investigation."
            ]
          }
        ]
      }
    ],
    "version": "2.3",
    "date_created": "2025-05-04",
    "last_updated": "2025-09-30",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]