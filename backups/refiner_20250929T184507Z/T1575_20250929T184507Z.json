[
  {
    "information_requirement": "Is an adversary using native code to obscure malicious activity on our mobile devices? (PIR)",
    "tactic_id": "TA0030",
    "tactic_name": "Defense Evasion",
    "indicators": [
      {
        "technique_id": "T1575",
        "name": "Native API",
        "evidence": [
          {
            "description": "A native library (.so file) within an Android Application Package (APK) has a calculated Shannon entropy value in the top 5% of all scanned libraries of a similar file size, and/or exports three or fewer JNI functions, with 'JNI_OnLoad' being the most common single export.",
            "data_sources": [
              "Static analysis results from APK files (e.g., strings, entropy scores, exported functions list)",
              "Mobile Device Management (MDM) application inventory logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate application vetting system, MDM server, Enterprise mobile device file systems",
            "action": "First, scan all APKs for native libraries (.so files) and check their SHA256 hashes against a threat intelligence feed of known malicious or packed libraries to find IOC matches. Second, for each native library, calculate its Shannon entropy and create a statistical baseline of entropy values segmented by file size (e.g., 0-100KB, 100KB-1MB). Alert on any library whose entropy exceeds the 95th percentile for its size class, or which exports fewer than three functions. Third, train a binary classification model (e.g., Random Forest) using features like entropy, file size, number of exports, and the presence of strings like 'JNI_OnLoad' to predict if a library is packed or malicious, and use it to score all new libraries."
          },
          {
            "description": "An Android application process executes a 'System.load' or 'System.loadLibrary' call where the file path argument points to a location outside the application's standard 'lib' directory, such as '/data/data/[app_name]/files/', particularly within 60 seconds of observed network activity downloading a file with a .so, .dex, or .jar extension.",
            "data_sources": [
              "Android Logcat streams from MDM",
              "Zeek conn.log",
              "Zeek files.log",
              "Zeek dns.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Enterprise wireless network segments, VPN concentrators, Monitored mobile device endpoints",
            "action": "First, use Zeek dns.log to correlate network connections from mobile devices with a threat intelligence feed of known malicious domains. If an application connects to a known-bad domain and Zeek files.log shows a subsequent download of a .so, .dex, or .jar file, generate a high-severity alert. Second, baseline the frequency of dynamic library loads from non-standard paths per application; use a 99th percentile statistical threshold to detect apps performing this action anomalously. Third, use a time-series analysis model on network traffic from Zeek conn.log to detect anomalous download events, flagging any sudden data spike followed by a 'System.load' event in Logcat within a 5-minute window."
          }
        ]
      }
    ],
    "version": "1.1",
    "date_created": "2025-09-26",
    "last_updated": "2025-09-29",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is an adversary executing malicious commands or binaries on mobile devices via native code? (PIR)",
    "tactic_id": "TA0041",
    "tactic_name": "Execution",
    "indicators": [
      {
        "technique_id": "T1575",
        "name": "Native API",
        "evidence": [
          {
            "description": "Static analysis of an application's native library (.so file) reveals the presence of imported functions 'system', 'execve', 'execl', or 'execvp', or contains embedded strings like '/system/bin/sh', 'su', or shell commands such as 'pm install', 'reboot', 'setprop'.",
            "data_sources": [
              "Static analysis results from APK files (e.g., imported functions list, embedded strings)",
              "MDM application inventory logs",
              "Endpoint Detection and Response (EDR) for mobile process events"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate application vetting system, Managed mobile device endpoints",
            "action": "First, statically scan all native libraries for known dangerous function imports ('system', 'execve') or embedded strings ('/bin/sh', 'su'). Maintain an allowlist of approved apps (e.g., diagnostic tools) and alert on any non-allowlisted app with these indicators. Second, establish a statistical baseline for the prevalence of shell-related strings across all applications; flag any app containing these strings that is a statistical outlier (e.g., present on <1% of devices). Third, develop a machine learning classifier using static APK features (permissions, native libraries, shell strings) to score the risk of an application attempting native code execution, flagging high-risk apps for sandbox analysis."
          },
          {
            "description": "An application known to contain native libraries establishes a recurring network connection (heartbeat) to a single IP address, characterized by small, periodic data transfers (e.g., <1KB every 5-15 minutes), and the destination IP is not associated with a known-good service or CDN.",
            "data_sources": [
              "Zeek conn.log",
              "Zeek dns.log",
              "MDM application inventory logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Network egress points (Firewall/Proxy), Enterprise DNS servers, VPN concentrators",
            "action": "First, enrich network logs (Zeek conn.log, Zeek dns.log) with threat intelligence; create high-priority alerts when an app with native code communicates with a destination on a C2 blocklist. Second, for each app using native code, calculate the entropy of destination ports and the standard deviation of the time delta between connections. Alert when low port entropy is combined with a near-zero time delta standard deviation, a statistical sign of C2 beaconing. Third, apply a time-series clustering algorithm (e.g., K-Shape) to network traffic patterns to group apps by communication profile; investigate outlier apps whose patterns resemble periodic, low-volume 'heartbeats'."
          }
        ]
      }
    ],
    "version": "1.1",
    "date_created": "2025-09-26",
    "last_updated": "2025-09-29",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]