[
  {
    "information_requirement": "Is an adversary maintaining persistence on mobile devices by abusing broadcast receivers? (TA0028 - Persistence)",
    "tactic_id": "TA0028",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1624.001",
        "name": "Broadcast Receivers",
        "evidence": [
          {
            "description": "An application's AndroidManifest.xml file contains a `<receiver>` element for a high-risk system broadcast intent (e.g., `android.intent.action.BOOT_COMPLETED`, `android.provider.Telephony.SMS_RECEIVED`) and a corresponding `<uses-permission>` element that enables a malicious capability (e.g., `android.permission.RECEIVE_SMS`, `android.permission.INTERNET`).",
            "data_sources": [
              "Parsed AndroidManifest.xml from APKs",
              "UEM application inventory metadata"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate Unified Endpoint Management (UEM) platform; Static Application Security Testing (SAST) pipeline; Internal corporate application repository; Third-party application vetting sandboxes",
            "action": [
              "Scan all application manifests for a watchlist of high-risk broadcast intents, such as 'android.intent.action.BOOT_COMPLETED' or 'android.provider.Telephony.SMS_RECEIVED'. Generate an alert if an application that is not on an approved allowlist registers a receiver from this watchlist.",
              "Parse all available application manifests to extract every declared broadcast receiver. Calculate the population frequency for each unique receiver across the entire mobile application inventory. For each application, identify any declared receivers that fall below a 5th percentile rarity threshold and flag the application for manual review.",
              "Extract features from application manifests, including multi-hot encoded vectors for all declared receivers and permissions. Train a random forest classification model on a labeled dataset of known benign and malicious APKs. Use the trained model to scan and classify all new and updated applications, flagging any with a malicious probability score exceeding 0.8 for dynamic sandbox analysis."
            ]
          },
          {
            "description": "A mobile security agent logs a runtime `registerReceiver()` API call from an application, with an IntentFilter for a sensitive system event (e.g., `android.intent.action.NEW_OUTGOING_CALL`, `android.app.action.DEVICE_ADMIN_ENABLED`) that is not justified by the application's documented functionality or category.",
            "data_sources": [
              "Mobile EDR API call logs",
              "Dynamic Analysis Sandbox API Traces (JSON)",
              "Android Debug Bridge (adb) logcat output"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Endpoint fleet of corporate-managed mobile devices; Mobile EDR/Threat Defense management console; Automated dynamic application security testing (DAST) pipeline",
            "action": [
              "Deploy a detection rule to the SIEM or Mobile EDR platform that alerts when a `registerReceiver()` API call is logged with an IntentFilter for a high-risk action (e.g., 'android.provider.Telephony.SMS_RECEIVED', 'android.intent.action.NEW_OUTGOING_CALL') and the parent application is not explicitly categorized as 'Communications' or 'System Tools'.",
              "Ingest Mobile EDR API call logs. For each application on each device, establish a 30-day rolling baseline of unique intents registered via `registerReceiver()`. Generate an alert if an application registers an intent that has not been observed in its historical baseline for that device or user profile, indicating a first-seen anomalous behavior.",
              "For each device, create time-ordered sequences of (timestamp, application_package_name, registered_intent_action) tuples from `registerReceiver()` calls. Train a Long Short-Term Memory (LSTM) autoencoder model on these sequences from a known-benign operational period. In production, continuously feed new sequences into the model and flag any sequence with a reconstruction error in the top 1st percentile as a potential anomaly for analyst investigation."
            ]
          },
          {
            "description": "Static analysis of an application's AndroidManifest.xml file reveals a 'toxic combination': the co-occurrence of a specific broadcast receiver and a set of permissions that, together, create a high-impact malicious capability (e.g., `RECEIVE_SMS` receiver with `READ_CONTACTS` and `INTERNET` permissions).",
            "data_sources": [
              "Parsed AndroidManifest.xml from APKs",
              "UEM application inventory metadata"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "UEM/MDM application inventory database; Static Application Security Testing (SAST) platform; Mobile Threat Defense (MTD) management console",
            "action": [
              "Define and maintain a list of known 'toxic combinations,' where each combination is a set containing one broadcast receiver and one or more permissions (e.g., {'receiver': 'android.provider.Telephony.SMS_RECEIVED', 'permissions': ['android.permission.READ_CONTACTS', 'android.permission.INTERNET']}). Scan all application manifests against this list and generate a critical alert for any application containing a complete match.",
              "From all parsed manifests, create a co-occurrence matrix for all observed (receiver, permission) pairs. Calculate a rarity score for each pair using a negative log probability, such as $$ S = -\\\\log(P(pair)) $$. For each application, sum the rarity scores of all its declared (receiver, permission) pairs to produce a total risk score. Flag applications in the top 5th percentile of risk scores for manual analysis.",
              "For each application, generate a binary feature vector where each element represents the presence (1) or absence (0) of a specific receiver or permission from the global set of all observed receivers/permissions. Apply a density-based clustering algorithm, such as DBSCAN, to these vectors. Manually analyze the resulting clusters, prioritizing small, dense clusters that are not associated with known legitimate software vendors for deeper investigation."
            ]
          }
        ]
      }
    ],
    "last_updated": "2025-10-01",
    "version": "1.5",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]