[
  {
    "information_requirement": "Is an adversary maintaining persistence on mobile devices by abusing broadcast receivers? (TA0028 - Persistence)",
    "tactic_id": "TA0028",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1624.001",
        "name": "Broadcast Receivers",
        "evidence": [
          {
            "description": "An application's AndroidManifest.xml file contains a <receiver> element for a high-risk system broadcast intent (e.g., 'android.provider.Telephony.SMS_RECEIVED') and a corresponding <uses-permission> element for a permission that grants access to the data associated with that intent (e.g., 'android.permission.READ_SMS'), creating a capability for unauthorized data access or action upon a system event.",
            "data_sources": [
              "Parsed AndroidManifest.xml data from SAST/MTD scans",
              "UEM application inventory reports containing manifest details",
              "Android Package (APK) files"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate Unified Endpoint Management (UEM) platform, Internal corporate application repository, Third-party application vetting sandbox, Static Application Security Testing (SAST) pipeline",
            "action": "1. (Symbolic) Using a static analysis tool or SIEM query, scan all managed application manifests. Define a watchlist of high-risk broadcast receivers (e.g., 'android.intent.action.BOOT_COMPLETED', 'android.provider.Telephony.SMS_RECEIVED', 'android.intent.action.NEW_OUTGOING_CALL'). Generate a high-severity alert if an application's manifest contains a receiver from this watchlist and the application is not on an approved allowlist. 2. (Statistical) For all applications in the UEM inventory, parse their AndroidManifest.xml files to extract all declared broadcast receivers. Calculate the population frequency for each unique receiver. For each application, identify any declared receivers that are statistically rare (e.g., fall below the 5th percentile of frequency across the entire application population). Flag applications with rare receivers for manual review, as they may indicate specialized or malicious functionality. 3. (Machine Learning) Extract features from each application's manifest, including a multi-hot encoded vector for all declared receivers, a multi-hot encoded vector for all declared permissions, and the statistical rarity (inverse frequency) of its rarest receiver. Train a logistic regression or random forest classifier on a labeled dataset of known benign (e.g., from the corporate app store) and malicious (e.g., from public malware feeds) APK manifests. Deploy the model to classify all new and updated applications, flagging those with a predicted probability of being malicious greater than 0.8 for manual reverse engineering."
          },
          {
            "description": "A Mobile EDR agent observes a process executing the 'registerReceiver()' API call at runtime. The associated IntentFilter targets a high-risk system event (e.g., 'android.provider.Telephony.SMS_RECEIVED') and the application's established behavioral baseline or declared category (e.g., a 'Game' or 'Calculator') does not justify monitoring such events.",
            "data_sources": [
              "Mobile EDR agent logs detailing API calls (e.g., process, function, parameters)",
              "Android Debug Bridge (adb) logcat output from targeted devices",
              "Dynamic analysis sandbox API call trace logs",
              "Frida instrumentation trace logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Endpoint fleet of corporate-managed mobile devices, Automated dynamic application security testing (DAST) pipeline, Mobile EDR/Threat Defense management console",
            "action": "1. (Symbolic) In the Mobile EDR platform, create a detection rule that generates an alert when a process makes a 'registerReceiver()' API call with an IntentFilter for 'android.provider.Telephony.SMS_RECEIVED', 'android.intent.action.NEW_OUTGOING_CALL', or 'android.intent.action.BOOT_COMPLETED', and the parent application's category is not 'Communications', 'Productivity', or 'System Tools'. 2. (Statistical) Ingest Mobile EDR API call logs into a SIEM. For each application on each device, establish a 30-day rolling baseline profile of its runtime behavior, including the set of unique intents registered and the hourly count of registrations for each intent. Generate an alert if an application registers an intent not present in its historical baseline, or if the hourly registration count for any intent exceeds 3 standard deviations above its 30-day mean for that hour of the day. 3. (Machine Learning) From Mobile EDR logs, create time-ordered sequences of (timestamp, application_package_name, registered_intent_action) tuples for each device. Train a Long Short-Term Memory (LSTM) autoencoder model on these sequences from a known-benign time period (e.g., the first 30 days post-enrollment). In production, continuously feed new sequences into the model. Flag any sequence that produces a reconstruction error in the top 1st percentile for analyst investigation, as this indicates a significant deviation from the device's normal pattern of runtime event registration."
          },
          {
            "description": "Static analysis of an application's AndroidManifest.xml reveals a 'toxic combination' of a declared broadcast receiver and a set of permissions that, when combined, enable a high-impact malicious capability. For example, the combination of the 'android.provider.Telephony.SMS_RECEIVED' receiver with both the 'android.permission.READ_CONTACTS' and 'android.permission.INTERNET' permissions allows for the interception of SMS messages and subsequent exfiltration of both message content and contact lists.",
            "data_sources": [
              "Parsed AndroidManifest.xml data from SAST/MTD scans",
              "UEM application inventory reports containing manifest permissions and receivers",
              "Google Play Store manifest data via API"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "UEM/MDM application inventory database, Static Application Security Testing (SAST) platform, Mobile Threat Defense (MTD) management console",
            "action": "1. (Symbolic) Define a list of high-risk 'toxic combinations', where each combination is a set containing one broadcast receiver and one or more permissions (e.g., {'receiver': 'android.provider.Telephony.SMS_RECEIVED', 'permissions': ['android.permission.READ_CONTACTS', 'android.permission.INTERNET']}). Scan all application manifests against this list. Generate a critical alert if an application's manifest contains a complete match for any defined combination. 2. (Statistical) From all parsed manifests, create a co-occurrence matrix for all possible (receiver, permission) pairs. Calculate a rarity score for each pair, such as $$ S = 1 / \\log(f+1) $$, where $$ f $$ is the frequency of the pair. For each application, calculate a total risk score by summing the rarity scores of all its declared (receiver, permission) pairs. Flag the top 5% of applications with the highest total risk scores for manual analysis, as they utilize uncommon combinations of receivers and permissions. 3. (Machine Learning) For each application, create a binary feature vector where each element represents the presence (1) or absence (0) of a specific receiver or permission from the set of all possible receivers/permissions observed in the environment. Apply a density-based clustering algorithm like DBSCAN to these vectors. Manually analyze the resulting clusters. Small, dense clusters that are not associated with known legitimate software are highly suspicious and should be prioritized for investigation as they may represent new or unknown malware families sharing a common persistence pattern."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "1.3",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]