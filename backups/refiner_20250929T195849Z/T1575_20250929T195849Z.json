[
  {
    "information_requirement": "Is an adversary using native code to obscure malicious activity on our mobile devices? (PIR)",
    "tactic_id": "TA0030",
    "tactic_name": "Defense Evasion",
    "indicators": [
      {
        "technique_id": "T1575",
        "name": "Native API",
        "evidence": [
          {
            "description": "An APK's native library (.so file) exhibits characteristics of packing or obfuscation, defined as: 1) a calculated Shannon entropy value greater than the 95th percentile for libraries of a comparable file size (+/- 10%), or 2) the library exports three or fewer JNI functions, with 'JNI_OnLoad' being one of them.",
            "data_sources": [
              "APK static analysis reports (JSON/XML)",
              "MDM application inventory logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate application vetting system, MDM server, Enterprise mobile device file systems",
            "action": "1. (Symbolic) Query for native library (.so file) SHA256 hashes from mobile application inventories against a threat intelligence feed of known malicious or packed libraries. Generate a critical alert upon a match. 2. (Statistical) For each library not matching an IOC, calculate its Shannon entropy. Create statistical baselines of entropy values, binned by file size (e.g., 0-50KB, 50-250KB, 250KB-1MB, 1MB+). Flag any library with an entropy score exceeding the 95th percentile for its respective size bin. Additionally, flag libraries that export three or fewer functions, especially if one is 'JNI_OnLoad'. 3. (Machine Learning) Develop and apply a binary classification model (e.g., Gradient Boosting) trained on a labeled dataset of benign and malicious/packed native libraries. Use features such as file size, Shannon entropy, the count of exported functions, and the presence of 'JNI_OnLoad'. Score all new libraries and investigate those with a probability score greater than 0.85 of being malicious or packed."
          },
          {
            "description": "A process associated with an Android application is observed loading a library (e.g., via 'System.load' or 'System.loadLibrary' calls in logs) from a non-standard, writable directory (e.g., /data/data/[app_name]/files, /sdcard/downloads) within 120 seconds after the device downloaded a file with a .so, .dex, or .jar extension from a low-reputation domain.",
            "data_sources": [
              "Android Logcat streams from MDM",
              "Zeek conn.log",
              "Zeek files.log",
              "Zeek dns.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Enterprise wireless network segments, VPN concentrators, Monitored mobile device endpoints",
            "action": "1. (Symbolic) Join Zeek dns.log with a threat intelligence feed of malicious domains. If a mobile device's DNS query for a malicious domain is followed by a file download event in Zeek files.log for a file of type .so, .dex, or .jar, and then a dynamic library load event is seen in Android Logcat for that device, create a high-severity alert. 2. (Statistical) For each application, establish a baseline of its library loading behavior. Calculate the frequency of loads from non-standard paths (any path not matching '/data/app/[app_name]/lib/'). Alert on any application whose non-standard load frequency exceeds the 99th percentile of its own historical behavior. 3. (Machine Learning) Implement a sequence analysis model (e.g., LSTM) to detect the chain of events: 1) network connection to a new or rare domain (Zeek dns.log), 2) download of an executable file (Zeek files.log), and 3) dynamic library load from a writable directory (Android Logcat). Score all observed sequences and flag those with a high probability of matching a trained malicious pattern."
          }
        ]
      }
    ],
    "version": "1.2",
    "date_created": "2025-09-26",
    "last_updated": "2025-09-29",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is an adversary executing malicious commands or binaries on mobile devices via native code? (PIR)",
    "tactic_id": "TA0041",
    "tactic_name": "Execution",
    "indicators": [
      {
        "technique_id": "T1575",
        "name": "Native API",
        "evidence": [
          {
            "description": "A native library (.so file) from an APK contains evidence of command execution capabilities, defined as: 1) importing common execution-related C functions such as 'system', 'execve', 'execl', or 'execvp', or 2) containing embedded strings indicative of shell commands, such as '/system/bin/sh', 'su', 'pm install', 'am start', 'reboot', or 'setprop'.",
            "data_sources": [
              "APK static analysis reports (JSON/XML)",
              "MDM application inventory logs",
              "Mobile EDR process event logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate application vetting system, Managed mobile device endpoints",
            "action": "1. (Symbolic) Scan all native libraries for a blocklist of imported functions ('system', 'execve') and embedded strings ('/bin/sh', 'su'). Compare findings against an application allowlist of approved tools that legitimately use these functions. Alert on any non-allowlisted application that contains these indicators. 2. (Statistical) Calculate the prevalence of each sensitive string and imported function across the entire corpus of applications. Flag any application that contains indicators present in less than 1% of the total app population or that has a total count of such indicators greater than 3 standard deviations above the mean. 3. (Machine Learning) Train a supervised learning model (e.g., Logistic Regression) to classify applications as 'potential native executor' or 'benign'. Use features like the presence of execution-related function imports, the count of shell-like strings, and requested Android permissions. Flag applications with a high prediction score for dynamic sandbox analysis."
          },
          {
            "description": "An application with one or more native libraries generates network traffic consistent with C2 beaconing. This is defined as repeated connections to the same destination IP address or domain with a low standard deviation in time intervals (jitter), small and consistent packet sizes (e.g., < 2KB), and a destination that is not on a known-good service allowlist.",
            "data_sources": [
              "Zeek conn.log",
              "Zeek dns.log",
              "MDM application inventory logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Network egress points (Firewall/Proxy), Enterprise DNS servers, VPN concentrators",
            "action": "1. (Symbolic) Join Zeek dns.log and conn.log data with threat intelligence feeds. Generate a high-severity alert when any mobile device communicates with a destination IP, domain, or JA3/JA4S hash on a known C2 blocklist. 2. (Statistical) For each source-destination pair in Zeek conn.log over a 24-hour period, calculate the standard deviation of the time delta between connections and the standard deviation of the 'orig_bytes' and 'resp_bytes' fields. Alert on connections exhibiting low standard deviation in all three metrics (e.g., near-zero jitter, consistent packet size), especially if the destination IP is newly observed. 3. (Machine Learning) Use an unsupervised clustering algorithm (e.g., DBSCAN) on network connection features from Zeek conn.log (e.g., duration, bytes sent, time between connections). Isolate and investigate small, dense clusters of activity that do not group with large clusters of benign traffic, as these often represent C2 beaconing."
          }
        ]
      }
    ],
    "version": "1.2",
    "date_created": "2025-09-26",
    "last_updated": "2025-09-29",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]