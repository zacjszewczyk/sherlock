[
  {
    "information_requirement": "Is an adversary maintaining persistence on mobile devices by abusing broadcast receivers? (TA0028 - Persistence)",
    "tactic_id": "TA0028",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1624.001",
        "name": "Broadcast Receivers",
        "evidence": [
          {
            "description": "An application's AndroidManifest.xml file declares a <receiver> for a high-risk broadcast intent AND also declares a <uses-permission> for a permission that is functionally related to the intent, creating a high-risk capability. For example, registering 'android.provider.Telephony.SMS_RECEIVED' and requesting 'android.permission.READ_SMS'.",
            "data_sources": [
              "Decompiled AndroidManifest.xml",
              "Mobile Threat Defense (MTD) application scan results",
              "Unified Endpoint Management (UEM) application inventory logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate Unified Endpoint Management (UEM) platform, Internal corporate application repository, Third-party application vetting sandbox",
            "action": "1. (Symbolic) Using a static analysis tool, scan all managed application AndroidManifest.xml files. Create a watchlist of high-risk broadcast receivers (e.g., 'android.intent.action.BOOT_COMPLETED', 'android.provider.Telephony.SMS_RECEIVED', 'android.intent.action.NEW_OUTGOING_CALL'). Generate an alert if an application both registers a receiver from this list and is not present on an approved application allowlist. 2. (Statistical) For all applications in the UEM inventory, parse the AndroidManifest.xml to extract all declared broadcast receivers. Calculate the global frequency of each receiver across the entire application population. For each application, identify any declared receivers that fall below the 5th percentile of frequency. Flag these applications for review, as they use uncommon system events which may indicate specialized malicious functionality. 3. (Machine Learning) Develop a feature set from each application's manifest, including a binary vector for the presence of known high-risk receivers, a count of total receivers, a count of sensitive permissions, and the statistical rarity of its rarest receiver. Train a logistic regression classifier on a labeled dataset of known benign (from the corporate app store) and malicious (from public malware feeds) APK manifests. Deploy the model to classify all new and updated applications, flagging those with a predicted probability of being malicious greater than 0.8 for manual reverse engineering."
          },
          {
            "description": "A running application process dynamically registers a broadcast receiver at runtime via the 'registerReceiver()' API call, where the registered IntentFilter corresponds to a high-risk system event (e.g., 'android.provider.Telephony.SMS_RECEIVED') and the application's category or function (e.g., a simple calculator app) does not justify this behavior.",
            "data_sources": [
              "Mobile EDR agent logs detailing API calls",
              "Android Debug Bridge (adb) logcat output",
              "Dynamic analysis sandbox API call trace"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Endpoint fleet of corporate-managed mobile devices, Automated dynamic application security testing (DAST) pipeline, Network gateway security stack monitoring mobile device traffic",
            "action": "1. (Symbolic) In the Mobile EDR platform, create a detection rule that generates an alert when a process whose parent application is not in the 'Communications' or 'System Tools' category makes a 'registerReceiver()' API call with an IntentFilter for 'android.provider.Telephony.SMS_RECEIVED' or 'android.intent.action.NEW_OUTGOING_CALL'. 2. (Statistical) For each application on each device, ingest Mobile EDR API call logs. For a 30-day rolling window, establish a baseline profile for each app including the set of unique intents registered and the count of registrations per hour. Generate an alert if an application registers an intent not seen in its historical baseline, or if the hourly registration count for any intent exceeds 3 standard deviations above its 30-day mean. 3. (Machine Learning) For each device, create sequences of (timestamp, application_name, registered_intent) tuples from Mobile EDR logs. Train an LSTM autoencoder model on these sequences from a known-benign time period. In production, feed new sequences into the model. Flag any sequence that produces a reconstruction error in the top 1st percentile for analyst investigation, as this indicates a significant deviation from the device's normal pattern of runtime event registration."
          },
          {
            "description": "An application's manifest declares a combination of a broadcast receiver and permissions that, when used together, create a high-risk capability. For example, the combination of the 'android.provider.Telephony.SMS_RECEIVED' receiver with the 'android.permission.READ_CONTACTS' and 'android.permission.INTERNET' permissions allows for the interception and exfiltration of SMS messages and contact lists.",
            "data_sources": [
              "Decompiled AndroidManifest.xml",
              "Unified Endpoint Management (UEM) application permission reports",
              "Google Play Store manifest data"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "UEM/MDM application inventory database, Static application security testing (SAST) platform, Mobile Threat Defense (MTD) management console",
            "action": "1. (Symbolic) Define a list of high-risk combinations, where each combination is a set of one broadcast receiver and one or more permissions (e.g., {'receiver': 'SMS_RECEIVED', 'permissions': ['READ_CONTACTS', 'INTERNET']}). Scan all application manifests. Generate a critical alert if an application's manifest contains a complete match for any defined high-risk combination. 2. (Statistical) From all parsed manifests, create a co-occurrence matrix for all possible pairs of (receiver, permission). Calculate a rarity score for each pair based on its inverse frequency. For each application, calculate a total risk score by summing the rarity scores of all its declared (receiver, permission) pairs. Flag the top 5% of applications with the highest total risk scores for manual analysis, as they combine uncommon receivers and permissions. 3. (Machine Learning) For each application, create a binary feature vector where each element represents the presence or absence of a specific receiver or permission. Apply a density-based clustering algorithm like DBSCAN to these vectors. Manually analyze the resulting clusters. Small, dense clusters that are not associated with known legitimate software are highly suspicious and should be prioritized for investigation as they may represent new or unknown malware families sharing a common persistence mechanism."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "1.2",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]