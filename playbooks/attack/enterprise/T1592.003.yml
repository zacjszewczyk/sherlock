name: T1592.003: Firmware
id: a7b3c9d1-e2f4-4a5b-8c6d-7e8f9a0b1c2d
description: This playbook helps identify if an adversary is actively gathering information about an organization's host and device firmware. It focuses on detecting reconnaissance activities from external sources and post-compromise discovery from internal hosts. Detections include identifying inbound connections from known malicious scanners, analyzing HTTP requests for tool-specific signatures, detecting horizontal and vertical network scans, monitoring for connection attempts to sensitive management ports, and searching for command-line execution of firmware-querying tools.
type: technique
related:
- TA0043: Reconnaissance
contributors:
- Zachary Szewczyk
- Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
- question: Are known malicious scanners or reconnaissance actors attempting to connect to our network?
  context: |
    This question aims to identify initial reconnaissance attempts by cross-referencing inbound connection logs with a threat intelligence database of known malicious IPs. A successful connection from a known bad actor is a high-confidence indicator of targeted activity, while even a failed attempt suggests the organization is being probed. This is a foundational step in detecting external threats.
  answer_sources:
  - Zeek conn.log
  - Internet gateway firewalls
  - DMZ network sensors
  - public-facing application servers
  - cloud VPC internet gateways
  - VPN concentrators
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      inbound_connections = SEARCH conn.log WHERE direction=inbound
      known_scanners = GET threat_intel_feed('scanning_ips')
      FOR conn IN inbound_connections:
        IF conn.source_ip IN known_scanners:
          IF conn.state IS NOT 'S0', 'REJ', 'RSTO':
            ALERT(severity=high, reason='Successful connection from known scanner')
          ELSE:
            ALERT(severity=medium, reason='Connection attempt from known scanner')
- question: Is any single external IP exhibiting scanning behavior by connecting to an anomalously high number of unique destination ports?
  context: |
    This question seeks to identify scanning behavior through statistical anomaly detection. An adversary's scanning tool will often connect to far more unique ports than a legitimate client. By establishing a historical baseline for connection and port counts for external IPs, we can flag any IP that significantly deviates from this norm as a potential scanner, even if it is not on a threat intelligence list.
  answer_sources:
  - Zeek conn.log
  - Internet gateway firewalls
  - DMZ network sensors
  - public-facing application servers
  - cloud VPC internet gateways
  - VPN concentrators
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      FOR each external_ip in conn.log over last 24h:
        total_connections = COUNT connections FROM external_ip
        unique_ports = COUNT_DISTINCT destination_port FROM external_ip
        historical_avg_ports = GET_BASELINE(external_ip, 'unique_ports')
        all_ip_95th_percentile = GET_PERCENTILE('all_external_ips', 'unique_ports', 95)
        IF unique_ports > historical_avg_ports OR unique_ports > all_ip_95th_percentile:
          ALERT(severity=medium, reason='Anomalous port scanning behavior detected')
- question: Can we use machine learning to proactively identify new, unknown scanners based on their connection characteristics?
  context: |
    This question leverages a machine learning classification model to identify potential scanners that are not yet included in static threat intelligence feeds. By training a model on features from known benign and malicious connections (e.g., protocol, duration, bytes transferred, connection state), we can score and classify new inbound traffic in near-real-time to uncover emerging threats based on their behavioral patterns.
  answer_sources:
  - Zeek conn.log
  - Internet gateway firewalls
  - DMZ network sensors
  - public-facing application servers
  - cloud VPC internet gateways
  - VPN concentrators
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      labeled_data = GET_LABELED_DATA(threat_intel_feeds)
      features = ['protocol', 'service', 'duration', 'orig_bytes', 'resp_bytes', 'conn_state']
      model = TRAIN_CLASSIFIER(labeled_data, features)
      FOR each new_connection:
        prediction = model.PREDICT(new_connection.features)
        IF prediction == 'scanner':
          ALERT(severity=low, reason='ML model identified potential scanner')
- question: Are automated tools attempting to fingerprint our web servers for specific firmware versions or vulnerabilities?
  context: |
    This question focuses on detecting reconnaissance tools by searching for their specific signatures in web server logs. Many scanners and vulnerability assessment tools use unique User-Agent strings or probe for specific, known file paths (e.g., '/firmware', '/.env'). By using a list of regular expressions to match these patterns, we can generate high-fidelity alerts for attempts to fingerprint our web-facing applications.
  answer_sources:
  - Zeek http.log
  - Zeek conn.log
  - Zeek ssl.log
  - Public-facing web servers
  - API gateways
  - management interfaces for network appliances
  - load balancers
  - Web Application Firewalls (WAFs)
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      scanner_ua_patterns = ['Nmap', 'masscan', 'ZGrab', 'Nuclei']
      firmware_uri_patterns = ['/version', '/firmware', '/.git/', '/.env']
      http_requests = SEARCH http.log WHERE source_is_external
      FOR req IN http_requests:
        IF REGEX_MATCH(req.user_agent, scanner_ua_patterns) OR REGEX_MATCH(req.uri, firmware_uri_patterns):
          ALERT(severity=medium, reason='Firmware fingerprinting attempt detected')
- question: Is an external IP using a single, non-diverse User-Agent string, suggesting automated scripting?
  context: |
    This question aims to identify automated activity by analyzing the diversity of User-Agent strings from a single source IP. Legitimate users browsing a site may generate traffic with a few different User-Agents (e.g., from a browser and embedded web views), but a simple script will almost always use the exact same User-Agent for every request. A very low Shannon entropy score for the User-Agent field indicates a lack of diversity and is a strong signal of automated, non-human traffic.
  answer_sources:
  - Zeek http.log
  - Zeek conn.log
  - Zeek ssl.log
  - Public-facing web servers
  - API gateways
  - management interfaces for network appliances
  - load balancers
  - Web Application Firewalls (WAFs)
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      FOR each external_ip in http.log over last 1h:
        user_agents = GET user_agent FROM http.log WHERE source_ip=external_ip
        entropy = SHANNON_ENTROPY(user_agents)
        baseline_entropy = GET_PERCENTILE('all_external_ips', 'user_agent_entropy', 5)
        IF entropy < baseline_entropy:
          ALERT(severity=low, reason='Anomalously low User-Agent entropy suggests automation')
- question: Can we identify clusters of anomalous HTTP requests that indicate automated tool usage?
  context: |
    This question uses unsupervised machine learning to find groups of suspicious activity that do not conform to normal user behavior. By converting HTTP request features (like URI length and User-Agent) into numerical vectors and applying a clustering algorithm like DBSCAN, normal user traffic will form a large, dense cluster. Smaller, separate clusters often represent automated tools, as they exhibit consistent, non-standard behavior that distinguishes them from the majority of traffic.
  answer_sources:
  - Zeek http.log
  - Zeek conn.log
  - Zeek ssl.log
  - Public-facing web servers
  - API gateways
  - management interfaces for network appliances
  - load balancers
  - Web Application Firewalls (WAFs)
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      features = ['uri_length', 'uri_special_chars', 'user_agent_vector', 'header_count']
      request_vectors = VECTORIZE(http.log, features)
      clusters = DBSCAN(request_vectors)
      FOR cluster IN clusters:
        IF cluster.size < threshold AND cluster.density > threshold:
          ALERT(severity=medium, reason='Anomalous cluster of HTTP requests detected, possible tool usage')
- question: Is a single external IP conducting a horizontal (many hosts) or vertical (many ports) scan against our network?
  context: |
    This question provides a simple, real-time method for detecting the most common types of network scans. By creating a rule with a sliding window, we can immediately alert when a single source IP crosses a defined threshold for either the number of unique destination hosts (horizontal scan) or unique destination ports on one host (vertical scan). This is a classic and effective method for catching noisy, unsophisticated scanning.
  answer_sources:
  - Zeek conn.log
  - Perimeter firewalls
  - network tap at the internet edge
  - cloud VPC flow logs
  - cloud security group flow logs
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      RULE: On new conn.log event:
      WITHIN 5_minutes FOR a_single source_ip:
        unique_hosts = COUNT_DISTINCT(destination_host)
        unique_ports = COUNT_DISTINCT(destination_port) on a_single_host
        IF unique_hosts > 50:
          ALERT(severity=high, reason='Horizontal scan detected')
        IF unique_ports > 100:
          ALERT(severity=high, reason='Vertical scan detected')
- question: Over a longer period, are any external IPs exhibiting scanning behavior that exceeds historical norms?
  context: |
    This question is designed to catch scanners that may be operating below real-time thresholds but whose activity is still statistically significant over time. By running an hourly job to count distinct hosts and ports contacted by each external IP, and comparing these counts to a 30-day baseline, we can identify scanners with high confidence. Flagging IPs that exceed the 99.5th percentile helps to filter out noise and focus on true outliers.
  answer_sources:
  - Zeek conn.log
  - Perimeter firewalls
  - network tap at the internet edge
  - cloud VPC flow logs
  - cloud security group flow logs
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      SCHEDULED_JOB (hourly):
      FOR each external_ip in conn.log over last hour:
        distinct_hosts = COUNT_DISTINCT(destination_host)
        distinct_ports = COUNT_DISTINCT(destination_port)
        host_percentile = GET_PERCENTILE('all_external_ips', 'distinct_hosts_30d', 99.5)
        port_percentile = GET_PERCENTILE('all_external_ips', 'distinct_ports_30d', 99.5)
        IF distinct_hosts > host_percentile OR distinct_ports > port_percentile:
          ALERT(severity=medium, reason='Source IP exceeds 99.5th percentile for scanning')
- question: Is an adversary using 'low-and-slow' scanning techniques to evade simple threshold-based detection?
  context: |
    This question addresses sophisticated adversaries who deliberately slow down their scanning to avoid triggering alerts based on volume. By analyzing the time between connection attempts from a source IP, we can detect machine-like, rhythmic patterns that are distinct from the more random timing of human-generated traffic. A time series anomaly detection model can learn what normal traffic patterns look like and flag IPs whose connection timing is too consistent, indicating automation.
  answer_sources:
  - Zeek conn.log
  - Perimeter firewalls
  - network tap at the internet edge
  - cloud VPC flow logs
  - cloud security group flow logs
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      benign_timeseries = GET_INTERARRIVAL_TIMES('known_benign_ips')
      model = TRAIN_ARIMA(benign_timeseries)
      FOR each external_ip:
        ip_timeseries = GET_INTERARRIVAL_TIMES(external_ip)
        is_anomalous = model.PREDICT(ip_timeseries)
        IF is_anomalous:
          ALERT(severity=medium, reason='Low-and-slow scan suspected based on connection timing')
- question: Are external actors attempting to connect to or query known device management ports?
  context: |
    This question focuses on detecting targeted reconnaissance against high-value management interfaces like IPMI, SNMP, or RDP. An external connection attempt to one of these ports is highly suspicious. By monitoring a watchlist of these ports and correlating connection attempts with protocol-specific logs (e.g., checking for SNMP `get-request` commands), we can confirm and alert on targeted probing of critical infrastructure.
  answer_sources:
  - Zeek conn.log
  - Zeek weird.log
  - Zeek snmp.log
  - Zeek http.log
  - Zeek rdp.log
  - Network segments hosting IoT/OT devices
  - data center management networks
  - network appliance management interfaces
  - blade server chassis management interfaces
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      mgmt_ports = [161, 623, 3389, 5900, 5985, 5986]
      connections = SEARCH conn.log WHERE destination_port IN mgmt_ports AND source_is_external
      FOR conn IN connections:
        snmp_query = SEARCH snmp.log WHERE conn_uid=conn.uid AND command='get-request'
        rdp_attempt = SEARCH rdp.log WHERE conn_uid=conn.uid
        IF snmp_query OR rdp_attempt OR conn.state IS NOT 'S0':
          ALERT(severity=high, reason='Targeted probe against management port detected')
- question: Can we distinguish targeted management port probing from general, untargeted web traffic?
  context: |
    This question helps to differentiate between an adversary specifically targeting management interfaces and random internet noise or misconfigurations. A legitimate web crawler might accidentally hit a management port, but a targeted actor's traffic will show a much higher ratio of connections to management ports versus standard web ports (80, 443). By calculating this ratio for each IP and flagging those in the top percentile, we can isolate actors with clear intent.
  answer_sources:
  - Zeek conn.log
  - Zeek weird.log
  - Zeek snmp.log
  - Zeek http.log
  - Zeek rdp.log
  - Network segments hosting IoT/OT devices
  - data center management networks
  - network appliance management interfaces
  - blade server chassis management interfaces
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      mgmt_ports = [161, 623, 3389, 5900, 5985, 5986]
      web_ports = [80, 443]
      FOR each external_ip:
        mgmt_conns = COUNT connections WHERE dest_port IN mgmt_ports
        web_conns = COUNT connections WHERE dest_port IN web_ports
        IF web_conns > 0:
          ratio = mgmt_conns / web_conns
          baseline_ratio = GET_PERCENTILE('all_external_ips', 'mgmt_web_ratio', 98)
          IF ratio > baseline_ratio:
            ALERT(severity=medium, reason='IP has high ratio of management-to-web port connections')
- question: Can we detect novel or malformed fingerprinting attempts by analyzing protocol anomalies?
  context: |
    This question is designed to catch advanced or custom fingerprinting tools that may not have standard signatures. These tools often work by sending malformed or unexpected packets to elicit a specific response from a device's network stack. Zeek's `weird.log` is specifically designed to capture these protocol anomalies. By training an unsupervised machine learning model on what 'normal' weird events look like, we can score new events and flag highly anomalous ones for investigation as potential fingerprinting.
  answer_sources:
  - Zeek conn.log
  - Zeek weird.log
  - Zeek snmp.log
  - Zeek http.log
  - Zeek rdp.log
  - Network segments hosting IoT/OT devices
  - data center management networks
  - network appliance management interfaces
  - blade server chassis management interfaces
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      normal_weird_events = GET weird.log FROM baseline_period
      model = TRAIN_ISOLATION_FOREST(normal_weird_events)
      FOR each new_weird_event:
        anomaly_score = model.SCORE(new_weird_event)
        IF anomaly_score > threshold:
          ALERT(severity=low, reason='Highly anomalous protocol event detected, possible fingerprinting')
- question: Has an adversary, once inside the network, run commands to discover local system firmware information?
  context: |
    This question shifts focus from external reconnaissance to post-compromise discovery. Once on a host, an adversary will often try to identify the underlying hardware by querying for firmware and BIOS information. This helps them determine if they are in a virtualized environment or if the hardware is vulnerable to a specific exploit. We can detect this by monitoring for the specific commands and WMI queries used for this purpose.
  answer_sources:
  - Windows Event ID 4688
  - Windows Event ID 4104
  - Domain Controllers
  - administrator workstations
  - virtualization hosts
  - critical application servers
  - endpoint devices
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      keywords = ['wmic bios', 'Get-WmiObject win32_bios', 'systeminfo', 'dmidecode', 'msinfo32.exe']
      events = SEARCH EventID:4688 OR EventID:4104
      FOR event in events:
        IF event.command_line CONTAINS ANY(keywords):
          ALERT(severity=high, reason='Firmware discovery command executed on host')
- question: Is there an anomalous frequency of firmware discovery commands being run on any single host?
  context: |
    This question helps detect the execution of a reconnaissance script, which may run multiple discovery commands in a short period. While a single command might be legitimate administrative activity, a sudden spike is suspicious. By establishing a baseline for how often these commands are run on each host and using a moving average and standard deviation, we can automatically alert when the frequency of execution becomes statistically anomalous.
  answer_sources:
  - Windows Event ID 4688
  - Windows Event ID 4104
  - Domain Controllers
  - administrator workstations
  - virtualization hosts
  - critical application servers
  - endpoint devices
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      FOR each host:
        baseline_avg = GET_BASELINE_AVG(host, 'firmware_query_count')
        baseline_stddev = GET_BASELINE_STDDEV(host, 'firmware_query_count')
        current_count = COUNT firmware_query_commands in last 1h
        IF current_count > baseline_avg + (3 * baseline_stddev):
          ALERT(severity=medium, reason='Anomalous frequency of firmware query commands')
- question: Can we detect a malicious sequence of commands that includes firmware discovery as one of its steps?
  context: |
    This question aims to identify malicious behavior by analyzing not just individual commands, but the order in which they are executed. Adversaries often follow a predictable pattern: download a tool, execute it to gather information (like firmware details), and then exfiltrate that data. A sequence-based model like an LSTM can learn normal command progressions and flag sequences with a high reconstruction error, indicating that the observed sequence does not fit the learned normal patterns and is therefore suspicious.
  answer_sources:
  - Windows Event ID 4688
  - Windows Event ID 4104
  - Domain Controllers
  - administrator workstations
  - virtualization hosts
  - critical application servers
  - endpoint devices
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      normal_sequences = GET_COMMAND_SEQUENCES('baseline_users_and_systems')
      model = TRAIN_LSTM_AUTOENCODER(normal_sequences)
      FOR each new_command_sequence:
        reconstruction_error = model.GET_ERROR(new_command_sequence)
        IF reconstruction_error > threshold:
          ALERT(severity=medium, reason='Anomalous command sequence detected')