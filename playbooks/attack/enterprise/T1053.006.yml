name: T1053.006: Systemd Timers
id: f47ac10b-58cc-4372-a567-0e02b2c3d479
description: This playbook helps investigate the malicious use of systemd timers for
  execution, persistence, and privilege escalation on Linux hosts. It focuses on
  detecting suspicious processes spawned by systemd (PPID 1), the creation or modification
  of malicious .timer and .service unit files, and subsequent actions like outbound
  network connections, execution from unusual locations, and modification of critical
  system files. Adversaries leverage systemd timers to schedule and run malicious
  code at specific times or intervals, often with elevated privileges.
type: technique
related:
- TA0002: Execution
- TA0003: Persistence
- TA0004: Privilege Escalation
contributors:
- Zachary Szewczyk
created: '2025-10-01'
modified: '2025-10-01'
version: 1.0
tags: none
investigative_questions:
- question: Is a process spawned by systemd (PPID 1) a known malicious indicator?
  context: Systemd-scheduled tasks run with a Parent Process ID (PPID) of 1. By comparing
    the executable hash and command-line arguments of these processes against threat
    intelligence feeds, analysts can quickly identify known malware or adversary
    tools being executed via this scheduling mechanism.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - Threat Intelligence Platform
  - All Linux servers and workstations, particularly those hosting critical services.
  range: last 90 days
  queries:
  - pseudocode: |
      SEARCH process_execution_logs WHERE parent_process_id == 1
      FOR_EACH event,
        COMPARE event.sha256_hash, event.command_line_args AGAINST threat_intelligence_feed
        IF match, ALERT
- question: Is a process spawned by systemd (PPID 1) statistically rare within the
    environment?
  context: Malicious executables are often rare compared to legitimate system binaries
    that are present on many hosts. Calculating the prevalence of a process's hash
    across the enterprise helps identify outliers. A process running on only a few
    systems, especially if spawned by systemd, is highly suspicious and warrants
    investigation.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - Threat Intelligence Platform
  - All Linux servers and workstations, particularly those hosting critical services.
  range: last 30 days
  queries:
  - pseudocode: |
      SEARCH process_execution_logs WHERE parent_process_id == 1
      GROUP_BY sha256_hash, CALCULATE prevalence_percentage
      IF prevalence_percentage < 1%, ALERT
- question: Does a machine learning model classify a process spawned by systemd (PPID
    1) as malicious?
  context: This question uses a supervised machine learning model trained on features
    of known benign and malicious processes. By scoring new systemd-spawned processes,
    analysts can detect novel or obfuscated threats that may not match known IOCs
    or simple rarity checks, providing a more advanced layer of detection.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - Threat Intelligence Platform
  - All Linux servers and workstations, particularly those hosting critical services.
  range: last 90 days
  queries:
  - pseudocode: |
      FOR_EACH process_event WHERE parent_process_id == 1,
        EXTRACT features (user, path, args, etc.)
        SCORE features with classification_model
        IF score > threshold, ALERT
- question: Is the 'systemd-run' utility being used to execute suspicious commands,
    like downloading and running remote scripts?
  context: Adversaries may use 'systemd-run' for one-off scheduled task execution.
    This is particularly suspicious when it's used to download and pipe a script directly
    to an interpreter (a "dropper" technique) or to decode a Base64 payload. This
    action directly looks for these high-confidence malicious patterns.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - Zeek conn.log
  - Zeek dns.log
  - All Linux endpoints, Network egress gateways, DNS resolvers.
  range: last 90 days
  queries:
  - pseudocode: |
      SEARCH process_execution_logs WHERE process_name == "systemd-run"
        AND command_line MATCHES REGEX ('curl .*\|.*sh', 'wget .*\|.*bash', 'base64 -d')
      CORRELATE with network_logs to verify remote host reputation
      IF confirmed, ALERT
- question: Is a user executing a 'systemd-run' command that is anomalous compared
    to their historical usage?
  context: Legitimate use of 'systemd-run' by a user often follows a pattern. By
    baselining this activity, analysts can detect deviations. An unusually long or
    structurally different command for a specific user can indicate that their account
    is compromised or being used for malicious purposes outside their normal duties.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - Zeek conn.log
  - Zeek dns.log
  - All Linux endpoints, Network egress gateways, DNS resolvers.
  range: last 90 days
  queries:
  - pseudocode: |
      FOR_EACH user,
        BUILD baseline of historical systemd-run command patterns/lengths
      FOR_EACH new systemd-run_event,
        CALCULATE similarity_score or length_deviation to user_baseline
        IF score is low OR deviation is high, ALERT
- question: Does a machine learning model flag a 'systemd-run' command line as anomalous
    based on its structure?
  context: An autoencoder model can learn the "normal" structure of benign 'systemd-run'
    commands. When a malicious command with an unusual structure is processed, the
    model will fail to reconstruct it accurately, resulting in a high reconstruction
error.
    This allows for the detection of novel attack patterns that don't match signatures.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - Zeek conn.log
  - Zeek dns.log
  - All Linux endpoints, Network egress gateways, DNS resolvers.
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN autoencoder_model on tokenized benign systemd-run commands
      FOR_EACH new systemd-run_event,
        CALCULATE reconstruction_error with model
        IF reconstruction_error > threshold, ALERT
- question: Is a process spawned by systemd (PPID 1) making a network connection
    to a known malicious IP or domain?
  context: A common action for malware or backdoors is to "call home" to a Command
    and Control (C2) server. By correlating processes started by systemd with network
    logs and checking destinations against C2 blocklists, analysts can directly identify
    compromised systems communicating with adversary infrastructure.
  answer_sources:
  - Linux audit.log (syscall=execve, syscall=connect)
  - Zeek conn.log
  - Zeek dns.log
  - Network egress gateways, DNS resolvers, All Linux endpoints.
  range: last 90 days
  queries:
  - pseudocode: |
      JOIN process_logs (ppid=1) with network_logs on pid
      FOR_EACH connection,
        CHECK destination_ip/domain AGAINST c2_blocklist
        IF match, ALERT
- question: Is a process spawned by systemd (PPID 1) making a network connection
    to a statistically rare destination or using a domain that appears to be algorithmically
    generated (DGA)?
  context: Beyond known-bad destinations, attackers may use new or unique domains.
    This question helps identify suspicious connections by flagging destinations
    that are rare across the enterprise. It also looks for high-entropy domain names,
    a common indicator of Domain Generation Algorithms (DGAs) used by malware to
    evade blocklists.
  answer_sources:
  - Linux audit.log (syscall=execve, syscall=connect)
  - Zeek conn.log
  - Zeek dns.log
  - Network egress gateways, DNS resolvers, All Linux endpoints.
  range: last 90 days
  queries:
  - pseudocode: |
      FOR_EACH systemd_process_connection,
        CALCULATE destination_prevalence_across_enterprise
        CALCULATE shannon_entropy of subdomain
        IF prevalence is low OR entropy is high, ALERT
- question: Is the network traffic volume from systemd-spawned processes on a host
    deviating from its predicted normal behavior?
  context: Malicious activity, such as data exfiltration or large payload downloads,
    can cause significant changes in network traffic patterns. A time-series model
    can predict the expected traffic volume for a host's systemd processes, and an
    alert on significant deviations can indicate a newly activated backdoor or other
    malicious behavior.
  answer_sources:
  - Linux audit.log (syscall=execve, syscall=connect)
  - Zeek conn.log
  - Zeek dns.log
  - Network egress gateways, DNS resolvers, All Linux endpoints.
  range: last 90 days
  queries:
  - pseudocode: |
      FOR_EACH host,
        MODEL time-series of network_volume from systemd_processes
        IF current_volume DEVIATES significantly from forecast, ALERT
- question: Is a process spawned by systemd (PPID 1) executing from a non-standard,
    world-writable directory?
  context: Legitimate system processes typically run from standard binary locations
    like /bin or /usr/bin. Adversaries often drop and execute payloads from world-writable
    directories like /tmp, /var/tmp, or /dev/shm because they are unlikely to require
    special permissions. This is a strong indicator of malicious activity.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - File systems on all Linux servers and workstations.
  range: last 90 days
  queries:
  - pseudocode: |
      SEARCH process_execution_logs WHERE parent_process_id == 1
        AND executable_path MATCHES REGEX '^/(tmp|var/tmp|dev/shm)/.*'
        ALERT on match
- question: Is a process spawned by systemd (PPID 1) executing from a path that is
    rare or has a high-entropy (random-looking) filename?
  context: Similar to rare hashes, rare execution paths can indicate a malicious
    binary. This analytic goes further by also checking the filename itself for high
    entropy (randomness), a common tactic used by attackers to evade simple signature-based
    detections by using randomized names.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - File systems on all Linux servers and workstations.
  range: last 90 days
  queries:
  - pseudocode: |
      FOR_EACH systemd_process_execution,
        CALCULATE path_prevalence_across_enterprise
        CALCULATE character_entropy of filename
        IF prevalence is low OR entropy is high, ALERT
- question: Does a clustering algorithm identify a systemd-spawned process (PPID
    1) as an outlier compared to normal activity?
  context: Clustering algorithms can group similar events together. By modeling features
    of systemd-spawned processes (path, user, command line), the algorithm can define
    "normal" clusters. Any process that doesn't fit into these clusters is flagged
    as a "noise point" or outlier, indicating it is anomalous and requires investigation.
  answer_sources:
  - Linux audit.log (syscall=execve)
  - File systems on all Linux servers and workstations.
  range: last 90 days
  queries:
  - pseudocode: |
      CLUSTER systemd_process_events using features (path, user, args)
      IDENTIFY outlier_events (noise points)
      ALERT on outliers
- question: Has a systemd .timer or .service file been created or modified that matches
    known malicious YARA rules?
  context: YARA rules are excellent for detecting known malicious patterns within
    files. By automatically scanning the content of newly created or modified systemd
    unit files, analysts can immediately identify attempts to install persistence
    using known malware families or attack tools.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Threat Intelligence Platform
  - Systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/,
    ~/.config/systemd/user/) on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write_event TO '*.timer' OR '*.service' IN systemd_dirs,
        SCAN file_content WITH yara_rules
        IF yara_match, ALERT
- question: Has a systemd .service file been created or modified with an anomalous
    content length or a rare 'ExecStart' path?
  context: Legitimate service files often have a predictable structure and length.
    A malicious service file, especially one with an embedded script, might be unusually
    long. Similarly, an 'ExecStart' directive pointing to a new or rarely used location
    is suspicious. This helps find unknown threats by flagging statistical outliers.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Threat Intelligence Platform
  - Systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/,
    ~/.config/systemd/user/) on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      BUILD baseline of service_file_length and ExecStart_path frequency
      ON file_write_event TO '*.service',
        IF file_length is outlier OR ExecStart_path is rare, ALERT
- question: Does a machine learning text classifier identify a newly created or modified
    systemd unit file as malicious?
  context: This applies machine learning to the entire content of a unit file. The
    model learns the textual characteristics that differentiate benign and malicious
    files, allowing it to detect novel or obfuscated malicious service definitions
    that might evade simpler rule-based or statistical methods.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Threat Intelligence Platform
  - Systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/,
    ~/.config/systemd/user/) on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN text_classifier on benign/malicious unit_files
      ON file_write_event TO unit_file,
        CLASSIFY file_content
        IF classified as 'malicious', ALERT
- question: Has a new systemd .service file been created that executes a program
    from a suspicious, high-risk location?
  context: This is a high-confidence detection rule. Adversaries frequently place
    their executables in world-writable directories like /tmp or /dev/shm, or in
    hidden directories, to be executed by a persistence mechanism. Alerting when
    a service's 'ExecStart' points to these locations is a direct way to find this
    behavior.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Systemd unit file directories and world-writable directories (/tmp, /dev/shm,
    /var/tmp) on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write_event TO '*.service',
        PARSE ExecStart_path from file
        IF ExecStart_path MATCHES REGEX ('^/(tmp|dev/shm|var/tmp)/.*', '/\..*'), ALERT
- question: Does a new systemd .service file specify an 'ExecStart' path in a directory
    that is rarely or never used for service executables?
  context: Legitimate services are typically installed in common, predictable directories.
    By tracking the frequency of the parent directories of all 'ExecStart' paths
    across the environment, we can identify when a new service points to an executable
    in an unusual location, which is a strong anomaly indicator.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Systemd unit file directories and world-writable directories (/tmp, /dev/shm,
    /var/tmp) on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      MAINTAIN frequency_map of ExecStart parent directories
      ON new '*.service' file,
        GET ExecStart_parent_dir
        IF frequency of parent_dir is in lowest 5th percentile, ALERT
- question: Does a graph-based anomaly detection model identify a suspicious relationship
    between a new service unit and its executable file properties?
  context: This advanced technique models the relationships between system components
    as a graph. An anomalous relationship, such as a new service unit node creating
    an edge to an executable path node that has the 'world-writable' property, would
    be flagged by the graph algorithm as a suspicious structure that warrants investigation.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Systemd unit file directories and world-writable directories (/tmp, /dev/shm,
    /var/tmp) on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      MODEL system entities (services, files, properties) as a graph
      USE graph_anomaly_detection to find unusual new nodes/edges
      ALERT on anomalous structures (e.g., service -> world_writable_exe)
- question: Is a systemd unit file being modified by an unexpected process, like
    a web server or an interactive shell?
  context: Systemd unit files are typically managed by package managers (yum, apt)
    or system administrators using tools like 'systemctl'. When a process like a
    web server (nginx, httpd) or an interactive shell (sshd) modifies a unit file,
    it's highly irregular and could indicate a web shell or a compromised user session
    being used to install persistence.
  answer_sources:
  - Linux audit.log (syscall=open, openat, execve)
  - Systemd unit file directories on all Linux hosts, especially web servers and
    multi-user systems.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write_event IN systemd_dirs,
        GET parent_process_name
        IF parent_process_name IN ('nginx', 'apache2', 'httpd', 'sshd', 'php-fpm'), ALERT
- question: Is a systemd unit file being modified by a process that has not historically
    done so on that host?
  context: This behavioral approach creates a baseline of normal activity on a per-host
    basis. By allow-listing the processes that normally modify unit files (like package
    managers), any modification from a process not on that list, or one that rarely
    performs this action, is flagged as a suspicious anomaly.
  answer_sources:
  - Linux audit.log (syscall=open, openat, execve)
  - Systemd unit file directories on all Linux hosts, especially web servers and
    multi-user systems.
  range: last 90 days
  queries:
  - pseudocode: |
      FOR_EACH host, BUILD allowlist of processes that modify unit_files
      ON file_write_event IN systemd_dirs,
        IF writing_process NOT IN host_allowlist, ALERT
- question: Does a machine learning model classify the event of a systemd unit file
    modification as an outlier?
  context: A One-Class SVM is an anomaly detection model that learns a boundary around
    "normal" data. By training it on features of legitimate modification events (e.g.,
    parent process name, user context), it can effectively identify any new modification
    event that falls outside this normal boundary, flagging it as a potential threat.
  answer_sources:
  - Linux audit.log (syscall=open, openat, execve)
  - Systemd unit file directories on all Linux hosts, especially web servers and
    multi-user systems.
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN OneClassSVM on features of legitimate unit_file modifications
      FOR_EACH new modification_event,
        CLASSIFY event with model
        IF classified as outlier, ALERT
- question: Has a user-level systemd timer or service been created for a system or
    service account?
  context: User-level systemd units are meant for interactive users (typically UID
    >= 1000). System or service accounts (UID < 1000) should not be creating user-level
    services. Such an event is highly anomalous and may indicate an attacker is abusing
    a service account to establish user-level persistence.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - User home directories, specifically `~/.config/systemd/user/` paths, on all multi-user
    Linux systems.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_creation IN '*/.config/systemd/user/*',
        GET user_id
        IF user_id < 1000, ALERT
- question: Has an interactive user created their first-ever user-level systemd timer
    or service file?
  context: While legitimate, many users never create their own systemd services.
    Alerting on the *first time* a user performs this action provides a valuable investigative
    starting point. It's a significant change in behavior that could be benign (e.g.,
    a developer learning a new feature) or malicious.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - User home directories, specifically `~/.config/systemd/user/` paths, on all multi-user
    Linux systems.
  range: last 90 days
  queries:
  - pseudocode: |
      TRACK users who have created user-level unit_files
      ON file_creation IN '*/.config/systemd/user/*',
        IF user has not created one before, ALERT
- question: Is a user creating a user-level systemd timer when other users with a
    similar role or profile are not?
  context: Peer group analysis helps to contextualize user behavior. For example,
    it's normal for a 'developer' group to create user services, but not for a 'finance'
    group. If a user performs an action that is abnormal for their peer group, it
    is a strong indicator of anomalous, and potentially malicious, activity.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - User home directories, specifically `~/.config/systemd/user/` paths, on all multi-user
    Linux systems.
  range: last 90 days
  queries:
  - pseudocode: |
      CLUSTER users into peer_groups based on activity
      ON user_creates_unit_file,
        IF this behavior is anomalous for user's peer_group, ALERT
- question: Has a privileged systemd service been created or modified to execute
    a known privilege escalation tool?
  context: This is a direct hunt for known privilege escalation techniques. When
    a service file running as root is modified, scanning its 'ExecStart' command
    for the names of common enumeration or exploit tools (like LinPEAS, pspy) provides
    a high-confidence alert that an attacker is attempting to elevate their privileges.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Threat Intelligence Platform
  - Privileged systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write to privileged '*.service' file,
        PARSE ExecStart command
        IF command CONTAINS ('pspy', 'linpeas.sh', 'dirtyc0w'), ALERT
- question: Does the command in a root-level service file contain rare command structures
    often used for malicious execution?
  context: Attackers often use shell interpreters ('bash -c', 'python -c') or other
    unusual argument combinations to execute code. By analyzing the frequency of
    command "n-grams" (short sequences of tokens), we can spot these rare and suspicious
    patterns that deviate from typical, simple 'ExecStart' directives.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Threat Intelligence Platform
  - Privileged systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      CALCULATE n-gram frequency for root-level ExecStart commands
      FOR new/modified service file,
        IF command contains low-frequency n-grams (e.g., 'bash -c', 'python -i'), ALERT
- question: Does a machine learning model, trained to recognize privilege escalation,
    classify a service file as malicious?
  context: This analytic uses a specialized ML model that focuses on the specific
    characteristics of service files used for privilege escalation, such as the absence
    of a 'User' directive combined with a specific command structure. This provides
    a more targeted and potentially more accurate detection than a general-purpose
    model.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Threat Intelligence Platform
  - Privileged systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN privesc_classifier on service file content features
      ON new/modified service file,
        CLASSIFY file content with model
        IF classified as 'privesc', ALERT
- question: Has a service file been created that will run as root by default and
    executes a file from a world-writable location?
  context: This is a classic and dangerous privilege escalation vector. An attacker
    with low-level access can write a malicious executable to /tmp, then create a
    systemd service to run it. If the service file doesn't specify a 'User', it runs
    as root. This rule looks for this exact combination of conditions, providing a
    very high-fidelity alert.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Privileged systemd unit directories and world-writable directories (/tmp, /dev/shm)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write to '/etc/systemd/system/*.service',
        IF ('User=' NOT IN file_content) AND
           (ExecStart path is in '/tmp/.*' or '/dev/shm/.*') AND
           (executable file is world-writable),
          ALERT
- question: Does a new privileged service file accumulate a high risk score based
    on suspicious attributes?
  context: Instead of a single binary rule, this approach assigns risk points for
    multiple suspicious characteristics (e.g., no 'User' specified, execution from
    /tmp, world-writable binary). A file with multiple risky attributes will cross
    a threshold and generate a higher-confidence alert, allowing for more nuanced
    detection.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Privileged systemd unit directories and world-writable directories (/tmp, /dev/shm)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON new/modified privileged service file,
        risk_score = 0
        IF 'User=' is absent, risk_score += 10
        IF ExecStart path is in /tmp, risk_score += 5
        IF executable is world-writable, risk_score += 10
        IF risk_score > 20, ALERT
- question: Does a decision tree model classify a new service file as following
    a known privilege escalation logic path?
  context: A decision tree is well-suited for modeling a series of logical conditions.
    By training it on boolean features (Is User= absent? Is path world-writable?),
    the model can learn the exact logical sequence that defines this attack technique,
    making it an efficient and interpretable way to detect it.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - File content from host
  - Privileged systemd unit directories and world-writable directories (/tmp, /dev/shm)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN decision_tree on boolean features of service files
      ON new service file,
        EVALUATE with decision_tree
        IF output is 'privesc', ALERT
- question: Is a non-root user or process creating or modifying a privileged, system-wide
    service file?
  context: System-wide services in directories like /etc/systemd/system/ should only
    be modified by the root user (euid 0). Any write to these directories by a process
    running with a different effective user ID is a major security violation and
    a direct indicator of a privilege escalation attempt, likely via a misconfiguration
    or vulnerability.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - Privileged systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write to '/etc/systemd/system/' OR '/usr/lib/systemd/system/',
        GET process_euid
        IF process_euid != 0, ALERT (CRITICAL)
- question: Has a write to a privileged systemd directory occurred from a process
    with a statistically impossible effective user ID (non-zero euid)?
  context: This reframes the previous rule-based detection from a statistical perspective.
    Since all legitimate modifications should come from euid 0, any event with a
    non-zero euid is a zero-frequency event, making it the highest possible statistical
    anomaly. This validates the symbolic rule and can be used to augment host or
    user risk scores.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - Privileged systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      ON file_write to privileged systemd_dirs,
        IF process_euid != 0, IDENTIFY as maximum statistical anomaly
        ALERT and increase host_risk_score
- question: Does an anomaly detection model flag the modification of a privileged
    systemd file by a non-root user as a significant outlier?
  context: An Isolation Forest model is designed to find outliers. By training it
    on normal system activity, it will learn that writes to privileged systemd directories
    are always associated with an euid of 0. An event that violates this learned association
    will be easily "isolated" by the model and flagged as a high-confidence anomaly.
  answer_sources:
  - Linux audit.log (syscall=open, openat)
  - Privileged systemd unit file directories (/etc/systemd/system/, /usr/lib/systemd/system/)
    on all Linux hosts.
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN IsolationForest on features (euid, target_path, process_name)
      FOR new file_write events,
        SCORE with model
        IF score indicates anomaly, ALERT
- question: Has a process started by a systemd timer with root privileges modified
    a critical system file like /etc/passwd or /etc/sudoers?
  context: This looks for the *impact* of a successful privilege escalation. If an
    attacker has managed to get a root service running, they might use it to create
    a new user, change a password, or grant themselves sudo rights. This analytic
    directly monitors for this post-exploitation behavior.
  answer_sources:
  - Linux audit.log (syscall=execve, syscall=open, openat)
  - All Linux hosts, focusing on directories containing critical authentication and
    configuration files (e.g., /etc/, /etc/sudoers.d/).
  range: last 90 days
  queries:
  - pseudocode: |
      FIND process P where ppid=1 and euid=0
      LOOK for subsequent file_write by P.pid
      IF file_write.target IN ('/etc/passwd', '/etc/shadow', '/etc/sudoers.d/*'), ALERT
- question: Is a critical system file being modified by a systemd-spawned root process
    that is not a known, legitimate administrative tool?
  context: Critical files like /etc/passwd are normally modified only by specific
    utilities (e.g., 'useradd', 'passwd'). This analytic baselines these legitimate
    processes. If a systemd-spawned root process modifies one of these files and
    its name is not on the baseline, it's a strong sign of malicious tampering.
  answer_sources:
  - Linux audit.log (syscall=execve, syscall=open, openat)
  - All Linux hosts, focusing on directories containing critical authentication and
    configuration files (e.g., /etc/, /etc/sudoers.d/).
  range: last 90 days
  queries:
  - pseudocode: |
      BUILD allowlist of processes that modify critical_files (e.g., 'useradd')
      ON critical_file_modification by process P (ppid=1),
        IF P.name NOT IN allowlist, ALERT
- question: Does a sequence analysis model detect an anomalous chain of events starting
    with a timer and ending with a critical file modification?
  context: This advanced analytic looks at the entire attack chain as a single sequence.
    A model can be trained on legitimate administrative sequences. An anomalous sequence,
    like a web server writing a timer file which then spawns a process that edits
    /etc/sudoers, would be flagged as a deviation from learned normal behavior.
  answer_sources:
  - Linux audit.log (syscall=execve, syscall=open, openat)
  - All Linux hosts, focusing on directories containing critical authentication and
    configuration files (e.g., /etc/, /etc/sudoers.d/).
  range: last 90 days
  queries:
  - pseudocode: |
      TRAIN sequence_model on legitimate admin workflows
      FEED new event sequences (timer_create -> service_exec -> file_mod)
      IF model flags sequence as anomalous, ALERT