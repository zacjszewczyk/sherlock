name: T1562.003: Impair Command History Logging
id: b7a2d1f0-a8e1-4b2d-9c3f-7e6d5a4b3c2d
description: This playbook focuses on detecting adversary attempts to impair or disable command history logging on endpoints and servers. This evasion technique involves several methods, such as using specific tools to clear history, executing commands to disable logging for a session, manipulating history files directly by deleting or truncating them, or using these techniques in anomalous contexts or as part of a broader attack sequence. The goal is to identify these activities to prevent adversaries from covering their tracks.
type: technique
related:
  - TA0005: Defense Evasion
contributors:
  - Zachary Szewczyk
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Are processes being created that are known tools for impairing command history, based on file hash or script block content?
    context: This question aims to detect the use of specific, known malicious tools designed to clear or disable shell history. By continuously monitoring process creation events and comparing file hashes against a threat intelligence feed, we can identify the initial execution of these evasion tools with high confidence, providing an early warning of an adversary's attempt to cover their tracks.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - osquery process_events
      - SIEM/EDR log repository aggregating process execution data from all Windows, Linux, and macOS endpoints and servers, correlated with a Threat Intelligence Platform.
    range: last 90 days
    queries:
      - pseudocode: SEARCH process_creation_events | WHERE (process_hash IN threat_intel_feed OR script_block_hash IN threat_intel_feed)
  - question: Are any rarely seen processes executing that are also known for impairing command history?
    context: This question identifies history-impairment tools that might not be caught by simple blocklists if they are new or modified. By calculating the prevalence of each executed file across the enterprise, we can flag tools that are not part of standard software deployments. A low prevalence (e.g., running on less than 1% of hosts) for a tool known to be used for evasion is a strong indicator of targeted malicious activity rather than widespread administrative action.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - osquery process_events
      - SIEM/EDR log repository aggregating process execution data from all Windows, Linux, and macOS endpoints and servers, correlated with a Threat Intelligence Platform.
    range: last 90 days
    queries:
      - pseudocode: SEARCH process_creation_events | CALCULATE prevalence by host | WHERE process_hash IN history_impairment_signatures AND prevalence < 0.01
  - question: Can we use machine learning to identify processes that behave like command history impairment tools, even if they are unknown?
    context: This question seeks to build a predictive model to identify potentially malicious processes based on their characteristics, rather than just their signature. By training a classifier on features like process name entropy, argument count, parent process, and user context, the model can learn to spot anomalous executions that fit the profile of an evasion tool, providing a more resilient detection method against novel threats.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - osquery process_events
      - SIEM/EDR log repository aggregating process execution data from all Windows, Linux, and macOS endpoints and servers, correlated with a Threat Intelligence Platform.
    range: last 90 days
    queries:
      - pseudocode: INPUT process_events_with_features | PREDICT is_evasive_tool USING trained_ml_model | WHERE prediction == true
  - question: Are any command lines or scripts being executed that contain specific keywords or patterns known to disable, clear, or manipulate shell history?
    context: This question focuses on detecting the direct commands used to impair history logging. Adversaries often use built-in shell commands or options (e.g., `Set-PSReadLineOption -HistorySaveStyle SaveNothing`, `unset HISTFILE`, `history -c`) to achieve their goal. Scanning command-line arguments and script block content for these specific patterns provides a direct and high-fidelity method for detecting this evasion technique.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - osquery shell_history
      - Syslog from network devices
      - SIEM platform aggregating command-line logs from all enterprise endpoints, servers, and network devices with command logging capabilities.
    range: last 90 days
    queries:
      - pseudocode: SEARCH command_line_logs, script_block_logs | WHERE command_line MATCHES regex_pattern_for_history_impairment
  - question: Is any user executing history-impairing commands at a statistically unusual rate?
    context: This question helps differentiate between rare, legitimate administrative use and a concerted effort by an adversary to cover their tracks. By establishing a baseline of how often a user typically runs these sensitive commands, we can use a Poisson distribution model to detect a statistically significant spike in activity. Such a spike suggests an abnormal, and therefore suspicious, increase in history manipulation.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - osquery shell_history
      - Syslog from network devices
      - SIEM platform aggregating command-line logs from all enterprise endpoints, servers, and network devices with command logging capabilities.
    range: last 90 days
    queries:
      - pseudocode: SEARCH command_line_logs | FILTER command_line MATCHES history_impairment_pattern | STATS count by user, day | COMPARE to baseline using Poisson distribution | WHERE p_value < 0.01
  - question: Can we use a language model to detect obfuscated or novel commands intended to impair shell history?
    context: This question addresses the challenge of adversaries using obfuscation (like string concatenation or environment variables) to bypass simple regex-based detection. By fine-tuning a pre-trained language model on shell commands, we can identify commands that are semantically similar to known evasion techniques, even if their syntax is completely different. This provides a more robust defense against advanced obfuscation.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - osquery shell_history
      - Syslog from network devices
      - SIEM platform aggregating command-line logs from all enterprise endpoints, servers, and network devices with command logging capabilities.
    range: last 90 days
    queries:
      - pseudocode: INPUT command_line_text | PREDICT is_evasive_command USING fine_tuned_BERT_model | WHERE prediction == true
  - question: Are history impairment commands being executed in a suspicious context, such as by a service account, from a non-standard parent process, or immediately after a remote login from a new location?
    context: This question adds context to the execution of a history impairment command to reduce false positives and increase confidence in alerts. A legitimate administrator might clear history, but it's highly unusual for a web server's service account to do so, or for it to happen from a parent process like Microsoft Word. Correlating the command with other suspicious events, like a login from a new country, creates a high-fidelity indicator of compromise.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4624
      - Zeek conn.log
      - osquery logged_in_users
      - Linux auditd logs
      - SIEM platform capable of correlating authentication logs (Windows, Zeek), process logs (Windows, Linux), and IP geolocation enrichment data.
    range: last 90 days
    queries:
      - pseudocode: CORRELATE command_line_events with auth_events | WHERE command_line MATCHES history_impairment_pattern AND (parent_process NOT IN allowlist OR (event_time - login_time < 5m AND login_country NOT IN user_historical_countries))
  - question: Are user sessions that contain a history impairment command also exhibiting an unusually high degree of command randomness or variety?
    context: This question seeks to identify sessions where an adversary is exploring a system after disabling history. A typical user session has a certain pattern and predictability. By measuring the Shannon entropy of commands executed shortly after logging in, we can spot sessions that are unusually chaotic or varied. When this high entropy is combined with a history clearing command, it strongly suggests an attacker performing reconnaissance.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4624
      - Zeek conn.log
      - osquery logged_in_users
      - Linux auditd logs
      - SIEM platform capable of correlating authentication logs (Windows, Zeek), process logs (Windows, Linux), and IP geolocation enrichment data.
    range: last 90 days
    queries:
      - pseudocode: GROUP commands by user_session | WITHIN first 10 minutes, CALCULATE Shannon_entropy of commands | WHERE history_impairment_command exists AND entropy > 95th_percentile for user
  - question: Can a time-series model detect anomalous user session activity that coincides with a history impairment command?
    context: This question proposes building a model of normal user session behavior over time. An LSTM autoencoder can learn the typical sequences of processes, network connections, and file modifications for a user. When an adversary takes over, their actions will deviate from this learned norm, causing a high 'reconstruction error' in the model. If this error spike occurs right after a history impairment command, it's a strong signal of malicious activity.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4624
      - Zeek conn.log
      - osquery logged_in_users
      - Linux auditd logs
      - SIEM platform capable of correlating authentication logs (Windows, Zeek), process logs (Windows, Linux), and IP geolocation enrichment data.
    range: last 90 days
    queries:
      - pseudocode: INPUT user_session_time_series_data | PREDICT reconstruction_error using LSTM_autoencoder | WHERE error > threshold AND history_impairment_command occurred recently
  - question: Are history impairment commands being followed by known discovery, credential access, or execution commands within the same user session?
    context: This question looks for a logical attack chain. Adversaries often clear history *before* running noisy reconnaissance or execution commands to hide their subsequent actions. This stateful detection rule specifically looks for this sequence: (1) history impairment, followed by (2) commands like `whoami`, `net user`, `psexec`, etc. This temporal correlation provides strong evidence of malicious intent.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - Critical servers (Domain Controllers, file servers), administrator workstations, and developer endpoints.
    range: last 90 days
    queries:
      - pseudocode: TRACK user_sessions by logon_id | IF history_impairment_command seen, SET state=suspicious for 1hr | IF state==suspicious AND subsequent_command IN (recon_watchlist, cred_access_watchlist, exec_watchlist), THEN ALERT
  - question: Are we observing rare sequences of ATT&CK techniques that begin with history impairment?
    context: This question abstracts individual commands into their corresponding MITRE ATT&CK techniques to find suspicious behavioral patterns. While any single technique might be benign, certain sequences are highly indicative of an attack. By calculating the probability of all three-technique sequences (trigrams) across the organization, we can flag those that start with history impairment (T1562.003) and are extremely rare, pointing to a novel or unusual attack path.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - Critical servers (Domain Controllers, file servers), administrator workstations, and developer endpoints.
    range: last 90 days
    queries:
      - pseudocode: MAP commands to MITRE_technique_IDs | CREATE trigrams of techniques per session | CALCULATE probability of each trigram | WHERE trigram starts with T1562.003 AND probability < 0.0005
  - question: Can a sequence model predict when a user's command sequence deviates from normal behavior immediately after a history impairment command is executed?
    context: This question uses a predictive model to establish a baseline of normal command progressions for different user roles. A Seq2Seq model can learn, for example, that a developer after `git pull` often runs `mvn clean install`. If the model observes a history impairment command and then the user's *actual* next commands (e.g., `net user`) are completely different from what the model *predicted*, this deviation is a strong anomaly signal.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - Linux auditd logs (type=EXECVE)
      - Critical servers (Domain Controllers, file servers), administrator workstations, and developer endpoints.
    range: last 90 days
    queries:
      - pseudocode: INPUT live_command_sequence | PREDICT next_expected_command using Seq2Seq_model | IF history_impairment_command observed AND actual_next_command != predicted_next_command, THEN ALERT
  - question: Are default shell history files (e.g., .bash_history) being deleted, truncated, or symbolically linked to /dev/null?
    context: This question focuses on direct manipulation of the history files themselves, a common and straightforward evasion method. By using File Integrity Monitoring (FIM) or native OS auditing (like auditd) to watch for specific destructive actions (delete, truncate, symlink) on these critical files, we can generate high-confidence alerts for blatant attempts to erase command history.
    answer_sources:
      - Windows Event ID 4663
      - Windows Event ID 4688
      - Linux auditd logs (type=SYSCALL, syscall=unlink,truncate,symlink)
      - osquery file_events
      - File Integrity Monitoring (FIM) system and SIEM, monitoring user profile directories (~, %APPDATA%) on all endpoints and servers.
    range: last 90 days
    queries:
      - pseudocode: SEARCH file_integrity_events | WHERE file_path IN history_file_list AND (event_type == 'delete' OR event_type == 'truncate' OR (event_type == 'symlink' AND target == '/dev/null'))
  - question: Is a user's shell history file failing to update despite them actively executing commands?
    context: This question detects a more subtle form of history impairment where logging might be disabled in memory without directly modifying the file. By correlating active command execution with the history file's metadata (last modified time, size), we can spot a logical inconsistency. If a user is running commands but the history file isn't changing, it's a strong statistical anomaly indicating that logging has been disabled for the current session.
    answer_sources:
      - Windows Event ID 4663
      - Windows Event ID 4688
      - Linux auditd logs (type=SYSCALL, syscall=unlink,truncate,symlink)
      - osquery file_events
      - File Integrity Monitoring (FIM) system and SIEM, monitoring user profile directories (~, %APPDATA%) on all endpoints and servers.
    range: last 90 days
    queries:
      - pseudocode: CORRELATE process_events with file_metadata | FOR each active user, IF command_count_last_15m > 5 AND history_file_modified_time is static, THEN ALERT
  - question: Can a time-series model forecast the expected size of a shell history file and detect anomalous deviations, such as a sudden drop to zero?
    context: This question proposes building a predictive model for the growth of each user's history file. An ARIMA model can learn the normal rate of file growth based on past activity and current command volume. An anomaly is flagged when the actual file size deviates significantly from the forecastâ€”for example, if it suddenly drops to zero or stops growing during an active session. This approach can catch manipulation that other methods might miss.
    answer_sources:
      - Windows Event ID 4663
      - Windows Event ID 4688
      - Linux auditd logs (type=SYSCALL, syscall=unlink,truncate,symlink)
      - osquery file_events
      - File Integrity Monitoring (FIM) system and SIEM, monitoring user profile directories (~, %APPDATA%) on all endpoints and servers.
    range: last 90 days
    queries:
      - pseudocode: INPUT history_file_size_time_series | PREDICT expected_size using ARIMA_model | IF actual_size deviates significantly from prediction_confidence_interval, THEN ALERT