name: "T1027.009: Embedded Payloads"
id: "a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d"
description: "This playbook helps investigate whether an adversary is evading defenses by embedding malicious payloads within non-executable or seemingly benign executable files. This involves analyzing files for malicious signatures, anomalous structural properties like high entropy or large overlays, and suspicious behavior such as process injection from non-standard sources or the execution of files with masqueraded extensions. It also covers the detection of obfuscated PowerShell scripts that decode and execute embedded payloads in memory."
type: "technique"
related:
  - "TA0005: Defense Evasion"
contributors:
  - "Zachary Szewczyk"
  - "Ask Sage"
created: "2025-10-01"
modified: "2025-10-01"
version: "1.0"
tags: "none"
questions:
  - question: "Are file hashes from process creation events or network logs matching known malicious signatures, or are PE section names indicative of known packers?"
    context: "This question aims to identify known malicious files using signature-based detection. By querying for file hashes from network traffic (Zeek files.log) and endpoint process creation events (Windows Event ID 4688) and comparing them against a threat intelligence feed, analysts can quickly spot known droppers, loaders, or packed malware. Additionally, searching for PE section names that match patterns of known packers (e.g., 'UPX', 'FSG!') in Zeek pe.log helps identify common evasion techniques."
    answer_sources:
      - "Zeek files.log"
      - "Zeek pe.log"
      - "Windows Event ID 4688"
      - "Internet Gateway Firewalls"
      - "Web Proxies"
      - "Email Gateways"
      - "User Workstations"
      - "File Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Query for file hashes from logs
          file_hashes = search(Zeek:files.log, WinEvent:4688).pluck('hash')
          // Compare against TI feed
          malicious_hashes = threat_intel_feed.match(file_hashes, tags=['dropper', 'loader', 'packed'])
          // Query for PE section names matching packer signatures
          packed_files = search(Zeek:pe.log).where('section_name').matches_regex('UPX[0-9]|FSG!|.aspack')
          // Alert on findings
          alert_on(malicious_hashes, packed_files)"
  - question: "Are any Portable Executable (PE) files exhibiting unusually high entropy in their sections compared to a baseline of legitimate software?"
    context: "High entropy in a file section often indicates the presence of packed or encrypted data, a common technique for hiding malicious payloads. This question involves calculating the Shannon entropy for each executable section of PE files observed in Zeek pe.log. By establishing a baseline entropy distribution for legitimate executables in the environment, analysts can flag any file where a section's entropy is a statistical outlier (e.g., exceeds the 99th percentile), pointing to potential obfuscation."
    answer_sources:
      - "Zeek pe.log"
      - "Internet Gateway Firewalls"
      - "Web Proxies"
      - "Email Gateways"
      - "User Workstations"
      - "File Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // For each PE file in Zeek pe.log
          foreach file in search(Zeek:pe.log):
            // Calculate entropy for each section
            entropies = calculate_shannon_entropy(file.sections)
            // Compare against baseline
            if any(entropies) > baseline.entropy_99th_percentile:
              alert('High entropy PE file detected', file)"
  - question: "Can a machine learning model identify PE files that are likely to contain an embedded payload based on their structural features?"
    context: "This question leverages machine learning to detect novel or unknown threats that signature-based methods might miss. By training a classifier (e.g., logistic regression) on labeled PE file features (section count, names, entropy, import table, etc.) from Zeek pe.log, a predictive model can be created. This model can then score new, unseen files for their probability of containing an embedded payload, generating alerts for high-probability files."
    answer_sources:
      - "Zeek pe.log"
      - "Internet Gateway Firewalls"
      - "Web Proxies"
      - "Email Gateways"
      - "User Workstations"
      - "File Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Continuously process new PE files
          foreach file in stream(Zeek:pe.log):
            // Extract features
            features = extract_pe_features(file)
            // Get prediction from ML model
            probability = ml_model.predict_proba(features)
            // Alert if probability is high
            if probability > 0.9:
              alert('High probability of embedded payload detected', file)"
  - question: "Are any PE files being observed with an unusually large overlay size, potentially indicating an appended payload?"
    context: "An overlay is data appended to the end of a PE file, outside of its defined structure. Adversaries often use large overlays to store malicious payloads. This question focuses on detecting PE files where the overlay is anomalously large, either by exceeding a fixed threshold (e.g., 500KB) or by being larger than the PE structure itself. This is often correlated with a low number of imported functions, as packed executables resolve imports dynamically."
    answer_sources:
      - "Zeek pe.log"
      - "Zeek files.log"
      - "Windows Event ID 11 (Sysmon)"
      - "Internet Gateway Firewalls"
      - "Web Proxies"
      - "Email Gateways"
      - "Endpoint temporary directories"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Join Zeek logs to get total size and PE info
          foreach file in join(Zeek:files.log, Zeek:pe.log):
            // Calculate overlay size
            overlay_size = file.total_bytes - file.pe_structure_size
            // Check against thresholds
            if overlay_size > 500KB or overlay_size > file.pe_structure_size:
              alert('Anomalously large PE overlay detected', file)"
  - question: "Do any PE files show a statistically anomalous ratio of overlay size to total file size, or have an unusually high number of sections compared to a baseline?"
    context: "This question uses statistical analysis to identify abnormally structured PE files. By calculating the ratio of overlay size to total file size and the count of PE sections for all observed files, a baseline for legitimate software can be established. Alerts are then generated for files where these metrics are statistical outliers (e.g., overlay ratio > 95th percentile, section count > 2 standard deviations above the mean), as these are common characteristics of packed or modified malware."
    answer_sources:
      - "Zeek pe.log"
      - "Internet Gateway Firewalls"
      - "Web Proxies"
      - "Email Gateways"
      - "Endpoint temporary directories"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // For each PE file in Zeek pe.log
          foreach file in search(Zeek:pe.log):
            // Calculate metrics
            overlay_ratio = file.overlay_size / file.total_size
            section_count = count(file.sections)
            // Compare against statistical baseline
            if overlay_ratio > baseline.ratio_95th_percentile or section_count > baseline.section_count_mean + (2 * baseline.section_count_stddev):
              alert('Statistically anomalous PE structure detected', file)"
  - question: "Can an unsupervised machine learning model detect anomalous PE files based on structural features like section count, entropy, and overlay size?"
    context: "This question applies unsupervised machine learning (e.g., Isolation Forest) to find outlier PE files without relying on pre-labeled data. The model is trained on a large corpus of network traffic to learn the characteristics of 'normal' PE files based on a feature set including section count, entropy, and overlay size ratio. It can then flag files that the model identifies as strong outliers, representing potentially malicious files that might otherwise evade detection."
    answer_sources:
      - "Zeek pe.log"
      - "Internet Gateway Firewalls"
      - "Web Proxies"
      - "Email Gateways"
      - "Endpoint temporary directories"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Continuously process new PE files
          foreach file in stream(Zeek:pe.log):
            // Extract features
            features = extract_pe_features(file)
            // Get anomaly score from unsupervised model
            anomaly_score = unsupervised_model.predict(features)
            // Alert if identified as an outlier
            if anomaly_score == -1: // -1 often indicates an anomaly
              alert('Anomalous PE file detected by ML model', file)"
  - question: "Are PowerShell script logs showing the co-occurrence of in-memory execution functions with large, Base64-encoded text blocks?"
    context: "This question targets a common PowerShell-based attack where a malicious payload is encoded (often in Base64) to evade static analysis, then decoded and executed directly in memory. The query searches PowerShell script block logs (Event ID 4104) for the simultaneous presence of keywords associated with decoding (`FromBase64String`) and execution (`Invoke-Expression`, `IEX`) alongside large blocks of encoded text (e.g., > 256 bytes)."
    answer_sources:
      - "Windows Event ID 4104"
      - "Windows Event ID 4103"
      - "User Workstations"
      - "Application Servers"
      - "Domain Controllers"
      - "Exchange Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Search PowerShell logs
          search(WinEvent:4104).where('ScriptBlockText').contains(['FromBase64String', 'Invoke-Expression', 'IEX'])
          .and('ScriptBlockText').matches_regex('[A-Za-z0-9+/=]{256,}')
          .alert('Potential in-memory PowerShell execution detected')"
  - question: "Are any PowerShell scripts exhibiting statistically high entropy or an unusual character distribution compared to a baseline of benign scripts?"
    context: "Legitimate administrative scripts usually have a predictable structure and character set, while obfuscated or encrypted malicious scripts often have high entropy and a different character frequency. This statistical approach involves establishing a baseline for these metrics from known-good scripts in the environment. Any new script from Event ID 4104 with an entropy score or character distribution that is a significant statistical outlier is flagged as suspicious."
    answer_sources:
      - "Windows Event ID 4104"
      - "User Workstations"
      - "Application Servers"
      - "Domain Controllers"
      - "Exchange Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // For each new PowerShell script log
          foreach script in stream(WinEvent:4104):
            // Calculate metrics
            entropy = calculate_shannon_entropy(script.ScriptBlockText)
            // Compare to baseline
            if entropy > baseline.powershell_entropy_98th_percentile:
              alert('High entropy PowerShell script detected', script)"
  - question: "Can a machine learning text classifier distinguish between malicious and benign PowerShell scripts based on their content?"
    context: "This question proposes using a supervised machine learning model (e.g., Naive Bayes) to automate the classification of PowerShell scripts. The model is trained on a labeled dataset of malicious and benign scripts, using features like keyword frequency (n-grams), API call mentions, entropy, and string length. Once deployed, it can classify incoming script blocks from Event ID 4104 in near real-time, providing a scalable way to identify malicious activity."
    answer_sources:
      - "Windows Event ID 4104"
      - "User Workstations"
      - "Application Servers"
      - "Domain Controllers"
      - "Exchange Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // For each new PowerShell script log
          foreach script in stream(WinEvent:4104):
            // Extract features and classify
            features = extract_ps_features(script.ScriptBlockText)
            prediction = ps_classifier_model.predict(features)
            // Alert if classified as malicious
            if prediction == 'malicious':
              alert('Malicious PowerShell script classified by ML model', script)"
  - question: "Is a common productivity application injecting code into a legitimate system process, especially without a known start module?"
    context: "This question looks for classic process injection, a technique where malware injects its code into the memory space of another process to hide. The query focuses on Sysmon Event ID 8 (CreateRemoteThread) where the source process is a common application (e.g., WINWORD.EXE, CHROME.EXE) and the target is a system process (e.g., svchost.exe). A null or non-standard value in the `StartModule` field is a strong indicator that the injected code is shellcode rather than a legitimate DLL."
    answer_sources:
      - "Windows Event ID 8 (Sysmon)"
      - "Windows Event ID 10 (Sysmon)"
      - "Windows Event ID 4688"
      - "User Workstations"
      - "Critical Servers"
      - "Terminal Servers"
      - "Domain Controllers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Search for process injection events
          search(Sysmon:8)
          .where('SourceImage').in(['WINWORD.EXE', 'CHROME.EXE', 'ACRORD32.EXE'])
          .and('TargetImage').in(['svchost.exe', 'explorer.exe', 'rundll32.exe'])
          .and('StartModule').is_null()
          .alert('Suspicious process injection detected')"
  - question: "Are there any statistically rare or previously unseen process injection pairs (source process -> target process) occurring in the environment?"
    context: "Since some process injection is legitimate (e.g., by security software), this approach focuses on finding the unknown. By analyzing the frequency of all source-target process injection pairs from Sysmon Event ID 8 across the enterprise, a baseline of normal activity is established. Any injection pairs that are statistically rare (e.g., occurring fewer than 5 times in 90 days) or have never been seen before are flagged as highly suspicious and warrant investigation."
    answer_sources:
      - "Windows Event ID 8 (Sysmon)"
      - "User Workstations"
      - "Critical Servers"
      - "Terminal Servers"
      - "Domain Controllers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Count all injection pairs over the last 90 days
          injection_pairs = search(Sysmon:8, time='-90d').count_by(['SourceImage', 'TargetImage'])
          // Find pairs with low counts
          rare_pairs = injection_pairs.where('count').is_less_than(5)
          // Alert on rare pairs
          alert('Statistically rare process injection pair detected', rare_pairs)"
  - question: "Can a graph-based machine learning model detect anomalous process injection events by analyzing process interaction patterns?"
    context: "This question uses a more advanced approach by modeling process relationships as a graph, where processes are nodes and injections (Sysmon Event ID 8) are directed edges. By training a model on benign activity, it learns the normal process interaction graph structure. A new, anomalous edge (an injection) that deviates from these learned structural patterns, such as a browser process injecting into a kernel-level process, can be flagged as a high-fidelity alert."
    answer_sources:
      - "Windows Event ID 8 (Sysmon)"
      - "User Workstations"
      - "Critical Servers"
      - "Terminal Servers"
      - "Domain Controllers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Continuously update process graph with Sysmon events
          foreach event in stream(Sysmon:8):
            graph.add_edge(event.SourceImage, event.TargetImage)
            // Use ML model to check if the new edge is an anomaly
            is_anomaly = graph_model.predict(graph)
            if is_anomaly:
              alert('Anomalous process injection detected by graph ML model', event)"
  - question: "Is an executable file, disguised with a non-executable extension (e.g., .jpg, .txt), being downloaded and then executed shortly after?"
    context: "This question targets file masquerading, where an adversary renames a malicious executable to evade simple extension-based filters. The query correlates network file transfer logs (Zeek files.log) with endpoint process creation logs (Windows Event ID 4688). It triggers an alert when a file transferred with an executable MIME type (e.g., 'application/x-dosexec') but saved with a non-executable extension (e.g., .jpg, .txt) is executed on an endpoint within a short time window."
    answer_sources:
      - "Windows Event ID 4688"
      - "Zeek files.log"
      - "Zeek conn.log"
      - "User Workstations"
      - "Web Proxies"
      - "Email Gateways"
      - "Network Egress Points"
      - "File Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Join network and endpoint logs
          network_events = search(Zeek:files.log).where('mime_type') == 'application/x-dosexec' and 'filename'.ends_with('.jpg', '.txt', '.pdf')
          process_events = search(WinEvent:4688)
          // Correlate on filename/hash within a 5-minute window
          correlated_events = correlate(network_events, process_events, key='filename', window='5m')
          alert('Masqueraded file execution detected', correlated_events)"
  - question: "Are processes being created from files with statistically rare or uncommon file extensions?"
    context: "Most legitimate processes are created from a predictable set of file extensions (e.g., .exe, .com, .bat). This statistical approach performs frequency analysis on the file extensions of all executed processes recorded in Event ID 4688 logs. By maintaining a dynamic list of the most common executable extensions (e.g., the top 95%), the query can alert whenever a process is created from a file with an extension that falls outside this common set, as this represents a statistical rarity."
    answer_sources:
      - "Windows Event ID 4688"
      - "User Workstations"
      - "Web Proxies"
      - "Email Gateways"
      - "Network Egress Points"
      - "File Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Get list of common executable extensions from baseline
          common_extensions = baseline.get_common_extensions(percentile=95)
          // Search for process creation events with rare extensions
          rare_executions = search(WinEvent:4688).where_not('ProcessName'.ends_with(common_extensions))
          alert('Process created from file with rare extension', rare_executions)"
  - question: "Can a time-series model detect an anomalous spike in the execution of a typically non-executed file type?"
    context: "This question uses a time-series anomaly detection model (e.g., ARIMA) to monitor the execution frequency of various file types over time. A sudden, coordinated attack might involve the execution of a file type that is normally dormant (e.g., .iso, .img, .dat). The model is trained on historical data to learn the normal temporal baseline for each extension and will flag any significant, sudden spike in executions as a potential coordinated attack."
    answer_sources:
      - "Windows Event ID 4688"
      - "User Workstations"
      - "Web Proxies"
      - "Email Gateways"
      - "Network Egress Points"
      - "File Servers"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // For each file extension, get execution counts over time
          timeseries_data = search(WinEvent:4688).time_series('count', '1h', by='extension')
          // Feed data into time-series model
          anomalies = timeseries_model.find_anomalies(timeseries_data)
          if anomalies:
            alert('Anomalous spike in execution frequency for extension', anomalies)"
  - question: "Is a non-installer process (like a web browser or office application) creating and then immediately executing a new executable file?"
    context: "This question targets the 'drop and execute' behavior common in malware delivery from phishing or drive-by downloads. It correlates a file creation event (Sysmon ID 11) with a process creation event (Windows ID 4688) for the exact same file path, occurring within a very short window (e.g., < 60 seconds). The rule critically filters out legitimate parent processes (like 'setup.exe' or 'msiexec.exe') to focus on suspicious activity originating from non-installer applications."
    answer_sources:
      - "Windows Event ID 4688"
      - "Windows Event ID 11 (Sysmon)"
      - "User Workstations"
      - "Application Servers"
      - "Temporary File Directories (%TEMP%, %APPDATA%)"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Correlate file create and process create events
          correlated = correlate(Sysmon:11, WinEvent:4688, key='FilePath', window='1m')
          .where('event1.ProcessGuid == event2.ParentProcessGuid')
          .and_not('event2.ParentProcessName').in(installer_allowlist)
          alert('Suspicious drop-and-execute behavior detected', correlated)"
  - question: "Are there any 'file create -> process create' sequences with an unusually short time delay, initiated by a non-standard parent process?"
    context: "This statistical approach quantifies the 'immediacy' of drop-and-execute behavior. For all observed sequences where a parent process creates a file and then executes it, the time delta between the two events is calculated. By establishing a baseline distribution of these deltas, analysts can flag sequences that fall in the lowest percentile (indicating automated, immediate execution) when the parent process is not a known installer or trusted system process."
    answer_sources:
      - "Windows Event ID 4688"
      - "Windows Event ID 11 (Sysmon)"
      - "User Workstations"
      - "Application Servers"
      - "Temporary File Directories (%TEMP%, %APPDATA%)"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // Find create -> execute sequences
          sequences = correlate(Sysmon:11, WinEvent:4688, key='FilePath', window='5m')
          // Calculate time delta for each
          sequences.calculate('delta', 'event2.timestamp - event1.timestamp')
          // Find sequences with very small deltas from non-installers
          anomalies = sequences.where('delta').is_less_than(baseline.delta_5th_percentile)
          .and_not('ParentProcessName').in(installer_allowlist)
          alert('Anomalously fast drop-and-execute sequence detected', anomalies)"
  - question: "Can a sequence mining model detect anomalous post-download behavior, such as an unexpected drop-and-execute pattern?"
    context: "This question applies sequence-aware machine learning (e.g., an LSTM-based autoencoder) to understand normal user and application behavior. The model is trained to learn the typical sequences of endpoint events (file creations, process creations, network connections) that follow a file download by a specific application like Chrome or Outlook. It can then detect and flag sequences that deviate significantly from this learned normal behavior, such as a browser suddenly creating and running an executable from a temp directory."
    answer_sources:
      - "Windows Event ID 4688"
      - "Windows Event ID 11 (Sysmon)"
      - "User Workstations"
      - "Application Servers"
      - "Temporary File Directories (%TEMP%, %APPDATA%)"
    range: "last 90 days"
    queries:
      - "pseudocode: |
          // For each application (e.g., Chrome)
          foreach app in ['chrome.exe', 'outlook.exe']:
            // Get event sequences following a download
            sequences = get_event_sequences_after_download(app)
            // Use sequence model to find anomalies
            anomalous_sequences = sequence_model.find_anomalies(sequences)
            if anomalous_sequences:
              alert('Anomalous post-download event sequence detected', anomalous_sequences)"