name: T1546.006: LC_LOAD_DYLIB Addition
id: d4a529a4-1365-4b95-934c-623e1b739678
description: This playbook helps investigate the use of LC_LOAD_DYLIB addition for
  persistence and privilege escalation on macOS. Adversaries modify the load commands
  of legitimate Mach-O binaries to force them to load malicious dynamic libraries
  (dylibs) upon execution. Key investigative avenues include monitoring for the use
  of binary modification tools (e.g., `optool`, `install_name_tool`), looking for
  dylibs being loaded from unusual or user-writable locations (e.g., `/tmp`, `/Users/Shared/`),
  and correlating file modifications with process executions. For persistence, this
  often involves targeting commonly used applications. For privilege escalation, adversaries
  target binaries with setuid or setgid permissions. Subsequent suspicious activity,
  such as spawning shells or initiating outbound network connections after a dylib
  is loaded, can be a strong indicator of compromise.
type: technique
related:
- TA0003: Persistence
- TA0004: Privilege Escalation
contributors:
- Zachary Szewczyk
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
- question: Are binary modification tools being used to inject dylibs listed on threat
    intelligence feeds?
  context: This question aims to detect the direct use of known malicious code for
    persistence. Adversaries often use tools like `optool` or `install_name_tool`
    to modify legitimate applications to load their malicious dynamic libraries (dylibs).
    By cross-referencing the dylib name or path from the command-line arguments against
    a threat intelligence feed, we can quickly identify this explicit TTP.
  answer_sources:
  - macOS ESF Process Events
  - File Integrity Monitoring Logs
  - EDR Module Load Events
  - Threat Intelligence Feeds
  - macOS endpoints (laptops, desktops), macOS-based servers (e.g., build servers,
    web servers), and threat intelligence platforms.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_events
      where process_name in ('optool', 'install_name_tool', 'yololib')
      and command_line contains dylib_from_threat_feed
- question: Are any rarely seen dynamic libraries being loaded across the enterprise?
  context: This question uses a statistical approach to find unknown threats. Legitimate
    dylibs associated with common software are typically found on many hosts, while
    malicious or highly specialized dylibs will be rare. By identifying dylibs with
    very low prevalence (e.g., running on only a handful of machines), analysts can
    focus on potential adversary tools or custom malware.
  answer_sources:
  - macOS ESF Process Events
  - File Integrity Monitoring Logs
  - EDR Module Load Events
  - Threat Intelligence Feeds
  - macOS endpoints (laptops, desktops), macOS-based servers (e.g., build servers,
    web servers), and threat intelligence platforms.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events
      | stats count by dylib_name, host_count
      | where host_count < enterprise_prevalence_threshold(1%)
- question: Can we use machine learning to predict if a dylib load event is malicious
    based on its context?
  context: This question proposes a more advanced detection method for threats that
    are not yet known to threat intelligence. A machine learning model can be trained
    to recognize patterns of malicious behavior by analyzing various features of
    a dylib load event, such as the parent process, user context, path entropy, and
    signing status. This allows for the detection of novel threats by flagging events
    that share characteristics with previously seen malware.
  answer_sources:
  - macOS ESF Process Events
  - File Integrity Monitoring Logs
  - EDR Module Load Events
  - Threat Intelligence Feeds
  - macOS endpoints (laptops, desktops), macOS-based servers (e.g., build servers,
    web servers), and threat intelligence platforms.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events
      | evaluate ML_model(features: parent_process, user, path, signature)
      | where model_confidence > 0.9
- question: Are binary modification tools adding dylibs from non-standard, user-writable
    locations like /tmp or /Users/Shared?
  context: Legitimate dylibs are typically installed in protected system directories.
    Adversaries often drop their malicious payloads into world-writable locations
    like `/tmp` or `/Users/Shared` for ease of access. This question focuses on creating
    a correlation rule to detect the act of modifying a binary to load a dylib from
    one of these suspicious locations.
  answer_sources:
  - macOS Process Execution Logs (with command-line arguments and user context)
  - macOS ESF File Modification Events
  - User home directories on macOS endpoints, shared and temporary directories (`/tmp`,
    `/Users/Shared`) on all macOS systems.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      sequence
        [process_exec where process_name in ('optool', 'install_name_tool') and command_line contains '-add_dylib']
        then [file_mod where dylib_path in ('/tmp/*', '~/.*', '/Users/Shared/*')]
- question: Can we risk-score binary modification events based on the characteristics
    of the dylib path being added?
  context: This question aims to quantify the risk of a given modification. Instead
    of a simple blocklist, this approach assigns a score based on factors like the
    suspiciousness of the path (e.g., `/tmp` is riskier than `/usr/local/lib`) and
    the entropy of the filename (random-looking names are more suspicious). This
    allows analysts to prioritize alerts based on a calculated risk level.
  answer_sources:
  - macOS Process Execution Logs (with command-line arguments and user context)
  - macOS ESF File Modification Events
  - User home directories on macOS endpoints, shared and temporary directories (`/tmp`,
    `/Users/Shared`) on all macOS systems.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search binary_modification_events
      | calculate risk_score(dylib_path_location, filename_entropy)
      | where risk_score > threshold
- question: Does the sequence of events surrounding a binary modification deviate
    from normal software installation patterns?
  context: Legitimate software installations and updates follow predictable sequences
    of events, often involving installer packages and specific process lineages.
    Adversary actions, such as a user directly running a tool to modify a system
    binary, deviate from these norms. This question suggests using a sequence analysis
    model to learn legitimate patterns and flag any modification sequence that is
    statistically improbable.
  answer_sources:
  - macOS Process Execution Logs (with command-line arguments and user context)
  - macOS ESF File Modification Events
  - User home directories on macOS endpoints, shared and temporary directories (`/tmp`,
    `/Users/Shared`) on all macOS systems.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_and_file_events
      | evaluate sequence_model(event_sequence)
      | where probability_score < low_threshold
- question: Has a trusted system binary been modified without a corresponding, authorized
    patch or change request?
  context: This question provides a high-fidelity method for detecting unauthorized
    changes by integrating security data with IT operations data. A file integrity
    monitoring (FIM) system will detect the change, and by cross-referencing this
    with patch management and change control logs, analysts can quickly determine
    if the change was part of a legitimate, documented administrative action or if
    it was unauthorized and potentially malicious.
  answer_sources:
  - File Integrity Monitoring Logs (file hash, signature status, modifying process)
  - Change Management System Logs (patch IDs, deployment times, target hosts)
  - Software Deployment Logs
  - Directories containing critical system binaries (`/bin`, `/sbin`, `/usr/bin`),
    application bundles (`/Applications`), framework directories (`/System/Library/Frameworks`),
    and change management log repositories.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search fim_logs
      | lookup change_management_logs on host, timestamp within 24h
      | where change_record is null
- question: Is a system binary being modified at an unusual or unexpected time compared
    to its historical update cycle?
  context: This question uses time-series analysis to baseline the normal update
    frequency for monitored binaries. Many system files are only patched on a predictable
    schedule (e.g., monthly, quarterly). A modification that occurs far outside this
    expected window is a statistical outlier and warrants investigation as a potential
    compromise.
  answer_sources:
  - File Integrity Monitoring Logs (file hash, signature status, modifying process)
  - Change Management System Logs (patch IDs, deployment times, target hosts)
  - Software Deployment Logs
  - Directories containing critical system binaries (`/bin`, `/sbin`, `/usr/bin`),
    application bundles (`/Applications`), framework directories (`/System/Library/Frameworks`),
    and change management log repositories.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search fim_logs
      | model modification_frequency for each binary
      | alert where current_modification is outlier from baseline
- question: Can an anomaly detection model distinguish between legitimate and potentially
    malicious file modifications?
  context: This question suggests using a machine learning model trained exclusively
    on the features of legitimate file modifications (e.g., the modifying process
    is a known installer, the user is 'system', the time is during a maintenance
    window). Any new modification that does not conform to this learned profile of
    "normal" is flagged as an anomaly, allowing for the detection of novel attack
    techniques.
  answer_sources:
  - File Integrity Monitoring Logs (file hash, signature status, modifying process)
  - Change Management System Logs (patch IDs, deployment times, target hosts)
  - Software Deployment Logs
  - Directories containing critical system binaries (`/bin`, `/sbin`, `/usr/bin`),
    application bundles (`/Applications`), framework directories (`/System/Library/Frameworks`),
    and change management log repositories.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search fim_logs
      | evaluate anomaly_detection_model(features: modifying_process, user, time_of_day)
      | where is_anomaly == true
- question: Is any process loading an unsigned dylib from a suspicious, user-writable
    location?
  context: This question focuses on a rule-based detection that combines two strong
    indicators of malicious activity. Legitimate software is typically code-signed
    by the developer, and it resides in protected system directories. A dylib that
    is both unsigned and located in a suspicious path like `/tmp` or a user's Downloads
    folder is very likely to be malicious.
  answer_sources:
  - macOS ESF Module Load Events (`ES_EVENT_TYPE_NOTIFY_LOADER_OPEN`)
  - Process Execution Logs
  - All macOS endpoints and servers, focusing on processes that run with high privilege
    or handle sensitive data.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events
      where dylib_path in ('/tmp/*', '~/Downloads/*', '/Users/Shared/*')
      and dylib_is_signed == false
- question: Has a new and previously unseen combination of a process and a dylib
    from a user-writable directory appeared in the environment?
  context: This question leverages "first seen" analysis to detect novel threats.
    Over time, a stable environment will have a predictable baseline of which processes
    load which dylibs. An alert on the very first time a new process-dylib pair is
    observed (especially when the dylib is in a risky location) is a powerful way
    to catch emerging malware or attacker activity.
  answer_sources:
  - macOS ESF Module Load Events (`ES_EVENT_TYPE_NOTIFY_LOADER_OPEN`)
  - Process Execution Logs
  - All macOS endpoints and servers, focusing on processes that run with high privilege
    or handle sensitive data.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events
      where is_first_seen(process_name, dylib_path)
      and dylib_path is user_writable
- question: Does a dylib load create an unusual connection in the process-library
    relationship graph?
  context: This question suggests modeling host activity as a graph where processes
    and libraries are nodes and a "loads" relationship is an edge. Legitimate software
    creates a predictable graph structure. An adversary action, such as forcing `sshd`
    to load a dylib from a user's home directory, would create a new and structurally
    anomalous edge between two otherwise disconnected parts of the graph, making
    it easy to spot.
  answer_sources:
  - macOS ESF Module Load Events (`ES_EVENT_TYPE_NOTIFY_LOADER_OPEN`)
  - Process Execution Logs
  - All macOS endpoints and servers, focusing on processes that run with high privilege
    or handle sensitive data.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events
      | build process_dylib_graph
      | evaluate graph_model
      | where is_structural_anomaly(new_edge)
- question: After loading a suspicious dylib, did the process make a network connection
    to a known malicious IP address?
  context: This question aims to increase detection confidence by correlating a suspicious
    host event (loading a dylib from `/tmp`) with a suspicious network event (connecting
    to an IP on a threat feed). This chained alert, linking the potential infection
    vector to command-and-control (C2) communication, provides strong evidence of
    a successful compromise.
  answer_sources:
  - Zeek conn.log
  - Zeek dns.log
  - macOS ESF Module Load Events
  - macOS Process Execution Logs
  - Network egress points (monitored by Zeek), macOS endpoints and servers (for process/module
    context).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      sequence
        [module_load where dylib_path is suspicious]
        then [network_conn where dest_ip in threat_feed]
        by host within 5m
- question: Is a process that loaded a suspicious dylib exhibiting network beaconing
    behavior?
  context: This question looks for a common malware behavior: periodic, automated
    "heartbeat" connections to a C2 server. By analyzing the time intervals between
    outbound connections from a suspicious process, a very low variance (i.e., highly
    regular timing) can be identified. This non-human pattern is a strong indicator
    of automated C2 communication.
  answer_sources:
  - Zeek conn.log
  - Zeek dns.log
  - macOS ESF Module Load Events
  - macOS Process Execution Logs
  - Network egress points (monitored by Zeek), macOS endpoints and servers (for process/module
    context).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search network_conn where process_loaded_suspicious_dylib
      | calculate time_delta_variance by dest_ip
      | where variance < beaconing_threshold
- question: Did a process exfiltrate an anomalous amount of data after loading a suspicious
    dylib?
  context: This question focuses on detecting data exfiltration following a potential
    compromise. By creating a time-series model of a process's normal outbound network
    volume, we can detect significant deviations. A sudden, large spike in data transfer
    that breaks the model's forecast after a suspicious dylib load is a strong signal
    of potential data theft.
  answer_sources:
  - Zeek conn.log
  - Zeek dns.log
  - macOS ESF Module Load Events
  - macOS Process Execution Logs
  - Network egress points (monitored by Zeek), macOS endpoints and servers (for process/module
    context).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search network_conn where process_loaded_suspicious_dylib
      | model outbound_data_volume
      | alert where current_volume > predicted_volume_99_percentile
- question: Is a known privilege escalation payload being injected into a setuid/setgid
    binary?
  context: This question describes a high-severity detection rule that looks for
    a very specific and dangerous attack. It triggers when a tool is used to modify
    a binary with elevated permissions (setuid/setgid) and the dylib being added
    is a known privilege escalation tool. This combination of factors indicates a
    clear and direct attempt to gain root access.
  answer_sources:
  - File Integrity Monitoring Logs (with file permission attributes)
  - macOS Process Execution Logs (with command-line arguments)
  - Threat Intelligence Feeds
  - Directories containing setuid/setgid binaries on macOS endpoints and servers (e.g.,
    `/sbin`, `/usr/bin`).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_exec
      where process_name in ('optool', 'install_name_tool')
      and target_file_is_suid=true and added_dylib_hash in watchlist
- question: Has a setuid/setgid binary that is rarely or never patched been modified?
  context: Many core system utilities with SUID/SGID permissions are extremely stable
    and are modified only during major OS updates. This question leverages that fact
    by profiling the modification frequency of these sensitive files. Any modification
    to a file that is almost never touched is a significant statistical outlier and
    highly suspicious.
  answer_sources:
  - File Integrity Monitoring Logs (with file permission attributes)
  - macOS Process Execution Logs (with command-line arguments)
  - Threat Intelligence Feeds
  - Directories containing setuid/setgid binaries on macOS endpoints and servers (e.g.,
    `/sbin`, `/usr/bin`).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search fim_logs where file_is_suid=true
      | stats count by file_path
      | where modification_count is in 1st_percentile
- question: Can a machine learning model predict if a file modification is an attempted
    privilege escalation?
  context: This question proposes using a supervised machine learning model to proactively
    identify privilege escalation attempts. By training a model on features like
    whether the target file has SUID/SGID bits, whether the modifying user is root,
    and the entropy of command-line arguments, the system can learn to distinguish
    between benign administrative changes and malicious tampering.
  answer_sources:
  - File Integrity Monitoring Logs (with file permission attributes)
  - macOS Process Execution Logs (with command-line arguments)
  - Threat Intelligence Feeds
  - Directories containing setuid/setgid binaries on macOS endpoints and servers (e.g.,
    `/sbin`, `/usr/bin`).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search file_mod_events
      | evaluate ML_model(features: is_suid, modifying_user, cmd_entropy)
      | where prediction == 'privesc_attempt'
- question: Did a non-root user modify a setuid/setgid binary and then immediately
    execute it to gain root privileges?
  context: This question looks for the full, textbook privilege escalation attack
    chain within a short time window. The sequence of a non-privileged user modifying
    a privileged binary, followed immediately by that binary's execution resulting
    in a process with an effective user ID of 0 (root), is an unambiguous indicator
    of a successful privilege escalation.
  answer_sources:
  - macOS Process Execution Logs (with UID, EUID, command line, and parent process
    ID)
  - macOS ESF File Modification Events
  - All macOS endpoints and servers, correlating user activity logs with modifications
    to privileged system files.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      sequence
        [process_exec where user_id != 0 and process_name in ('optool', 'install_name_tool')]
        then [file_mod where target_is_suid]
        then [process_exec where euid == 0 and process_path == modified_target]
        within 10m
- question: Does the process ancestry leading to a privileged execution show evidence
    of tampering with a setuid/setgid binary?
  context: Legitimate executions of SUID/SGID binaries have predictable process lineages.
    This question involves tracing the ancestry of any process running with elevated
    privileges. A process tree that shows a user shell spawning a modification tool,
    which then leads to the execution of the privileged binary, is a statistically
    rare and highly suspicious lineage that points directly to tampering.
  answer_sources:
  - macOS Process Execution Logs (with UID, EUID, command line, and parent process
    ID)
  - macOS ESF File Modification Events
  - All macOS endpoints and servers, correlating user activity logs with modifications
    to privileged system files.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_exec where euid == 0
      | build process_ancestry_graph
      | where graph_contains(user_shell -> mod_tool -> privileged_exec)
- question: Does the sequence of actions leading to a privileged process execution
    violate a model of normal administrative behavior?
  context: This question suggests using a sequence-based machine learning model (like
    a Markov Chain or LSTM) trained on legitimate privileged operations. The specific,
    rapid sequence of a non-root user modifying a SUID binary and then immediately
    executing it would be identified by the model as a highly improbable and therefore
    anomalous sequence, triggering an alert.
  answer_sources:
  - macOS Process Execution Logs (with UID, EUID, command line, and parent process
    ID)
  - macOS ESF File Modification Events
  - All macOS endpoints and servers, correlating user activity logs with modifications
    to privileged system files.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_and_file_events
      | evaluate sequence_model(event_sequence)
      | where sequence_is_improbable and last_event.euid == 0
- question: Was a setuid/setgid binary executed within five minutes of being modified
    by a non-root user?
  context: This is a specific, high-confidence correlation rule. It joins file modification
    events with process execution events to find cases where a SUID/SGID binary was
    tampered with by an unprivileged user and then immediately executed. The short
    timeframe is key, as it strongly suggests the modification was made for the express
    purpose of immediate exploitation.
  answer_sources:
  - macOS Process Execution Logs
  - File Integrity Monitoring Logs (including modifying user context)
  - macOS Authentication Logs
  - Authentication servers (for user context), macOS endpoints (for FIM and process
    logs).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      join fim_alerts, process_exec_logs on host, file_path
      where fim_alerts.modifying_user != 'root'
      and fim_alerts.is_suid
      and timestamp_diff < 5m
- question: Is the time between the modification of a setuid/setgid binary and its
    subsequent execution unusually short?
  context: This question uses statistical analysis of the "time-to-execution" (TTE)
    as an indicator of malicious intent. Legitimate patches or updates are often
    applied during maintenance windows, and the modified binary may not be executed
    for hours or days. A TTE of only a few minutes is a statistical outlier and suggests
    the modification was an attack, not an update.
  answer_sources:
  - macOS Process Execution Logs
  - File Integrity Monitoring Logs (including modifying user context)
  - macOS Authentication Logs
  - Authentication servers (for user context), macOS endpoints (for FIM and process
    logs).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search fim_and_process_events
      | calculate time_to_execution for suid_binaries
      | where tte_seconds < percentile(tte_seconds, 1)
- question: Can a machine learning model score the risk of a setuid/setgid binary
    execution based on recent file activity?
  context: This question proposes a risk-scoring model to evaluate every execution
    of a SUID/SGID binary. The model would ingest features related to the binary's
    recent state, such as `was_recently_modified`, `modifying_user_is_root`, `time_since_modification_seconds`,
    and `signature_is_valid`. Executions receiving a high-risk score would be flagged
    for analyst review.
  answer_sources:
  - macOS Process Execution Logs
  - File Integrity Monitoring Logs (including modifying user context)
  - macOS Authentication Logs
  - Authentication servers (for user context), macOS endpoints (for FIM and process
    logs).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_exec where is_suid
      | enrich with fim_data
      | evaluate risk_model(features: was_modified, mod_user, time_since_mod)
      | where risk_score > high
- question: Is a process running as root loading a dynamic library from an unprotected,
    user-writable directory?
  context: This is a fundamental security principle. Processes with root privileges
    should only load code from trusted, system-protected locations. A root process
    loading a dylib from `/tmp`, `/Users/Shared`, or a user's home directory is a
    major security violation and a very strong indicator of a successful privilege
    escalation or persistence mechanism.
  answer_sources:
  - macOS ESF Module Load Events (must include loading process EUID and module path)
  - All macOS endpoints, specifically monitoring module loads for processes running
    as root.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events
      where process_euid == 0
      and module_path in ('/tmp/*', '/Users/Shared/*', '~/.*')
- question: Is a root process loading a dylib from a directory it has never used
    before?
  context: This question uses baselining to detect anomalous behavior for privileged
    processes. Each root process (e.g., `sshd`, `sudo`) typically has a very stable
    and predictable set of directories from which it loads libraries. A load from
    a new, previously unobserved directory for that specific process is a statistical
    anomaly that should be investigated.
  answer_sources:
  - macOS ESF Module Load Events (must include loading process EUID and module path)
  - All macOS endpoints, specifically monitoring module loads for processes running
    as root.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events where process_euid == 0
      | alert where is_first_seen(process_name, dylib_parent_directory)
- question: Does a module load by a root process appear as an outlier when clustered
    with other legitimate loads?
  context: This question applies unsupervised machine learning to find threats. By
    running a clustering algorithm on the features of dylib paths (e.g., directory
    depth, character randomness), legitimate loads by root processes will form dense,
    well-defined clusters. Malicious loads from unusual paths will not fit into these
    clusters and will be flagged as noise or outliers.
  answer_sources:
  - macOS ESF Module Load Events (must include loading process EUID and module path)
  - All macOS endpoints, specifically monitoring module loads for processes running
    as root.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search module_load_events where process_euid == 0
      | cluster on dylib_path_features
      | where cluster_id == 'noise'
- question: After a privileged process loaded a suspicious dylib, did it spawn a
    shell or make an unusual network connection?
  context: This question looks for the adversary's next step after successfully gaining
    privileged code execution. Spawning an interactive shell (`sh`, `bash`) or a
    networking tool (`nc`, `curl`), or making a connection to an untrusted destination,
    are common post-exploitation actions. Correlating these actions with the initial
    suspicious dylib load creates a high-confidence alert for a critical incident.
  answer_sources:
  - macOS Process Execution Logs
  - macOS ESF Module Load Events
  - Zeek conn.log
  - Zeek dns.log
  - macOS endpoints (for process ancestry), network gateways (for Zeek logs), DNS
    servers (for Zeek DNS logs).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      sequence
        [module_load where process_is_privileged and dylib_path is suspicious]
        then [process_exec where child_process in ('sh', 'bash', 'nc') OR network_conn where dest_ip is not allowlisted]
- question: Did a privileged process, after potential compromise, spawn an uncharacteristic
    child process or connect to a rare network destination?
  context: This question uses baselining to spot abnormal behavior following a potential
    compromise. Every SUID/SGID binary has a predictable set of child processes it
    normally spawns and network destinations it connects to. An alert that triggers
    when a statistically rare child is spawned (e.g., `/usr/sbin/login` spawning
    `curl`) can effectively uncover post-exploitation activity.
  answer_sources:
  - macOS Process Execution Logs
  - macOS ESF Module Load Events
  - Zeek conn.log
  - Zeek dns.log
  - macOS endpoints (for process ancestry), network gateways (for Zeek logs), DNS
    servers (for Zeek DNS logs).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search process_exec where parent_is_suid
      | alert where is_rare_child(parent_name, child_name)
      OR is_rare_destination(parent_name, dest_ip)
- question: Does the graph of activity following a suspicious dylib load by a privileged
    process resemble known malicious patterns?
  context: This question describes an advanced threat detection technique using Graph
    Neural Networks (GNNs). A GNN can be trained to understand the complex structure
    and relationships of normal host activity. When a suspicious event occurs, the
    subgraph of subsequent activity (new processes, files, network connections) can
    be analyzed by the GNN to classify it as either benign or malicious based on
    its structural properties.
  answer_sources:
  - macOS Process Execution Logs
  - macOS ESF Module Load Events
  - Zeek conn.log
  - Zeek dns.log
  - macOS endpoints (for process ancestry), network gateways (for Zeek logs), DNS
    servers (for Zeek DNS logs).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      search events after suspicious_dylib_load
      | build activity_subgraph
      | evaluate GNN_model(subgraph)
      | where prediction == 'malicious'