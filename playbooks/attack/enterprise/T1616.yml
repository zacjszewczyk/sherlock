name: T1616: Call Control
id: 5b1d5e3c-2f9b-4e8a-8b1c-0a1b8c7d4e1f
description: This playbook helps identify adversarial use of the Call Control technique on mobile devices. It provides investigative steps to detect if an adversary is disrupting communications by blocking or redirecting calls, performing audio surveillance by programmatically answering or hiding calls, or using phone calls as a command and control (C2) channel. Detections focus on analyzing application permissions, real-time call events in logs, discrepancies between carrier and device call records, and correlations between call activity and network traffic to uncover these malicious behaviors.
type: technique
related:
  - TA0034: Impact
  - TA0035: Collection
  - TA0037: Command And Control
contributors:
  - Zachary Szewczyk
  - Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Are there any installed applications with risky call-related permissions that are not on our approved application allowlist?
    context: An application that is not on a pre-defined allowlist but possesses high-risk permissions like `ANSWER_PHONE_CALLS` or `PROCESS_OUTGOING_CALLS` could be used to intercept or block legitimate communications. This query helps identify such applications by comparing the installed application inventory and their permissions against a curated allowlist of known-good communication apps.
    answer_sources:
      - UEM application inventory logs
      - Android application manifest file
      - Unified Endpoint Management (UEM) platform
      - Mobile Application Management (MAM) server
      - Application vetting and sandboxing environment
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          apps = GET all_installed_apps_with_permissions()
          allowlist = GET communication_app_allowlist()
          FOR app in apps:
            IF app.package_name NOT IN allowlist AND (app.has_permission('PROCESS_OUTGOING_CALLS') OR app.has_permission('ANSWER_PHONE_CALLS')):
              ALERT(app.package_name, app.device_id)
  - question: Do any applications exhibit an anomalously high permission risk score for their category?
    context: Not all permissions are equally risky. By assigning weights to high-risk permissions (e.g., `PROCESS_OUTGOING_CALLS`), we can score each application. Comparing an app's score to the 98th percentile of scores within its own App Store category (e.g., 'Games') helps identify statistical outliers that are unusually privileged for their stated purpose, warranting manual review.
    answer_sources:
      - UEM application inventory logs
      - Android application manifest file
      - Unified Endpoint Management (UEM) platform
      - Mobile Application Management (MAM) server
      - Application vetting and sandboxing environment
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          app_scores = CALCULATE weighted_permission_score_for_all_apps()
          category_thresholds = CALCULATE 98th_percentile_score_per_category(app_scores)
          FOR app in app_scores:
            IF app.score > category_thresholds[app.category]:
              ALERT(app.package_name, app.score)
  - question: Can a machine learning model identify potentially malicious applications based on their manifest features?
    context: A supervised machine learning model, such as a Random Forest, can be trained to recognize patterns associated with malicious applications. By feeding the model features like the set of requested permissions, permission counts, and declared services, it can classify newly installed applications and flag those that appear malicious with a high confidence score, automating a complex review process.
    answer_sources:
      - UEM application inventory logs
      - Android application manifest file
      - Unified Endpoint Management (UEM) platform
      - Mobile Application Management (MAM) server
      - Application vetting and sandboxing environment
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          model = LOAD trained_random_forest_model()
          new_apps = GET newly_installed_apps()
          FOR app in new_apps:
            features = EXTRACT_features_from_manifest(app.manifest)
            prediction = model.predict(features)
            IF prediction.class == 'malicious' AND prediction.confidence > 0.85:
              ALERT(app.package_name, prediction.confidence)
  - question: Are there instances of non-system applications programmatically blocking outgoing calls in real-time?
    context: An adversary can block an outgoing call by intercepting the `NEW_OUTGOING_CALL` broadcast and terminating it with an `abortBroadcast()` call. This question seeks to identify this specific behavior by creating a correlation rule in a SIEM that looks for these two events occurring in close succession (within 1 second) from the same process, where the process is not a known system or telephony application.
    answer_sources:
      - Android Logcat
      - Centralized log aggregator (SIEM) collecting real-time Logcat streams from managed devices
      - Endpoint Detection and Response (EDR) for Mobile platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          RULE "Programmatic Call Block"
          WHEN event1.message == 'ACTION_NEW_OUTGOING_CALL'
          FOLLOWED BY event2.message == 'abortBroadcast()' WITHIN 1 second
          WHERE event1.process_id == event2.process_id
          AND event2.source_package NOT IN system_telephony_allowlist
          ALERT(event2.device_id, event2.source_package)
  - question: Is any device showing a statistically unusual rate of blocked outgoing calls compared to its own baseline or the fleet average?
    context: While a single blocked call might be benign, a high ratio of blocked calls to outgoing calls on a device can indicate malicious activity. This involves calculating this ratio daily for each device and using statistical methods to flag anomalies. An alert is triggered if a device's ratio deviates significantly (e.g., by 3 standard deviations) from its own 30-day history or from the fleet-wide 95th percentile.
    answer_sources:
      - Android Logcat
      - Centralized log aggregator (SIEM) collecting real-time Logcat streams from managed devices
      - Endpoint Detection and Response (EDR) for Mobile platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          FOR each device:
            daily_ratio = CALCULATE (abortBroadcast_count / new_outgoing_call_count) for last 24h
            historical_avg, historical_stddev = GET 30_day_rolling_stats(device)
            fleet_95th_percentile = GET fleet_95th_percentile_ratio()
            IF daily_ratio > (historical_avg + 3 * historical_stddev) OR daily_ratio > fleet_95th_percentile:
              ALERT(device.id, daily_ratio)
  - question: Are there fleet-wide spikes in call blocking events that indicate a coordinated or widespread campaign?
    context: A sudden, sharp increase in the total number of `abortBroadcast()` events across the entire mobile fleet could signal a large-scale attack. This question is answered by applying a time-series anomaly detection model (like S-H-ESD) to the fleet-wide count of these events per minute. The model learns normal daily and weekly patterns and flags any statistically significant deviations as anomalies for investigation.
    answer_sources:
      - Android Logcat
      - Centralized log aggregator (SIEM) collecting real-time Logcat streams from managed devices
      - Endpoint Detection and Response (EDR) for Mobile platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          event_timeseries = COUNT `abortBroadcast()` events per minute for entire fleet
          model = TRAIN S-H-ESD model on last 30 days of event_timeseries
          anomalies = model.detect_anomalies(event_timeseries)
          IF anomalies.found:
            ALERT("Fleet-wide spike in call blocking detected", anomalies.details)
  - question: Have any newly installed applications requested a combination of permissions indicative of spyware?
    context: Spyware often requires a specific combination of permissions to function: the ability to control calls (`CALL_PHONE` or `ANSWER_PHONE_CALLS`), record audio (`RECORD_AUDIO`), and access call history (`WRITE_CALL_LOG` or `READ_CALL_LOG`). This query sets up a high-priority alert to trigger immediately upon the installation of any non-allowlisted application that requests this dangerous trifecta of permissions.
    answer_sources:
      - UEM application inventory logs
      - Android application manifest file
      - Unified Endpoint Management (UEM) platform
      - Mobile Application Management (MAM) server
      - Data warehouse containing application metadata and allowlists
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          ON new_app_install(app):
            permissions = app.get_permissions()
            is_surveillance_combo = (permissions.has('CALL_PHONE') OR permissions.has('ANSWER_PHONE_CALLS')) AND permissions.has('RECORD_AUDIO') AND (permissions.has('WRITE_CALL_LOG') OR permissions.has('READ_CALL_LOG'))
            IF is_surveillance_combo AND app.package_name NOT IN allowlist:
              ALERT("Potential spyware installed", app.package_name)
  - question: Can applications be scored for 'spyware potential' to identify high-risk outliers?
    context: This approach quantifies the risk of an application being spyware by assigning weights to various surveillance-related permissions (e.g., `RECORD_AUDIO`=10, `CALL_PHONE`=8). The sum of these weights forms a 'Spyware Potential Score'. Applications whose scores exceed the 99th percentile for their category or a high absolute threshold (e.g., 20) are flagged as high-risk outliers needing investigation.
    answer_sources:
      - UEM application inventory logs
      - Android application manifest file
      - Unified Endpoint Management (UEM) platform
      - Mobile Application Management (MAM) server
      - Data warehouse containing application metadata and allowlists
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          spyware_scores = CALCULATE weighted_spyware_score_for_all_apps()
          category_thresholds = CALCULATE 99th_percentile_score_per_category(spyware_scores)
          FOR app in spyware_scores:
            IF app.score > category_thresholds[app.category] OR app.score > 20:
              ALERT(app.package_name, app.score)
  - question: Can clustering algorithms identify groups of applications with rare and suspicious permission combinations?
    context: Legitimate applications within the same category often share similar permission sets. Spyware may have a unique combination of permissions that makes it an outlier. By representing each app as a vector of its permissions and applying a density-based clustering algorithm like DBSCAN, we can find small, isolated clusters of apps. These clusters represent rare permission patterns that are potentially malicious and warrant investigation.
    answer_sources:
      - UEM application inventory logs
      - Android application manifest file
      - Unified Endpoint Management (UEM) platform
      - Mobile Application Management (MAM) server
      - Data warehouse containing application metadata and allowlists
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          permission_vectors = CREATE multi-hot_encoded_permission_vectors_for_all_apps()
          clusters = APPLY DBSCAN(data=permission_vectors, min_samples=3)
          FOR cluster in clusters:
            IF cluster.size < 5 AND cluster.is_not_known_legit_cluster:
              ALERT("Anomalous application cluster found", cluster.members)
  - question: Are there discrepancies between carrier call records and on-device call logs, suggesting call log tampering?
    context: An adversary might delete call logs from a device to hide malicious activity (e.g., calls to a C2 server). This can be detected by comparing the authoritative Call Detail Records (CDRs) from the telecom carrier with the call logs retrieved from the device itself. A `LEFT JOIN` operation can quickly identify calls that exist in the CDRs but are missing from the device's log, indicating deletion.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - UEM-retrieved device call logs
      - Data warehouse or SIEM containing both ingested telecom provider CDR feeds and UEM-polled device call logs
      - Telecom Expense Management (TEM) platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          SELECT cdr.*
          FROM carrier_cdrs cdr
          LEFT JOIN device_logs devlog ON cdr.device_id = devlog.device_id AND cdr.call_time = devlog.call_time
          WHERE devlog.device_id IS NULL
          AND cdr.time > NOW() - 90d
  - question: Is the similarity between carrier and device call logs for any device dropping below an expected threshold?
    context: This question provides a quantitative measure of call log integrity. For each device, we create two sets of call records (one from carrier CDRs, one from the device log) for a 24-hour period. By calculating the Jaccard similarity coefficient between these two sets, we get a score from 0 to 1 representing their overlap. A score that drops below a baseline (e.g., 0.95) indicates a significant discrepancy and potential log tampering.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - UEM-retrieved device call logs
      - Data warehouse or SIEM containing both ingested telecom provider CDR feeds and UEM-polled device call logs
      - Telecom Expense Management (TEM) platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          FOR each device:
            set_A = GET call_records_from_CDRs_last_24h(device)
            set_B = GET call_records_from_device_log_last_24h(device)
            jaccard_score = CALCULATE |intersection(A,B)| / |union(A,B)|
            IF jaccard_score < 0.95:
              ALERT(device.id, jaccard_score)
  - question: Can a predictive model identify devices with a statistically significant and anomalous number of missing call log entries?
    context: Rather than just finding missing logs, this analytic attempts to predict the *expected* number of log entries for a user based on their CDR history, department, and other features. If the actual number of logs found on the device is statistically much lower than the model's prediction (e.g., below the 5th percentile of the prediction interval), it signals an anomalous level of log deletion that may be malicious.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - UEM-retrieved device call logs
      - Data warehouse or SIEM containing both ingested telecom provider CDR feeds and UEM-polled device call logs
      - Telecom Expense Management (TEM) platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          model = LOAD trained_regression_model()
          FOR each user:
            features = GET_features(user.cdr_count, user.department, ...)
            prediction_interval = model.predict(features)
            actual_count = GET_device_log_count(user)
            IF actual_count < prediction_interval.lower_bound_5th_percentile:
              ALERT(user.id, "Anomalous number of missing call logs")
  - question: Is any device making an unusual number of repeated, short-duration calls to the same number?
    context: Malware may use very short phone calls (e.g., < 5 seconds) as a C2 beaconing mechanism. This behavior is distinct from normal human usage. This query establishes a SIEM rule to detect this pattern by alerting when a single device makes more than a set number of these short calls (e.g., > 5) to the same destination number within a short time frame (e.g., 1 hour).
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - Telecom provider data feeds ingested into a central SIEM or data lake
      - Telecom Expense Management (TEM) platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          RULE "Short Call Beaconing"
          COUNT calls WHERE duration < 5s GROUP BY device_id, destination_number
          HAVING COUNT > 5 WITHIN 1 hour
          AND destination_number NOT IN known_service_numbers
          ALERT(device_id, destination_number)
  - question: Are any devices exhibiting beaconing-like behavior characterized by a high volume of short calls to a very small set of numbers?
    context: This is a more advanced statistical method to detect beaconing. For each device, we look at its short-duration calls (< 5s). We then calculate the Shannon entropy of the destination numbers. A very low entropy score indicates low randomness, meaning the device is repeatedly calling the same one or two numbers. Alerting on devices with both a high count of short calls and very low entropy is a strong signal of C2 activity.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - Telecom provider data feeds ingested into a central SIEM or data lake
      - Telecom Expense Management (TEM) platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          FOR each device:
            short_calls = GET calls WHERE duration < 5s
            IF COUNT(short_calls) > fleet_95th_percentile_count:
              dest_numbers = GET destination_numbers from short_calls
              entropy = CALCULATE shannon_entropy(dest_numbers)
              IF entropy < fleet_5th_percentile_entropy:
                ALERT(device.id, "High volume of low entropy short calls detected")
  - question: Can clustering on call timing patterns identify machine-like, periodic C2 beaconing?
    context: C2 beaconing is often periodic (e.g., a call every 5 minutes). Human calling patterns are much more random. This query involves extracting the time between consecutive short calls to the same number (inter-arrival times). By using a clustering algorithm on the mean and variance of these times, we can find a tight cluster with low variance, which represents the machine-like periodicity of automated C2 calls.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - Telecom provider data feeds ingested into a central SIEM or data lake
      - Telecom Expense Management (TEM) platform
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          FOR each device and destination_number:
            inter_arrival_times = CALCULATE time_between_short_calls(device, destination_number)
            features = {mean: MEAN(inter_arrival_times), variance: VAR(inter_arrival_times)}
            cluster = CLUSTER features with other device-number pairs
            IF cluster.center_variance < low_threshold:
              ALERT("Periodic beaconing detected", device.id, destination_number)
  - question: Are short-duration phone calls immediately followed by network connections to known malicious infrastructure?
    context: An adversary could use a short call to "wake up" an implant or trigger it to connect to a C2 server. This query attempts to detect this by correlating a short call event from CDRs with a subsequent network connection (from Zeek logs) from the same device's IP within a tight window (e.g., 10 seconds). An alert is generated if the destination of the network traffic is on a threat intelligence list of known C2 servers.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - Zeek conn.log
      - Zeek dns.log
      - SIEM or data lake with correlation capabilities
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          RULE "Call-Triggered C2 Connection"
          WHEN cdr_event.duration < 5s
          FOLLOWED BY zeek_event.ip == cdr_event.device_ip WITHIN 10s
          WHERE zeek_event.dest_ip IN threat_intel_feed
          ALERT("Call-triggered connection to known C2", cdr_event.device_id, zeek_event.dest_ip)
  - question: Is there a statistically significant temporal correlation between short phone calls and subsequent network activity on any device?
    context: This is a statistical approach to find a "call-then-connect" pattern without relying on threat intelligence. For each device, we create two time series: one marking the end of short calls, and one marking the start of network connections. By calculating the cross-correlation between these two series, we can find if there's a consistent pattern where calls are followed by network activity at a specific lag (e.g., 1-10 seconds), which would be a strong indicator of C2.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - Zeek conn.log
      - Zeek dns.log
      - SIEM or data lake with correlation capabilities
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          FOR each device:
            call_series = CREATE_binary_timeseries_from_short_calls()
            net_series = CREATE_binary_timeseries_from_network_connections()
            cross_corr = CALCULATE_cross_correlation(call_series, net_series)
            peak = FIND_peak_correlation(cross_corr, lag=[1s, 10s])
            IF peak.is_statistically_significant:
              ALERT("Significant correlation found between calls and network traffic", device.id)
  - question: Can sequential pattern mining discover a recurring pattern of a short call followed by a DNS query and network connection?
    context: C2 behavior often follows a specific sequence of events. This query uses a sequential pattern mining algorithm (like PrefixSpan) to analyze a time-ordered stream of all events for a device. The goal is to discover if the specific, frequent pattern of `(short_call_end) -> (dns_query_for_rare_domain) -> (tcp_connection_start)` exists. Finding this strong, repeated sequence is a high-confidence indicator of call-based C2.
    answer_sources:
      - Carrier Call Detail Records (CDRs)
      - Zeek conn.log
      - Zeek dns.log
      - SIEM or data lake with correlation capabilities
    range: last 90 days
    queries:
      - technology: Pseudocode
        query: |
          FOR each device:
            event_stream = CREATE_time_ordered_stream_of_calls_and_network_events()
            patterns = PrefixSpan(event_stream, min_support=5, window=30s)
            target_pattern = `(short_call) -> (dns_query) -> (tcp_conn)`
            IF target_pattern IN patterns:
              ALERT("C2 event sequence discovered", device.id, patterns[target_pattern].details)