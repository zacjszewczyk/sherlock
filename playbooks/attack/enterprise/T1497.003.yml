name: T1497.003: Time Based Evasion
id: e1c9f8a0-4b1d-4e9c-8f2a-6d3b4c5d6e7f
description: >
  This playbook focuses on detecting adversaries attempting to evade defenses or discover the environment using time-based techniques.
  These methods involve manipulating the timing of execution to bypass automated analysis systems (sandboxes) or to delay malicious actions until after initial security scans are complete.
  Key indicators include the use of sleep or delay functions within encoded PowerShell scripts, execution of commands like 'timeout.exe' or 'ping.exe' with unusually long durations, processes that remain dormant for extended periods before acting, and techniques to detect sandbox time acceleration by comparing requested sleep times with actual elapsed time.
  The playbook also covers detecting API hammering and staged discovery actions that are preceded by a delay.
type: technique
related:
  - TA0005: Defense Evasion
  - TA0007: Discovery
contributors:
  - Zachary Szewczyk
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Are there encoded PowerShell commands being executed that contain time-based evasion functions like 'Start-Sleep'?
    context: Adversaries often Base64-encode PowerShell commands to hide their true intent. Within these encoded scripts, they may use cmdlets like 'Start-Sleep' or .NET methods to pause execution. This is a common technique to wait out the analysis time of automated sandboxes, which often terminate a process after a few minutes. Detecting these sleep commands within deobfuscated scripts is a high-fidelity indicator of malicious activity.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - All Windows endpoints and servers, particularly those with PowerShell v5+ script block logging enabled and systems with security monitoring agents.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH logs WHERE (EventID=4688 AND ProcessName='powershell.exe' AND CommandLine CONTAINS ('-e', '-en', '-enc')) OR (EventID=4104) | FOREACH log: DECODE Base64/ScriptBlock | FILTER DecodedContent CONTAINS ('Start-Sleep', '[System.Threading.Thread]::Sleep', 'GetTickCount', 'Measure-Command') | RETURN host, time, user, decoded_command
  - question: Are there PowerShell script blocks with unusually high entropy scores, suggesting obfuscation?
    context: Shannon entropy measures the randomness or complexity of data. Malicious scripts are often heavily obfuscated or packed to avoid signature-based detection, which results in a much higher entropy score than typical administrative scripts. By establishing a baseline for normal script entropy in your environment, you can flag outliers that are likely malicious, even if they don't contain known suspicious keywords.
    answer_sources:
      - Windows Event ID 4104
      - All Windows endpoints and servers, particularly those with PowerShell v5+ script block logging enabled and systems with security monitoring agents.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH logs WHERE EventID=4104 | CALCULATE ShannonEntropy(ScriptBlockText) | BASELINE normal_entropy_over_30_days | FILTER ShannonEntropy > 95th_percentile(baseline) | RETURN host, time, user, script_block, entropy_score
  - question: Can a machine learning model identify malicious command lines based on features like length, character frequency, and keywords?
    context: Manually creating rules for every possible malicious command-line variation is infeasible. A machine learning model, such as logistic regression, can be trained on a large dataset of known benign and malicious command lines to learn the subtle patterns that distinguish them. This allows for the proactive detection of new and unseen malicious commands based on their statistical properties rather than specific signatures.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4104
      - All Windows endpoints and servers, particularly those with PowerShell v5+ script block logging enabled and systems with security monitoring agents.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: INPUT command_lines from EventID 4688, 4104 | EXTRACT_FEATURES (length, char_freq, n-grams, keywords) | APPLY pre-trained_classification_model | FILTER prediction_score > confidence_threshold | RETURN host, time, command_line, score
  - question: Are processes like 'timeout.exe' or 'ping.exe' being used to create unusually long delays?
    context: The native Windows utilities 'timeout.exe' and 'ping.exe' can be abused by malware to pause execution. While legitimate scripts might use a short timeout, an adversary trying to evade a sandbox might use a very long delay (e.g., > 5 minutes or 300 seconds). Pinging a loopback address for a high count achieves the same effect. This is a simple but effective evasion technique.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, especially critical servers or those where interactive command-line usage is rare (e.g., production web servers, database servers).
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH logs WHERE EventID=4688 | FILTER (ProcessName='timeout.exe' AND CommandLine CONTAINS '/t' AND argument > 300) OR (ProcessName='ping.exe' AND CommandLine CONTAINS '-n' AND argument > 300 AND target_ip='127.0.0.1') | RETURN host, time, user, process, command_line
  - question: Are there executions of 'timeout.exe' or 'ping.exe' with delay values that are statistical outliers for the enterprise?
    context: A static threshold (e.g., 300 seconds) can be effective, but it might miss more subtle evasions or generate false positives in unique environments. A more robust approach is to dynamically baseline what constitutes a 'normal' delay for these commands across your entire organization. Any execution that significantly exceeds this learned baseline (e.g., falls in the 99th percentile) is highly suspicious.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, especially critical servers or those where interactive command-line usage is rare (e.g., production web servers, database servers).
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH logs WHERE EventID=4688 AND ProcessName IN ('timeout.exe', 'ping.exe') | PARSE delay_argument | BASELINE delay_values_over_30_days | FILTER delay_argument > 99th_percentile(baseline) | RETURN host, time, user, command_line, delay_argument, baseline_threshold
  - question: Is there a host exhibiting an anomalous spike in the use of delay-inducing commands compared to its own historical behavior?
    context: Instead of comparing a single event to an enterprise-wide baseline, this question focuses on a host's behavior over time. A time-series model can learn the normal rhythm of activity for a specific server or workstation. A sudden, unexpected increase in the use of delay commands on that host would deviate from the model's forecast, indicating a potential compromise or malware execution.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, especially critical servers or those where interactive command-line usage is rare (e.g., production web servers, database servers).
    range: last 90 days
    queries:
      - technology: pseudocode
        query: INPUT time_series_of_delay_commands_per_host | APPLY forecasting_model (SARIMA, LSTM) | COMPARE predicted_activity vs actual_activity | FILTER actual_activity > significant_deviation_threshold | RETURN host, time_of_spike, deviation_details
  - question: Are there 'sleeper' processes that remain dormant for an extended period before initiating network, file, or registry activity?
    context: Malware may be designed to start a process and then sleep for a long time (e.g., 10+ minutes) before performing any malicious actions. This 'sleeper' technique is designed to defeat security tools that only monitor a new process for a short period after it's created. By correlating process creation with subsequent activity over a longer timeframe, you can identify these dormant payloads.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4663
      - Windows Event ID 4657
      - Zeek conn.log
      - All Windows endpoints, servers, and Domain Controllers, in conjunction with network choke points (e.g., internet gateways, VPN concentrators) monitored by Zeek sensors.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: CORRELATE (EventID=4688 AS process_start) WITH (Zeek_conn, EventID=4663, EventID=4657 AS process_action) ON ProcessID | WHERE (time(process_action) - time(process_start)) > 10_minutes AND no_action_within_first_60_seconds | RETURN host, process_name, pid, start_time, first_action_time
  - question: Is a specific process instance taking an unusually long time to make its first network connection compared to other instances of the same process?
    context: Most legitimate applications (like browsers or system services) have a predictable pattern of behavior; they typically make network connections shortly after starting. By baselining this 'time-to-first-network-activity' for each process name (e.g., 'svchost.exe'), you can spot a malicious process masquerading under the same name that exhibits anomalous behavior, such as waiting a long time before connecting to a C2 server.
    answer_sources:
      - Windows Event ID 4688
      - Zeek conn.log
      - All Windows endpoints, servers, and Domain Controllers, in conjunction with network choke points (e.g., internet gateways, VPN concentrators) monitored by Zeek sensors.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: JOIN (EventID=4688) with (Zeek_conn) on host, process_name | CALCULATE time_delta = first_conn_time - process_start_time | GROUPBY process_name | BASELINE mean and std_dev of time_delta | FILTER time_delta > (mean + 3*std_dev) | RETURN host, process_name, time_delta, baseline_mean
  - question: Can unsupervised machine learning identify anomalous 'sleeper' processes by clustering them based on lifecycle features?
    context: This approach uses machine learning to find outliers without pre-defined rules. By creating a set of features for each process (e.g., time to first network connection, time to first file write, parent process rarity), a clustering algorithm like DBSCAN can group normal processes together. Processes that don't fit into any cluster are flagged as anomalies or noise, which are often the suspicious 'sleeper' processes you are looking for.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 4663
      - Windows Event ID 4657
      - Zeek conn.log
      - All Windows endpoints, servers, and Domain Controllers, in conjunction with network choke points (e.g., internet gateways, VPN concentrators) monitored by Zeek sensors.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FOR_EACH process | EXTRACT_FEATURES (time_to_net, time_to_file, process_rarity, etc.) | APPLY DBSCAN_clustering | FILTER cluster_label = 'outlier' OR 'noise' | RETURN host, process_name, process_features
  - question: Is a process checking for time acceleration by comparing a requested sleep duration to the actual elapsed time?
    context: This is a classic sandbox evasion technique. Malware requests a sleep for 'X' seconds and then checks how much wall-clock time actually passed. In many sandboxes, sleep functions are 'fast-forwarded' to speed up analysis. If the actual elapsed time is significantly less than the requested time, the malware knows it's in an analysis environment and can terminate or alter its behavior.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, with a focus on virtualized environments, sandboxes, and developer workstations.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: CORRELATE events by ProcessID | FIND sequence: [time_query_1, sleep_command, time_query_2] within 60s | PARSE requested_sleep_duration from sleep_command | CALCULATE actual_elapsed_time = time(time_query_2) - time(time_query_1) | FILTER actual_elapsed_time < (0.5 * requested_sleep_duration) | RETURN host, pid, command_sequence
  - question: Is any process executing a statistically unusual number of time-query commands?
    context: While a single time query is normal, a process that repeatedly queries the system time, especially in combination with sleep commands, may be performing sandbox checks or preparing for a time-based evasion. By calculating a Z-score, you can identify processes whose time-querying behavior is a statistical outlier compared to all other processes in the environment, warranting further investigation.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, with a focus on virtualized environments, sandboxes, and developer workstations.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH logs WHERE EventID=4688 | COUNT time_query_commands ('time /t', 'date /t') per ProcessID | BASELINE command counts over 7 days | CALCULATE Z-score for each count | FILTER Z-score > 3 | RETURN host, pid, command_count, z_score
  - question: Can a sequence analysis model detect the specific malicious pattern of 'query time -> sleep -> query time'?
    context: A Hidden Markov Model (HMM) is well-suited for analyzing sequences of events. By training an HMM on both benign and known malicious command sequences, the model learns the probable transitions between different actions. It can then score new, unseen sequences, flagging those that strongly match the learned malicious pattern (like a time check, a sleep, and another time check) with high confidence.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, with a focus on virtualized environments, sandboxes, and developer workstations.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: INPUT command_line_sequences per ProcessID | APPLY pre-trained_HMM | FILTER sequence_probability matches 'query_time -> sleep -> query_time' malicious model | RETURN host, pid, command_sequence, model_score
  - question: Are there processes rapidly and repeatedly executing time-query commands without performing any other meaningful action?
    context: This behavior, known as 'API hammering', is a stalling technique. The malware executes a tight loop of inexpensive API calls (like getting the system time) to consume time and wait out an automated analysis window without actually sleeping. The key indicator is a high frequency of these calls without any corresponding network or file I/O, which would be expected from a legitimate process.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, particularly those that are part of automated build or analysis pipelines where execution time is limited.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: AGGREGATE EventID=4688 by ProcessID over 30s windows | COUNT time_query_commands | FILTER command_count > 50 | JOIN with network/file logs for same ProcessID | FILTER network_or_file_activity = FALSE | RETURN host, pid, command_count
  - question: Is any process disproportionately focused on executing time-query commands compared to its other activities?
    context: This is a statistical approach to detecting API hammering. Instead of a fixed threshold, this method looks for processes whose activity is abnormally skewed towards querying the time. A legitimate process might query the time once or twice, but its primary function will involve other commands. A process where a very high percentage of its actions are time queries is highly anomalous and likely malicious.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, particularly those that are part of automated build or analysis pipelines where execution time is limited.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: FOR_EACH ProcessID | CALCULATE ratio = (count_time_queries / total_commands) | BASELINE ratio_distribution over 30 days | FILTER ratio > 99.9th_percentile(baseline) | RETURN host, pid, ratio, baseline_threshold
  - question: Can a deep learning model identify anomalous command sequences indicative of API hammering?
    context: An autoencoder is a type of neural network trained to reconstruct its input. When trained on sequences of normal, benign command-line activity, it learns to efficiently reconstruct them. A highly repetitive, low-complexity sequence like API hammering is not something the model has seen before and will be poorly reconstructed, resulting in a high 'reconstruction error'. This error score can be used to flag the anomalous behavior.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, particularly those that are part of automated build or analysis pipelines where execution time is limited.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: INPUT command_sequences per ProcessID | APPLY pre-trained_autoencoder_model | CALCULATE reconstruction_error | FILTER reconstruction_error > statistical_threshold | RETURN host, pid, sequence, error_score
  - question: Are discovery commands (e.g., 'whoami', 'net user') being executed immediately after a long delay process terminates?
    context: Adversaries often stage their attacks. They may first run a 'sleeper' process (e.g., 'timeout /t 600') to wait out initial monitoring. Once that delay is over and the child process terminates, the original parent process (the malware) proceeds with the next phase, which is often reconnaissance using built-in discovery tools. Correlating these events in sequence provides strong evidence of a staged malicious payload.
    answer_sources:
      - Windows Event ID 4688
      - Zeek conn.log
      - All Windows endpoints and servers, with a focus on Domain Controllers, file servers, and other high-value assets that are likely targets for internal reconnaissance.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: CORRELATE EventID=4688 by ParentPID | FIND sequence: [spawn(delay_process), delay_process_terminates, spawn(discovery_tool)] within 60s of termination | FILTER delay_duration > 300 | RETURN host, parent_pid, parent_process_name, full_sequence
  - question: Is there a suspicious pattern of discovery commands being executed at unusual times across multiple hosts?
    context: This is a hunting technique that looks for scheduled task activity across the enterprise. If an adversary uses a scheduled task to run discovery commands after a delay, it will often result in those commands executing at the same time (e.g., 2:05 AM) across many compromised machines. A time-of-day analysis will reveal these unusual peaks in activity that stand out from normal user or administrative behavior.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, with a focus on Domain Controllers, file servers, and other high-value assets that are likely targets for internal reconnaissance.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: SEARCH logs where ProcessName IN ('ipconfig', 'net', 'systeminfo') | AGGREGATE count by hour_of_day over 30 days | PLOT histogram | IDENTIFY anomalous peaks during non-business hours | RETURN suspicious_hour, command_name, count
  - question: Can we statistically prove that the execution of discovery commands is caused by the prior completion of a delay process?
    context: Correlation does not equal causation. A discovery command might happen to run after a delay process by coincidence. Causal inference models, like Granger causality, go a step further. They test whether the time series of one event (delay process completions) can statistically predict the time series of another event (discovery command executions). A high causality score provides much stronger, mathematically-backed evidence that the two events are part of a deliberate, staged attack chain.
    answer_sources:
      - Windows Event ID 4688
      - All Windows endpoints and servers, with a focus on Domain Controllers, file servers, and other high-value assets that are likely targets for internal reconnaissance.
    range: last 90 days
    queries:
      - technology: pseudocode
        query: CREATE time_series of 'delay_process_completions' per host | CREATE time_series of 'discovery_command_executions' per host | APPLY Granger_causality_test | FILTER p-value < 0.05 | RETURN host, causality_score, p-value