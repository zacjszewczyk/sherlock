name: T1569.003: Systemctl
id: f8a1b2c3-d4e5-4f6a-7b8c-9d0e1f2a3b4c
description: This playbook helps investigate if an adversary is using the systemctl utility on Linux hosts for execution or persistence. This involves detecting the creation of malicious systemd service files (.service), especially those with obfuscated commands or placed in unusual directories; identifying when systemctl is run by an anomalous parent process like a web server; spotting attempts to disable critical security services; and recognizing automated reconnaissance through rapid enumeration commands.
type: technique
related:
- TA0002: Execution
contributors:
- Zachary Szewczyk
- Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
- question: Has a new or modified systemd service file (.service) been detected where
    the `ExecStart` command matches a known malicious indicator from threat intelligence
    feeds?
  context: This question targets the direct placement of malicious code or commands
    within systemd service files for execution or persistence. Adversaries often use
    known malicious tools or connect to known C2 infrastructure. By scanning the `ExecStart`
    directive against threat intelligence for malicious file hashes, domains, IP
    addresses, or command patterns, analysts can uncover high-fidelity evidence of
    a compromise.
  answer_sources:
  - Sysmon for Linux Event ID 11 (FileCreate)
  - auditd logs (syscall=creat, openat)
  - File content of .service files
  - Systemd service file directories on all Linux hosts, including /etc/systemd/system/,
    /run/systemd/system/, /usr/lib/systemd/system/, and user-specific paths like ~/.config/systemd/user/.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      SEARCH file_create or file_modify events FOR file_name LIKE '%.service' IN standard systemd paths
      FOR_EACH event:
        EXTRACT content of ExecStart directive
        MATCH content against threat_intel (hashes, domains, IPs, patterns)
        IF match:
          ALERT (High Severity)
- question: Is there a new or modified systemd service file (.service) with an unusually
    high entropy `ExecStart` command, suggesting obfuscation?
  context: Adversaries often obfuscate commands within service files to evade signature-based
    detection. High Shannon entropy is a strong indicator of packed, encrypted, or
    encoded data. This question helps identify potentially malicious commands by comparing
    the entropy of a new service's `ExecStart` command against a baseline of normal
    entropy scores for legitimate services in the environment. A significant deviation
    warrants investigation for obfuscation techniques.
  answer_sources:
  - Sysmon for Linux Event ID 11 (FileCreate)
  - auditd logs (syscall=creat, openat)
  - File content of .service files
  - Systemd service file directories on all Linux hosts, including /etc/systemd/system/,
    /run/systemd/system/, /usr/lib/systemd/system/, and user-specific paths like ~/.config/systemd/user/.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      BASELINE Shannon entropy of ExecStart commands from all existing *.service files
      SEARCH file_create or file_modify events FOR file_name LIKE '%.service'
      FOR_EACH event:
        CALCULATE entropy of new ExecStart command
        IF entropy > 95th percentile of baseline:
          ALERT (For Manual Review)
- question: Can machine learning classify a newly created systemd service file (.service)
    as malicious based on its textual features?
  context: This question leverages a machine learning model to provide a more sophisticated
    and proactive detection method than simple signatures or statistical anomalies.
    By training a model on features like command length, presence of special characters,
    use of encoding utilities (e.g., base64), and n-gram analysis, it can learn the
    subtle characteristics that distinguish malicious service files from benign ones,
    even for novel threats.
  answer_sources:
  - Sysmon for Linux Event ID 11 (FileCreate)
  - auditd logs (syscall=creat, openat)
  - File content of .service files
  - Systemd service file directories on all Linux hosts, including /etc/systemd/system/,
    /run/systemd/system/, /usr/lib/systemd/system/, and user-specific paths like ~/.config/systemd/user/.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      ON file_create or file_modify event FOR file_name LIKE '%.service':
        EXTRACT features from file content (command length, char ratios, IP/domain presence, n-grams)
        INPUT features into pre-trained classification model (e.g., Random Forest)
        IF model_output == 'malicious':
          ALERT
- question: Has a systemd service file (.service) been created in a non-standard,
    world-writable directory (like /tmp or /dev/shm) and then immediately started
    or enabled via `systemctl`?
  context: This question seeks to identify a classic adversary tactic: dropping a
    persistence mechanism in a temporary, world-writable location and activating it.
    Legitimate services are almost never created and run from directories like `/tmp`.
    Correlating the file creation event with a subsequent `systemctl start` or `enable`
    command within a short time window provides a very high-confidence indicator of
    malicious activity.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - Sysmon for Linux Event ID 11 (FileCreate)
  - auditd logs (syscall=execve, creat)
  - File system and process execution logs from all Linux hosts, with a focus on world-writable
    directories such as /tmp, /var/tmp, and /dev/shm.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      SEARCH file_create event FOR '*.service' IN world-writable_dirs (/tmp, /var/tmp, /dev/shm)
      WITHIN 5 minutes of file_create:
        SEARCH process_create event for 'systemctl' with args 'start' or 'enable' targeting the same file path
        IF both events correlate on the same host:
          ALERT (High Confidence)
- question: Has a systemd service file (.service) been created in a directory that
    is historically very unusual for such files across the enterprise?
  context: This question helps find outliers that may not be in obviously 'bad' directories
    like /tmp but are still highly anomalous. By baselining all locations where .service
    files are normally created, we can flag creations in exceptionally rare locations.
    This statistical approach can uncover adversaries attempting to hide their persistence
    mechanisms in obscure but writable directories, which might be missed by static
    blocklists.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - Sysmon for Linux Event ID 11 (FileCreate)
  - auditd logs (syscall=execve, creat)
  - File system and process execution logs from all Linux hosts, with a focus on world-writable
    directories such as /tmp, /var/tmp, and /dev/shm.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      BASELINE frequency map of parent directories for all *.service file creations over 30 days
      SEARCH file_create event FOR file_name LIKE '%.service'
      FOR_EACH event:
        GET parent_directory
        IF parent_directory is in the bottom 1% of the frequency map (is very rare):
          ALERT
- question: Is there an anomalous spike in the rate of .service file creations in
    non-standard directories, suggesting an automated attack?
  context: This question focuses on the velocity of an attack rather than a single
    event. A sudden burst of .service file creations in unusual locations can indicate
    an automated script or worm spreading across the network. A time-series anomaly
    detection model can distinguish this abnormal spike from normal system activity,
    providing an early warning of a potentially widespread compromise.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - Sysmon for Linux Event ID 11 (FileCreate)
  - auditd logs (syscall=execve, creat)
  - File system and process execution logs from all Linux hosts, with a focus on world-writable
    directories such as /tmp, /var/tmp, and /dev/shm.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      MONITOR time-series of *.service file creation counts in non-standard directories
      APPLY anomaly detection model (e.g., SARIMA) to the time-series
      IF model detects a significant positive anomaly (a spike):
        ALERT (Potential Automated Attack)
- question: Was `systemctl` executed by a suspicious or non-interactive parent process,
    such as a web server daemon or database service?
  context: This question aims to detect when `systemctl` is invoked as part of a post-exploitation
    payload. `systemctl` is typically run by an administrator from an interactive shell
    or by a legitimate configuration management tool. When a process like `nginx`,
    `httpd`, `java`, or `node` spawns `systemctl`, it's a strong indication that an
    attacker has compromised that service and is now using it to escalate privileges
    or establish persistence.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - Process creation and process relationship logs from all Linux hosts, especially
    mission-critical servers (e.g., web servers running Apache/Nginx, application
    servers running Java/Node.js, database servers).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      SEARCH process_create events for process_name 'systemctl'
      FOR_EACH event:
        GET parent_process_name
        IF parent_process_name IN (nginx, httpd, apache2, php-fpm, java, node, etc.):
          ALERT (High Priority)
- question: Was `systemctl` executed by a parent process that has historically been
    a very rare parent for it on this host or server group?
  context: This question identifies anomalous process relationships that might not
    be on a static blocklist. By building a baseline of normal parent-child relationships
    for `systemctl` on a per-host or per-role basis, we can detect deviations. An
    execution by a parent that has a very low probability of spawning `systemctl`
    is a statistical anomaly that points to unusual and potentially malicious behavior.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - Process creation and process relationship logs from all Linux hosts, especially
    mission-critical servers (e.g., web servers running Apache/Nginx, application
    servers running Java/Node.js, database servers).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      BASELINE conditional probability P(Parent | Child='systemctl') for each host/server group over 30 days
      SEARCH process_create events for process_name 'systemctl'
      FOR_EACH event:
        GET parent_process_name and host
        CALCULATE P(parent_process_name | 'systemctl') for that host/group
        IF probability < 1%:
          ALERT
- question: Does the process execution chain leading to `systemctl` execution represent
    a topologically rare or abnormal path in the process graph?
  context: This question models system activity as a graph of process interactions
    to find not just a single anomalous parent, but an entire unusual sequence of
    events. A graph-based anomaly detection algorithm can identify execution pathways
    leading to `systemctl` that are structurally different from the thousands of benign
    pathways observed over time. This can uncover sophisticated attackers using complex
    process chains to hide their activity.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - Process creation and process relationship logs from all Linux hosts, especially
    mission-critical servers (e.g., web servers running Apache/Nginx, application
    servers running Java/Node.js, database servers).
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      MODEL all process executions as a historical process graph
      ON new process_create event for process_name 'systemctl':
        CONSTRUCT the execution chain (path) leading to this event
        APPLY graph-based anomaly detection algorithm
        IF path is topologically dissimilar to historical paths:
          ALERT
- question: Has a `systemctl stop` or `systemctl disable` command been executed against
    a critical security service (e.g., auditd, osqueryd, EDR agent)?
  context: This question looks for direct evidence of defense evasion. One of an attacker's
    first goals is often to disable security monitoring and logging tools to operate
    undetected. Monitoring for explicit commands to stop or disable a predefined list
    of critical services (like auditd, rsyslog, or EDR agents) provides a high-priority,
    actionable alert that security controls are being tampered with.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - SIEM ingestion logs
  - Zeek conn.log
  - Process execution logs from all Linux hosts. Log ingestion health metrics from
    the SIEM. Network traffic logs from network gateways and core switches.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      DEFINE critical_services_list (auditd.service, osqueryd.service, falcon-sensor.service, etc.)
      SEARCH process_create events for 'systemctl' with args 'stop' or 'disable'
      FOR_EACH event:
        GET target_service from command line
        IF target_service IN critical_services_list:
          ALERT (Critical)
- question: Has a critical security agent stopped sending logs or heartbeats, and
    does this outage correlate with recent `systemctl` activity on the same host?
  context: This question provides an indirect way to detect disabled services by monitoring
    their output. Instead of relying solely on catching the `systemctl stop` command,
    it detects the *effect* of that command. By baselining the normal logging interval
    for each agent, we can flag a statistically significant outage. Correlating this
    outage with `systemctl` commands executed just before the logs stopped provides
    strong circumstantial evidence of defense evasion.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - SIEM ingestion logs
  - Zeek conn.log
  - Process execution logs from all Linux hosts. Log ingestion health metrics from
    the SIEM. Network traffic logs from network gateways and core switches.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      FOR_EACH security_agent/host:
        MONITOR log ingestion timestamps
        CALCULATE mean and std deviation of time between logs
        IF time_since_last_log > (mean + 3 * std_dev):
          ALERT for potential outage
          SEARCH for 'systemctl' process events on the same host just before the outage
          CORRELATE and report findings
- question: Has a time-series model detected a sudden, unexplained drop in security
    log volume from a host that could indicate a disabled service?
  context: This question uses a more advanced time-series model to detect security
    agent tampering. Unlike a simple statistical threshold, a model like Prophet can
    account for seasonality (e.g., lower activity on weekends) to reduce false positives.
    An anomalous drop in log volume that the model cannot explain by normal patterns
    is a strong signal that a logging or security service may have been disabled,
    prompting correlation with `systemctl` activity on the host.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - SIEM ingestion logs
  - Zeek conn.log
  - Process execution logs from all Linux hosts. Log ingestion health metrics from
    the SIEM. Network traffic logs from network gateways and core switches.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      FOR_EACH host:
        MODEL security log volume over time using a time-series model (e.g., Prophet)
        IF model detects a sudden, unexplained drop in log volume:
          ALERT for anomalous log drop
          CORRELATE with 'systemctl' process logs from the same host
- question: Has a single user or process executed an excessive number of `systemctl`
    reconnaissance commands within a short time window?
  context: This question aims to detect automated reconnaissance. While an administrator
    might run a few `systemctl status` or `list-units` commands, an attacker's script
    will often run many enumeration commands in rapid succession to map out the system's
    services. A simple rule that counts these commands per user/host over a sliding
    window and alerts on a hard threshold (e.g., >15 in 1 minute) is effective at
    catching this noisy, automated behavior.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - Shell history logs (e.g., .bash_history, .zsh_history)
  - Process execution logs and shell command history logs from all interactive Linux
    sessions, including bastion hosts, developer workstations, and administrative
    servers.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      DEFINE recon_commands ('status', 'list-units', 'list-unit-files', 'is-enabled', etc.)
      COUNT 'systemctl' executions with recon_commands per user/host over a 1-minute sliding window
      IF count > 15:
        ALERT (Potential Automated Discovery)
- question: Is a user executing `systemctl` reconnaissance commands at a rate that
    is statistically abnormal compared to their own historical baseline?
  context: This question provides a more tailored approach to detecting reconnaissance
    by focusing on behavioral change. An administrator who frequently uses `systemctl`
    might trigger a simple threshold rule during normal work. By creating a baseline
    of each user's *own* typical command rate, we can alert when they significantly
    deviate from their personal norm. This helps distinguish a user's legitimate,
    heavy administrative work from potentially compromised account activity.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - Shell history logs (e.g., .bash_history, .zsh_history)
  - Process execution logs and shell command history logs from all interactive Linux
    sessions, including bastion hosts, developer workstations, and administrative
    servers.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      FOR_EACH user:
        BASELINE hourly rate of 'systemctl' recon commands over 30 days
      MONITOR current hourly rate of 'systemctl' recon commands per user
      IF current_rate > 99th percentile of user's baseline:
        ALERT (Behavioral Deviation)
- question: Can clustering algorithms automatically identify and group rapid, automated
    sequences of `systemctl` commands, separating them from normal manual usage?
  context: This question uses unsupervised machine learning to discover suspicious
    automation without predefined thresholds or baselines. A density-based clustering
    algorithm like DBSCAN can analyze `systemctl` executions based on features like
    the time between commands. It will naturally group the tightly packed, rapidly
    fired commands from a script into a 'dense' cluster, while sparse, manually-typed
    commands will be treated as noise. Identifying these dense clusters provides a
    powerful way to detect automated reconnaissance.
  answer_sources:
  - Sysmon for Linux Event ID 1 (ProcessCreate)
  - auditd logs (syscall=execve)
  - Shell history logs (e.g., .bash_history, .zsh_history)
  - Process execution logs and shell command history logs from all interactive Linux
    sessions, including bastion hosts, developer workstations, and administrative
    servers.
  range: last 90 days
  queries:
  - technology: pseudocode
    query: |
      COLLECT 'systemctl' command events with features (timestamp, user, host, command_type)
      APPLY DBSCAN clustering on events based on time delta between commands, user, and host
      IF a dense cluster is identified:
        ALERT (Suspicious Automated Sequence)