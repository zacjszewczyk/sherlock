name: T1055.009: Proc Memory
id: 3e7f8c9a-b1d2-4e5f-a6b7-c8d9e0f1a2b3
description: |
  This playbook focuses on detecting adversaries using the /proc filesystem on Linux to manipulate the memory of other processes for privilege escalation or defense evasion (T1055.009). Key investigative paths include searching for low-privilege processes writing to the `/proc/[pid]/mem` or `/proc/[pid]/maps` files of high-privilege processes, often followed by the target process spawning a shell or making outbound network connections. Another indicator is the use of the `dd` utility to read from or write to a process's memory space, especially when followed by anomalous network activity. Investigators should also look for any process that, after being targeted by a write to its `/proc` memory, exhibits abnormal behavior such as opening new listening ports, reading sensitive files, or spawning unusual child processes.
type: technique
related:
  - TA0004: Privilege Escalation
  - TA0005: Defense Evasion
contributors: Zachary Szewczyk, Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Has a non-root process written to the memory space of a root-owned process, and did that root process subsequently spawn a shell or networking utility?
    context: |
      This question aims to detect a classic privilege escalation scenario. An attacker with low-privilege access might inject code into a process running as root to gain elevated permissions. A common follow-on action is to spawn a shell (`/bin/sh`, `/bin/bash`) or a networking tool like netcat (`nc`) to establish a command and control channel or reverse shell with root privileges. Detecting this specific sequence of events within a short timeframe (60 seconds) is a high-fidelity indicator of a successful privilege escalation attempt via proc memory injection.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Zeek conn.log
      - Critical Linux servers (e.g., database servers, web servers), Crown Jewel application hosts, Kubernetes nodes
    range: Last 90 days
    queries:
      - pseudocode: |
          SEARCH (Auditd logs for write syscall to /proc/*/mem OR /proc/*/maps WHERE source_euid != 0 AND target_process_owner == 'root') 
          AND (Sysmon Event ID 1 for process creation of /bin/sh, /bin/bash, or nc WHERE parent_pid is the target_process_pid from the Auditd event) 
          WITHIN 60 SECONDS.
  - question: Has a process performed a statistically rare write to another process's memory, and did the target process then spawn an uncharacteristic child process?
    context: |
      This question uses behavioral analysis and anomaly detection to find more subtle injection attacks. Legitimate processes have predictable behavior. A process writing to another process's memory via `/proc/[pid]/mem` is extremely unusual. This question seeks to identify such a rare write event and correlate it with another anomaly: the target process spawning a child process it has never spawned before (e.g., a web server like nginx spawning a `bash` shell). This combination of rare events strongly suggests that the target process's execution flow has been hijacked.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Critical Linux servers (e.g., database servers, web servers), Crown Jewel application hosts, Kubernetes nodes
    range: Last 90 days
    queries:
      - pseudocode: |
          1. BASELINE file write paths and parent-child process relationships.
          2. SEARCH for file writes to /proc/*/mem that are statistically rare (>99th percentile).
          3. IF found, CHECK if the target process PID spawns a child process that is statistically rare for that parent process.
  - question: Has any process exhibited an anomalous sequence of system calls indicative of proc memory injection, such as opening, seeking, and writing to another process's memory, followed by the target process making a network connection?
    context: |
      This question leverages advanced machine learning to detect proc memory injection by modeling the sequence of system calls (syscalls). Benign software has predictable syscall patterns. A memory injection attack requires a specific sequence: `open` a proc memory file, `lseek` to a specific memory offset, and `write` the malicious code. If the injected code is a reverse shell, the target process will then execute a `connect` syscall. A model trained on normal behavior would flag this entire sequence as highly anomalous, providing a sophisticated method for detecting the attack pattern itself.
    answer_sources:
      - Linux Auditd logs
      - Critical Linux servers (e.g., database servers, web servers), Crown Jewel application hosts, Kubernetes nodes
    range: Last 90 days
    queries:
      - pseudocode: |
          1. TRAIN a sequence analysis model (e.g., HMM) on benign syscall sequences.
          2. MONITOR real-time syscall data for sequences with low probability under the model.
          3. FLAG sequences like (open /proc/[pid]/maps -> lseek -> write /proc/[pid]/mem) by one process, followed by a (connect) syscall by the target PID.
  - question: Was the `dd` utility used to interact with a process's memory, and did the host then connect to a known command-and-control (C2) server?
    context: |
      The `dd` utility is a powerful tool for copying data, but its use to interact with `/proc` memory files is highly suspicious and a known attacker technique. This question looks for the execution of `dd` with command-line arguments pointing to `/proc/[pid]/mem` or `/proc/[pid]/maps`. To increase confidence that this is malicious, it correlates the `dd` execution with subsequent outbound network traffic from the same host to an IP address on a threat intelligence list of known C2 servers. A match within a 5-minute window strongly suggests a defense evasion attempt.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Zeek conn.log
      - Zeek dns.log
      - Threat Intelligence Feeds
      - All Linux endpoints and servers, especially those running custom or sensitive applications, DNS resolvers
    range: Last 90 days
    queries:
      - pseudocode: |
          SEARCH (Sysmon Event ID 1 or Auditd execve for process 'dd' with command line containing '/proc/' AND ('mem' OR 'maps')) 
          AND (Zeek conn.log for outbound connection from the same host to an IP on C2 threat list) 
          WITHIN 5 MINUTES.
  - question: Has the `dd` utility been executed with rare arguments pointing to process memory, and did the targeted process subsequently connect to a rare destination IP address?
    context: |
      This question uses statistical rarity to uncover `dd`-based memory injection without relying on known-bad indicators. The core idea is that legitimate use of `dd` to access `/proc` memory is exceptionally rare. By baselining all `dd` command-line arguments, any instance involving `/proc/` can be flagged. The suspicion is strengthened by observing a second rare event: the process whose memory was targeted by `dd` then makes a network connection to an IP address that is itself a rare destination for that specific host. This two-stage rarity check effectively filters out noise.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Zeek conn.log
      - All Linux endpoints and servers, especially those running custom or sensitive applications
    range: Last 90 days
    queries:
      - pseudocode: |
          1. BASELINE 'dd' command-line arguments and host network destinations.
          2. SEARCH for 'dd' executions with '/proc/' in arguments (statistically rare >99.9th percentile).
          3. IF found, CHECK if the target process PID initiates network traffic to a destination IP that is statistically rare (>99th percentile) for that host.
  - question: Following a suspicious use of `dd` to modify a process's memory, did that process initiate network traffic that is anomalous compared to the host's normal communication patterns?
    context: |
      This question applies unsupervised machine learning to network traffic to identify C2 communications. By using a clustering algorithm like DBSCAN, we can group a host's network connections into clusters representing "normal" behavior. After detecting a suspicious `dd` command targeting a process's memory, we monitor the network traffic from that process. If its subsequent connections are outliers that don't fit into any of the established "normal" clusters, they are highly likely to be anomalous C2 traffic.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Zeek conn.log
      - All Linux endpoints and servers, especially those running custom or sensitive applications
    range: Last 90 days
    queries:
      - pseudocode: |
          1. CLUSTER network traffic (Zeek conn.log) using DBSCAN to define normal patterns.
          2. ON ALERT for suspicious 'dd' execution, analyze subsequent network traffic from the target PID.
          3. FLAG traffic that is classified as a noise/outlier point by the DBSCAN model.
  - question: After a process's memory was written to, did it then spawn a known reverse shell or connect to an external IP address?
    context: |
      This question provides a direct, rule-based method for detecting post-exploitation activity. Once a write to a process's memory via `/proc/[pid]/mem` is observed, the next logical step for an attacker is to establish control. This is often done by spawning a reverse shell using common tools like bash, python, or perl, or by initiating a direct network connection to an external, non-private (non-RFC1918) IP address. Alerting on this sequence provides a strong signal of a compromised process.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Sysmon for Linux Event ID 3
      - Application servers, developer workstations, systems with access to sensitive data repositories
    range: Last 90 days
    queries:
      - pseudocode: |
          SEARCH (Auditd log for write to /proc/*/mem) 
          AND WITHIN a short timeframe, the target PID either 
          (Sysmon Event ID 1 for process creation with command line matching reverse shell patterns) 
          OR (Sysmon Event ID 3 for network connection to a non-RFC1918 IP).
  - question: Following a potential memory write, did a critical process (like sshd, nginx, or mysqld) deviate from its established behavioral baseline by accessing unusual files or spawning unusual child processes?
    context: |
      Critical daemons and services typically have very stable and predictable behavior. This question focuses on creating a high-fidelity behavioral profile for these key processes. If a write to the memory of one of these profiled processes is detected, any subsequent deviation from its normal behavior becomes extremely suspicious. For example, a web server process (`nginx`) suddenly reading `/etc/shadow` or spawning a debugger (`gdb`) are actions completely outside its normal function and indicate it has likely been hijacked.
    answer_sources:
      - Linux Auditd logs
      - Sysmon for Linux Event ID 1
      - Application servers, developer workstations, systems with access to sensitive data repositories
    range: Last 90 days
    queries:
      - pseudocode: |
          1. BASELINE normal file access and child process creation for critical processes (sshd, nginx, etc.).
          2. ON ALERT for write to a critical process's memory, monitor its subsequent actions.
          3. CALCULATE and FLAG high anomaly scores for deviations from the baseline (e.g., reading /etc/shadow, spawning gdb).
  - question: Using a machine learning model trained on its normal system calls, has a long-running service process exhibited outlier behavior, especially after a write to its proc memory space?
    context: |
      This question employs a machine learning model (One-Class SVM) to create a precise boundary of "normal" behavior for critical, long-running services based on their system call patterns. Any syscall activity that falls outside this boundary is an outlier. The signal becomes stronger when an outlier is detected shortly after an observed write to the process's `/proc` memory space, as it suggests the anomalous behavior is a direct result of malicious code injection.
    answer_sources:
      - Linux Auditd logs
      - Application servers, developer workstations, systems with access to sensitive data repositories
    range: Last 90 days
    queries:
      - pseudocode: |
          1. TRAIN a one-class SVM model on benign syscall traces for specific services.
          2. MONITOR real-time syscalls for these services and identify outliers.
          3. INCREASE SEVERITY if an outlier is detected after a write to the process's /proc memory space.