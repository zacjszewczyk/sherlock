name: T1622: Debugger Evasion
id: f4b1b3b2-7b1a-4e3a-9e1d-8c1b2a3b4c5d
description: This playbook focuses on detecting adversary attempts to identify and evade debuggers for the purposes of defense evasion and discovery. Adversaries check for the presence of debuggers by accessing specific registry keys or file system artifacts of known tools (e.g., x64dbg, WinDbg), performing timing checks where a process terminates in under a second after loading, using self-debugging techniques where a process spawns a debugger to attach to its own parent, or by raising and handling specific exceptions like STATUS_SINGLE_STEP. Detection may also involve identifying executables whose file hashes match known malware with debugger evasion capabilities, or observing a rapid succession of process enumeration commands. This behavior is often followed by internal network reconnaissance, making the correlation of host and network events critical for detection.
type: technique
related:
  - TA0005: Defense Evasion
  - TA0007: Discovery
contributors:
  - Zachary Szewczyk
  - Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
  - question: Is a process unexpectedly accessing registry keys or file paths associated with known debuggers?
    context: This question aims to identify malware performing reconnaissance for debugging tools. Adversaries often check for the presence of debuggers like x64dbg, OllyDbg, or WinDbg by querying specific registry keys (e.g., in `Image File Execution Options`) or searching for their installation directories. An alert from an unexpected process (not a developer tool or admin script) accessing these artifacts is a strong indicator of an evasion attempt. Excluding known legitimate processes is crucial to reduce false positives.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 11 (Sysmon)
      - Windows Event ID 12 (Sysmon)
      - Windows Event ID 13 (Sysmon)
      - Standard user workstations
      - Production servers
      - Critical application servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: SEARCH process creation and registry access logs WHERE (process_name NOT IN (allow_list)) AND (command_line CONTAINS 'reg query' OR command_line CONTAINS 'dir') AND (target_path CONTAINS 'x64dbg' OR 'ollydbg' OR 'windbg' OR 'ida' OR 'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<debugger.exe>')
  - question: Is a specific process accessing debugger-related artifacts at a statistically anomalous rate compared to its baseline?
    context: This question seeks to find 'low and slow' or subtle evasion attempts that might be missed by simple signature-based rules. By establishing a normal baseline for file and registry access for every process, we can use statistical analysis to detect outliers. A process that suddenly starts accessing debugger-related files or keys, even infrequently, will stand out when its behavior deviates significantly (e.g., beyond the 99th percentile) from its own history or the behavior of its peers.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 11 (Sysmon)
      - Windows Event ID 12 (Sysmon)
      - Windows Event ID 13 (Sysmon)
      - Standard user workstations
      - Production servers
      - Critical application servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. GROUP process file/registry access events by process_name over 90 days. 2. CALCULATE baseline access frequency for debugger-related artifacts per process_name. 3. FOR each new event, COMPARE access frequency to baseline. 4. ALERT if frequency > 99th percentile.
  - question: Can machine learning classify a process's activity as malicious based on its interaction with the system and registry, specifically in the context of debugger evasion?
    context: This question explores a more advanced, predictive approach. A single event might not be suspicious, but a combination of factors (e.g., a process running from a temp folder, with high entropy, and accessing a debugger key) is highly indicative of malice. A machine learning model, like a Random Forest, can be trained on labeled data to recognize these complex patterns across multiple features (process name, parent, command line, registry paths) and assign a risk score, enabling more sophisticated and automated detection.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 11 (Sysmon)
      - Windows Event ID 12 (Sysmon)
      - Windows Event ID 13 (Sysmon)
      - Standard user workstations
      - Production servers
      - Critical application servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. EXTRACT features from process/registry logs (process_name, parent_name, path_entropy, cmd_line_args, registry_paths). 2. INPUT features into pre-trained ML model. 3. ALERT if model prediction score is 'malicious' or exceeds a high-confidence threshold.
  - question: Is a process terminating almost immediately after loading core system DLLs like 'kernel32.dll' or 'ntdll.dll'?
    context: This question targets a common anti-debugging technique where malware performs a quick check for a debugger and then exits if one is not found, to avoid analysis. This 'check-and-exit' behavior results in a very short process lifetime. Correlating a process termination event (Sysmon ID 5) that occurs within one second of a core module load (Sysmon ID 7) for the same process GUID is a high-fidelity indicator of this evasion tactic. The suspicion is increased if the process is unsigned or runs from a temporary location.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 5 (Sysmon)
      - Windows Event ID 7 (Sysmon)
      - All Windows endpoints and servers
      - Virtual Desktop Infrastructure (VDI) instances
      - Security analysis sandbox environments
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: CORRELATE logs by ProcessGuid. ALERT if (EventID=7 AND Module='kernel32.dll' OR 'ntdll.dll') is followed by (EventID=5) within 1 second for the same ProcessGuid.
  - question: Are there new or rare processes in the environment exhibiting unusually short lifetimes, consistent with 'check-and-exit' behavior?
    context: This question provides a broader, statistical method for detecting timing-based evasion. Instead of focusing on a single instance, it analyzes process lifetimes across the entire enterprise. By identifying the shortest-lived processes (e.g., the bottom 1st percentile), analysts can focus on new or uncommon executables that fit this profile. This helps uncover novel malware that uses timing checks without relying on specific module load events.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 5 (Sysmon)
      - Windows Event ID 7 (Sysmon)
      - All Windows endpoints and servers
      - Virtual Desktop Infrastructure (VDI) instances
      - Security analysis sandbox environments
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. CALCULATE process lifetime (terminate_time - create_time) for all processes. 2. IDENTIFY the 1st percentile lifetime threshold. 3. ALERT on new or rare process_names where median_lifetime < threshold.
  - question: Can unsupervised machine learning identify anomalous clusters of short-lived processes based on their execution characteristics?
    context: This question leverages clustering algorithms like DBSCAN to group processes based on multiple behavioral features, including lifetime, number of loaded DLLs, parent process, and file path characteristics. Legitimate short-lived processes (like installers or scripts) will form dense, known clusters. Malware using timing evasion will likely form new, small, or sparse clusters that can be flagged as anomalous and prioritized for investigation, without prior knowledge of the specific malware.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 5 (Sysmon)
      - Windows Event ID 7 (Sysmon)
      - All Windows endpoints and servers
      - Virtual Desktop Infrastructure (VDI) instances
      - Security analysis sandbox environments
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. EXTRACT features from process logs (lifetime, dll_count, parent_name, path_entropy). 2. APPLY clustering algorithm (e.g., DBSCAN) to the feature set. 3. INVESTIGATE processes in small or sparse clusters.
  - question: Is a process attempting to debug its own parent process?
    context: This question targets a specific and highly suspicious form of self-debugging used for evasion. An adversary's process might spawn a debugger (like ntsd.exe) and instruct it to attach to its own parent process. This can interfere with external debuggers an analyst might try to use. Detecting a known debugger being launched with command-line flags (-p, -pd) that point to its direct parent's Process ID is a critical, high-confidence indicator of malicious activity, as this behavior is virtually non-existent in legitimate operations.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - All Windows endpoints and servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: SEARCH process creation logs WHERE (process_name IN (debugger_list)) AND (command_line CONTAINS ('-p ' + ParentProcessId) OR ('-pd ' + ParentProcessId)).
  - question: Has a parent-child process relationship, where the child is a debugger attaching to the parent, ever occurred in the environment?
    context: This question frames the self-debugging detection as a zero-baseline anomaly. In a standard production environment, there is no legitimate reason for a program to spawn a debugger to attach to its parent. Therefore, the expected frequency of this event is zero. Any single occurrence is, by definition, a statistically significant deviation from the norm and should be treated as a high-priority security incident requiring immediate investigation.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - All Windows endpoints and servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: COUNT process creation events where a child debugger targets its ParentProcessId. ALERT if count > 0.
  - question: Can a process relationship graph reveal instances of a process spawning a debugger to attach to itself?
    context: This question proposes using a graph database to visualize and query complex process relationships. Processes and their parent-child links can be modeled as nodes and edges. This allows for a specific, powerful query to find a pattern a 'parent' node creating a 'child' node (where the child is a known debugger) with an edge attribute indicating the child's command line targets the parent's ID. This graph-based approach is highly effective for visualizing and detecting such specific, multi-hop malicious behaviors.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - All Windows endpoints and servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: QUERY graph database for pattern (Parent)-[creates]->(Child) WHERE Child.name IN (debugger_list) AND Child.command_line CONTAINS Parent.ProcessId.
  - question: Is a non-debugger process generating and handling a single-step exception without crashing?
    context: This question targets an evasion technique where malware intentionally triggers an exception, such as a single-step exception (STATUS_SINGLE_STEP), to see how the system handles it. If a debugger is attached, the handling flow will be different than if one is not. A legitimate program crashing would terminate, but malware using this technique will handle the exception and continue execution. Alerting on a process that raises this specific exception but doesn't crash (and isn't a whitelisted developer tool) is a strong signal of this behavior.
    answer_sources:
      - EDR Telemetry (Exception Events)
      - Windows Event ID 1000 (Application Error)
      - Windows Event ID 1001 (Windows Error Reporting)
      - All Windows endpoints, especially those not used for software development
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: CORRELATE exception logs and process termination logs. ALERT if (process_name NOT IN (allow_list)) AND (exception_code = '0x80000004') AND (process does not terminate shortly after).
  - question: Is a process showing a statistically unusual increase in the ratio of handled-to-unhandled exceptions, particularly for debug-related exception codes?
    context: This question uses statistical baselining to detect anomalous exception handling. Normal programs have a predictable rate of exceptions, most of which might be unhandled crashes. Malware performing anti-analysis checks will intentionally trigger and then handle exceptions, leading to a higher ratio of handled exceptions. By baselining this ratio for each executable, a significant spike, especially for codes like single-step or breakpoints, can indicate that the process is actively checking for a debugger.
    answer_sources:
      - EDR Telemetry (Exception Events)
      - Windows Event ID 1000 (Application Error)
      - Windows Event ID 1001 (Windows Error Reporting)
      - All Windows endpoints, especially those not used for software development
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. BASELINE the ratio of (handled_exceptions / unhandled_exceptions) per process_name. 2. MONITOR for new exception events. 3. ALERT if the ratio for a process significantly deviates from its baseline.
  - question: Can a machine learning model be trained to recognize anomalous sequences of system events, such as a debug-related exception followed by continued execution?
    context: This question proposes an advanced anomaly detection approach using models like Autoencoders. The model is trained on 'normal' sequences of process events (e.g., module loads, file access, termination). A sequence containing a debug-related exception that is handled and followed by continued normal activity would be a pattern the model has not seen before. It would flag this sequence as an anomaly with a high reconstruction error, effectively identifying the anti-debugging behavior without needing explicit rules.
    answer_sources:
      - EDR Telemetry (Exception Events)
      - Windows Event ID 1000 (Application Error)
      - Windows Event ID 1001 (Windows Error Reporting)
      - All Windows endpoints, especially those not used for software development
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. TRAIN an autoencoder on normal sequences of process events (exceptions, terminations, etc.). 2. FEED new event sequences into the model. 3. ALERT if the model's reconstruction error for a sequence is high.
  - question: Is a process running on an endpoint that has a file hash matching a known malware sample with debugger evasion capabilities?
    context: This is a fundamental threat intelligence question. The most direct way to identify a threat is to see if it's already known. By automatically checking the hash (e.g., SHA256) of every new executable against a threat intelligence feed, we can immediately identify known malware. If the intelligence indicates the malware sample uses 'Debugger Evasion' or 'Anti-Analysis' techniques, the alert can be enriched with this context, confirming the adversary's intent to perform discovery and evade analysis.
    answer_sources:
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 4688
      - All Windows endpoints and servers
      - Email gateways
      - Web proxies
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: ON process creation, LOOKUP process_hash in threat intelligence database. ALERT if match found. ENRICH alert with malware capabilities like 'Debugger-Evasion'.
  - question: Are there rare or 'first-seen' executables in the environment that should be prioritized for a threat intelligence lookup?
    context: This question focuses on identifying novel threats by tracking file prevalence. Commodity malware might be seen on many hosts, but targeted or new malware will be rare. By maintaining a census of all file hashes, any hash that is seen for the first time or is present on a very small number of hosts (e.g., fewer than five) is inherently more suspicious. These 'low-prevalence' hashes should be automatically submitted to threat intelligence platforms for deeper analysis, as they are more likely to be part of a new or targeted campaign.
    answer_sources:
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 4688
      - All Windows endpoints and servers
      - Email gateways
      - Web proxies
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. MAINTAIN a database of all seen file hashes and their host count. 2. ON new process creation, check prevalence. 3. IF host_count < 5, SUBMIT hash to threat intelligence for analysis.
  - question: Can a static analysis model identify potentially malicious executables, whose hashes can then be verified against threat intelligence?
    context: This question describes a proactive, pre-execution detection strategy. Instead of waiting for a hash to appear in a threat feed, a machine learning model can analyze the characteristics of the executable file itself (e.g., PE header anomalies, high section entropy, suspicious strings). Files that the model scores as 'likely malicious' can be flagged, and their hashes can be automatically submitted for threat intelligence lookup to confirm the finding and gather more context on the threat family and its capabilities, such as debugger evasion.
    answer_sources:
      - Windows Event ID 1 (Sysmon)
      - Windows Event ID 4688
      - All Windows endpoints and servers
      - Email gateways
      - Web proxies
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. ON new file creation, ANALYZE file with static ML model. 2. IF score > malicious_threshold, SUBMIT hash to threat intelligence for confirmation.
  - question: Is a single process rapidly spawning multiple child processes to search for running debugger applications?
    context: This question targets a common discovery behavior where malware quickly runs several commands to enumerate running processes, specifically looking for the names of analysis tools. A single parent process spawning a burst of child processes (e.g., more than three in 30 seconds) that execute commands like 'tasklist' or 'wmic process get' and pipe the output to find strings like 'x64dbg' or 'windbg' is a strong indication that the parent process is actively checking for a sandbox or analysis environment.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - All Windows endpoints and servers
      - Domain Controllers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: GROUP process creation events by ParentProcessGuid over 30s. ALERT if count > 3 AND child_command_line CONTAINS ('tasklist', 'wmic process get', 'x64dbg', etc.).
  - question: Is a parent process spawning a statistically anomalous number of discovery-related child processes compared to a baseline?
    context: This question uses statistical analysis to detect abnormal process-spawning behavior. Legitimate administrative scripts might spawn some discovery commands, so a baseline of normal activity is needed. By counting the number of discovery-related child processes spawned by each parent process in a short time window and comparing it to the established norm, we can alert when a process's activity exceeds a high percentile (e.g., 99th). This approach effectively distinguishes malicious bursts of discovery from routine administrative tasks.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - All Windows endpoints and servers
      - Domain Controllers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. BASELINE the count of discovery-tool child processes per parent per minute. 2. MONITOR new process creation events. 3. ALERT if a parent's child process count exceeds the 99th percentile of the baseline.
  - question: Is a user or host executing a sequence of commands that is highly improbable based on models of normal behavior?
    context: This question looks beyond simple counts to the order and combination of commands. Normal user and system behavior follows predictable patterns. A sequence analysis model (like a Markov Chain or LSTM) can be trained on these normal sequences. An adversary performing discovery will likely execute a sequence of commands (e.g., `whoami` -> `tasklist | findstr "windbg"` -> `net view`) that is statistically unlikely to occur in normal operations. The model would flag this low-probability sequence as anomalous, pointing to potential malicious discovery.
    answer_sources:
      - Windows Event ID 4688
      - Windows Event ID 1 (Sysmon)
      - All Windows endpoints and servers
      - Domain Controllers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. TRAIN a sequence model (e.g., Markov Chain) on normal command-line sequences per user/host. 2. SCORE new command sequences against the model. 3. ALERT if the sequence probability is below a critical threshold.
  - question: Is a host exhibiting a correlated pattern of local discovery, followed by internal network scanning and unusual DNS activity?
    context: This question connects host-based and network-based indicators to identify a common attack chain. An adversary will often first perform local discovery (like checking for debuggers with 'tasklist') to ensure the environment is 'safe', and then immediately begin lateral movement activities like network scanning (seen in Zeek conn.log as connections to many internal IPs) and C2 discovery (which can generate failed internal DNS lookups). Correlating these three distinct activities from a single host within a short time window (e.g., 5 minutes) provides a high-confidence alert for an active intrusion.
    answer_sources:
      - Windows Event ID 4688
      - Zeek conn.log
      - Zeek dns.log
      - Core network switches (for SPAN/TAP port)
      - DNS servers
      - All Windows endpoints and servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: CORRELATE events by source_ip over 5 mins. ALERT if (process_event for discovery) AND (network_connections to >10 internal IPs) AND (high ratio of NXDOMAIN DNS responses) occur.
  - question: Does a host's combined discovery and network activity exceed a statistically significant risk score?
    context: This question quantifies a host's suspicious behavior by assigning it a risk score. Instead of a rigid rule, this method aggregates weighted evidence over time. Each discovery command, each unique internal network connection, and each failed DNS lookup adds to the host's 'Discovery and Lateral Movement Score'. By alerting when this composite score becomes a statistical outlier (e.g., more than 3 standard deviations above the average), we can dynamically detect hosts that are behaving abnormally across both host and network telemetry.
    answer_sources:
      - Windows Event ID 4688
      - Zeek conn.log
      - Zeek dns.log
      - Core network switches (for SPAN/TAP port)
      - DNS servers
      - All Windows endpoints and servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. For each host, CALCULATE a risk score based on weighted counts of discovery commands, network scans, and DNS failures over a 10-min window. 2. ALERT if host_score > (mean_score + 3 * std_dev).
  - question: Can an unsupervised machine learning model identify hosts with an anomalous profile of combined host and network discovery activity?
    context: This question proposes a sophisticated, multi-dimensional anomaly detection approach. A host's behavior is represented as a feature vector containing metrics like discovery command counts, network scan fan-out (unique IPs contacted), and DNS query statistics. An algorithm like Isolation Forest can then efficiently identify which vectors (hosts) are 'different' from the majority without being trained on what is 'bad'. This allows for the detection of novel or complex attack patterns that combine host and network behaviors in ways not anticipated by predefined rules or scoring systems.
    answer_sources:
      - Windows Event ID 4688
      - Zeek conn.log
      - Zeek dns.log
      - Core network switches (for SPAN/TAP port)
      - DNS servers
      - All Windows endpoints and servers
    range: last 90 days
    queries:
      - search_technology: pseudocode
        query: 1. For each host, CREATE a feature vector (discovery_cmd_count, network_fan_out, nxdomain_ratio, etc.). 2. INPUT vectors into an anomaly detection model (e.g., Isolation Forest). 3. INVESTIGATE hosts flagged as anomalous.