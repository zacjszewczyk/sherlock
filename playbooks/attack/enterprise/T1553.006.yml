name: T1553.006: Code Signing Policy Modification
id: c8f9b1a2-3d4e-4f56-a7b8-9c0d1e2f3a4b
description: This playbook helps investigate attempts by adversaries to evade defenses by modifying code signing policies. Such modifications can allow the loading of unsigned or improperly signed code, bypassing a critical security control. The investigation focuses on identifying the execution of known policy modification tools, specific command-line arguments that disable or weaken signing requirements (e.g., `bcdedit.exe /set testsigning on`), direct manipulation of code integrity registry keys, and correlated event sequences like a policy change followed by a system reboot and an unsigned driver load. It also covers the advanced 'Bring Your Own Vulnerable Driver' (BYOVD) technique, where a legitimate but vulnerable driver is used to load a malicious one.
type: technique
related:
- TA0005: Defense Evasion
contributors:
- Zachary Szewczyk
- Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
- question: Has a known code signing policy modification tool been executed?
  context: This question aims to identify the execution of tools specifically designed to disable or bypass code signing policies, such as KDU or DSEFix. A match against a known malicious hash from a threat intelligence feed is a high-confidence indicator of an attempt to weaken system defenses to allow unsigned code execution.
  answer_sources:
  - Windows Event ID 4688
  - Sysmon Event ID 1
  - Zeek files.log
  - Developer Workstations
  - System Administrator Workstations
  - Critical Servers
  - Network Egress Points
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH process_creation_logs OR file_analysis_logs | JOIN file_hash with threat_intelligence_feed_of_code_signing_tools | WHERE match_found RETURN hostname, process_name, file_hash, timestamp
- question: Has a rare or unique process been observed modifying code signing policies?
  context: Adversaries often use custom or rare tools to avoid signature-based detection. This question focuses on identifying processes that perform actions related to code signing policy modification (like specific command-line arguments or registry changes) and are also statistically rare across the enterprise. A rare executable performing sensitive actions is highly suspicious.
  answer_sources:
  - Windows Event ID 4688
  - Sysmon Event ID 1
  - Zeek files.log
  - Developer Workstations
  - System Administrator Workstations
  - Critical Servers
  - Network Egress Points
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH process_creation_logs | WHERE process_modifies_code_signing_policy | CALCULATE prevalence(file_hash) across all_hosts | WHERE prevalence_percentile <= 1 RETURN hostname, process_name, file_hash, command_line
- question: Has a machine learning model identified a process execution as a likely attempt to modify code signing policies?
  context: This question leverages a predictive model to score process executions based on various features like parent-child relationships, file path, command-line structure, and file entropy. It aims to proactively detect novel or obfuscated techniques for modifying code signing policies that might not match simple rules or IOCs.
  answer_sources:
  - Windows Event ID 4688
  - Sysmon Event ID 1
  - Zeek files.log
  - Developer Workstations
  - System Administrator Workstations
  - Critical Servers
  - Network Egress Points
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: STREAM process_creation_events | APPLY ML_model_for_code_signing_modification | WHERE prediction_score > high_confidence_threshold RETURN hostname, process_name, parent_process, command_line, score
- question: Was a command-line utility like `bcdedit.exe` or `csrutil` used to explicitly disable or weaken code signing policies?
  context: This question looks for direct evidence of an adversary using built-in system utilities to turn off code integrity checks. Commands like `bcdedit /set testsigning on` or `csrutil disable` are explicit indicators of an attempt to create an environment where unsigned code can be loaded, which is a common precursor to loading malicious drivers or rootkits.
  answer_sources:
  - Windows Event ID 4688
  - Sysmon Event ID 1
  - Domain Controllers
  - Developer Workstations
  - Endpoint fleet
  - macOS systems
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH process_creation_logs | REGEX command_line matches "(?i)(bcdedit|csrutil).*(testsigning|nointegritychecks|disable)" | RETURN hostname, user, process_name, command_line
- question: Has a user executed an unusual or rare variation of a code signing modification command?
  context: While administrators might use tools like `bcdedit.exe` for legitimate purposes, their usage patterns are typically consistent. This question aims to detect anomalous usage by baselining normal command-line patterns for each user and the organization as a whole. A command that is rare for a specific user and rare globally is highly suspicious and could indicate misuse or compromise.
  answer_sources:
  - Windows Event ID 4688
  - Sysmon Event ID 1
  - Domain Controllers
  - Developer Workstations
  - Endpoint fleet
  - macOS systems
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH process_creation_logs where process_name is "bcdedit.exe" | CALCULATE rarity_score(command_line) based on user_history and global_history | WHERE rarity_score > threshold RETURN hostname, user, command_line, score
- question: Have any outlier or novel command-line arguments been used to modify code signing policies?
  context: This question uses unsupervised machine learning to find new or obfuscated command-line arguments that don't match known patterns. By clustering all observed commands, single-member clusters (outliers) can represent unique, potentially malicious attempts that would be missed by signature-based rules.
  answer_sources:
  - Windows Event ID 4688
  - Sysmon Event ID 1
  - Domain Controllers
  - Developer Workstations
  - Endpoint fleet
  - macOS systems
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH process_creation_logs where process_name is "bcdedit.exe" | VECTORIZE command_line | CLUSTER vectors using DBSCAN | WHERE cluster_size == 1 RETURN hostname, user, command_line
- question: Have critical registry keys controlling code integrity been modified?
  context: This question targets direct manipulation of the Windows registry to disable or alter code signing policies. Modifications to keys like `HKLM\SYSTEM\CurrentControlSet\Control\CI\Config` are a direct method for adversaries to bypass driver signature enforcement without using command-line tools, making it a crucial event to monitor.
  answer_sources:
  - Windows Event ID 4657
  - Sysmon Event ID 13
  - All Windows Endpoints and Servers
  - Active Directory Certificate Services Servers
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH registry_modification_logs | WHERE registry_key in ["HKLM\...\CI\Config", "HKLM\...\CI\Policy"] and operation in ["write", "delete"] | RETURN hostname, process_name, registry_key, value_changed
- question: Was a code integrity registry key modified by a process executing from a suspicious or randomized file path?
  context: Legitimate system tools that modify sensitive registry keys typically reside in standard system directories (e.g., `C:\Windows\System32`). Adversaries often place their tools in temporary, user-writable, or randomized paths. This question seeks to identify modifications made by processes with high-entropy file paths, which suggests an attempt to evade detection.
  answer_sources:
  - Windows Event ID 4657
  - Sysmon Event ID 13
  - All Windows Endpoints and Servers
  - Active Directory Certificate Services Servers
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH registry_modification_logs | WHERE registry_key is related_to_code_signing | CALCULATE entropy(process_path) | WHERE entropy > baseline_threshold RETURN hostname, process_name, process_path, registry_key
- question: Has there been an anomalous spike in modifications to code signing registry keys?
  context: Modifications to these critical registry keys should be rare and predictable. This question uses time-series analysis to model the normal rate of these events and detect any unusual bursts of activity. A sudden increase in modifications that exceeds the predicted baseline could indicate a widespread or automated attack.
  answer_sources:
  - Windows Event ID 4657
  - Sysmon Event ID 13
  - All Windows Endpoints and Servers
  - Active Directory Certificate Services Servers
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: AGGREGATE count(registry_modification_events) over time | APPLY time_series_model | WHERE actual_count > predicted_upper_bound RETURN time_window, actual_count, predicted_count
- question: Has a system been rebooted to activate a weakened code signing policy, followed by the loading of an unsigned driver?
  context: Many code signing policy changes require a system reboot to take effect. This question looks for a specific sequence of events: a policy modification, a reboot, and the subsequent loading of an unsigned driver. This chain of events is a strong indicator that the policy change was made specifically to enable the loading of a malicious or unauthorized driver.
  answer_sources:
  - Windows Event ID 5038
  - Sysmon Event ID 6
  - Windows Event ID 6006
  - Sysmon Event ID 1
  - Zeek conn.log
  - All Windows Endpoints
  - especially developer and administrator workstations
  - Virtual Desktop Infrastructure (VDI) fleet
  range: Last 30 minutes
  queries:
  - technology: pseudocode
    query: CORRELATE on hostname over 30m: (event_A: code_signing_policy_mod) -> (event_B: reboot) -> (event_C: unsigned_driver_load) | RETURN hostname, timestamp_A, timestamp_B, timestamp_C, driver_name
- question: Are any hosts loading an unusually high number of unsigned drivers?
  context: A host that consistently loads a high volume of unsigned drivers compared to its peers may have had its code signing policy permanently disabled. This question identifies such outliers across the enterprise, which could indicate a persistent compromise or a severe misconfiguration that an adversary could exploit.
  answer_sources:
  - Windows Event ID 5038
  - Sysmon Event ID 6
  - Windows Event ID 6006
  - Sysmon Event ID 1
  - Zeek conn.log
  - All Windows Endpoints
  - especially developer and administrator workstations
  - Virtual Desktop Infrastructure (VDI) fleet
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH driver_load_logs where signed is false | AGGREGATE count per day per host | CALCULATE percentile(daily_count) across all_hosts | WHERE percentile >= 99 RETURN hostname, date, unsigned_driver_count
- question: Has a sequence of endpoint events occurred that is statistically unlikely and involves a code signing policy modification?
  context: This question uses a probabilistic model (HMM) to learn the "normal" sequences of events on a healthy system. It then flags new event sequences that deviate significantly from this learned normal, particularly when the anomalous sequence includes the specific state transitions from policy modification to reboot to unsigned driver load. This can detect sophisticated attacks that blend in with other system noise.
  answer_sources:
  - Windows Event ID 5038
  - Sysmon Event ID 6
  - Windows Event ID 6006
  - Sysmon Event ID 1
  - Zeek conn.log
  - All Windows Endpoints
  - especially developer and administrator workstations
  - Virtual Desktop Infrastructure (VDI) fleet
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: STREAM endpoint_event_sequences | APPLY HMM_benign_model | WHERE sequence_probability < low_prob_threshold AND sequence_contains(policy_mod, reboot, unsigned_driver_load) RETURN hostname, event_sequence, probability_score
- question: Has a known vulnerable driver been loaded immediately before an unsigned or anomalously signed driver, indicating a potential 'Bring Your Own Vulnerable Driver' (BYOVD) attack?
  context: In a BYOVD attack, adversaries use a legitimately signed but vulnerable driver to gain kernel-level access, which they then use to load their own malicious, unsigned driver. This question specifically looks for this two-step sequence: the loading of a driver from a known-vulnerable list followed closely by the loading of an unsigned driver on the same host.
  answer_sources:
  - Windows Event ID 7045
  - Sysmon Event ID 6
  - Sysmon Event ID 7
  - Zeek x509.log
  - High-Value Target Workstations
  - Domain Controllers
  - Servers running Endpoint Detection and Response (EDR) agents
  range: Last 5 minutes
  queries:
  - technology: pseudocode
    query: CORRELATE on hostname over 5m: (event_A: vulnerable_driver_load) -> (event_B: unsigned_driver_load) | RETURN hostname, vulnerable_driver_name, unsigned_driver_name, timestamp
- question: Following the load of a vulnerable driver, was another driver loaded that was signed by a rare or previously unseen certificate issuer?
  context: Adversaries in a BYOVD attack might self-sign their malicious driver. While signed, the certificate issuer would be highly unusual for the enterprise. This question identifies scenarios where a vulnerable driver is loaded, followed by another driver whose signing authority is statistically rare, which is a strong indicator of a malicious self-signed driver.
  answer_sources:
  - Windows Event ID 7045
  - Sysmon Event ID 6
  - Sysmon Event ID 7
  - Zeek x509.log
  - High-Value Target Workstations
  - Domain Controllers
  - Servers running Endpoint Detection and Response (EDR) agents
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH driver_load_events | IF vulnerable_driver_loaded THEN LOOK for subsequent driver_load on same host | CALCULATE rarity(subsequent_driver_issuer) | WHERE rarity_percentile <= 1 RETURN hostname, vulnerable_driver, subsequent_driver, rare_issuer
- question: Does process and file activity data reveal a causal graph pattern matching a BYOVD attack?
  context: This question moves beyond simple event correlation to model the causal relationships between processes and files. It aims to detect the specific graph structure of a BYOVD attack: a process loading a known vulnerable driver, which in turn leads to the modification of the kernel or the loading of a second, malicious (e.g., unsigned) driver. This approach can uncover the full attack chain.
  answer_sources:
  - Windows Event ID 7045
  - Sysmon Event ID 6
  - Sysmon Event ID 7
  - Zeek x509.log
  - High-Value Target Workstations
  - Domain Controllers
  - Servers running Endpoint Detection and Response (EDR) agents
  range: Last 90 days
  queries:
  - technology: pseudocode
    query: SEARCH causality_graph for pattern: (Process)-[:LOADS]->(Driver {hash:vulnerable_hash})-[:LOADS]->(Driver {signed:false}) RETURN Process, VulnerableDriver, MaliciousDriver