name: T1547.006: Kernel Modules and Extensions
id: f8e4e9a0-1b2c-4d5e-8f6a-7b8c9d0e1f2a
description: This playbook helps investigate whether an adversary is maintaining persistence or escalating privileges by loading malicious kernel modules or extensions. Adversaries exploit this technique across Windows, Linux, and macOS to gain high-level, persistent access. Detections focus on identifying the loading of unsigned, anomalously located, or known-malicious drivers/modules (e.g., via Windows services, `insmod`/`modprobe` on Linux, `kextload` on macOS). A key tactic is "Bring Your Own Vulnerable Driver" (BYOVD), where non-administrative users load a known-vulnerable driver to gain system-level access. Investigations should correlate module/driver load events with suspicious subsequent network activity, process creation with elevated privileges (e.g., integrity level changes on Windows, EUID changes on Linux), and anomalous command-line arguments for system utilities.
type: technique
related:
- TA0003: Persistence
- TA0004: Privilege Escalation
contributors:
- Zachary Szewczyk
- Ask Sage
created: 2025-10-01
modified: 2025-10-01
version: 1.0
tags: none
questions:
- question: Is a new Windows service being created for a kernel driver that is either unsigned or has a hash matching known malware?
  context: Adversaries often use malicious kernel drivers for persistence with the highest privileges. This question directly checks for the creation of services pointing to such drivers. An unsigned driver or a driver with a known malicious hash is a high-fidelity indicator of compromise.
  answer_sources:
  - Windows Event ID 7045
  - Windows Event ID 4688
  - Windows Sysmon Event ID 6
  - Windows endpoint and server fleet, including Domain Controllers and application servers; System driver directories (%SystemRoot%\System32\drivers) for baselining.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="WinEventLog:System", event_id=7045, service_type="kernel driver") | foreach(event): if (is_unsigned(event.image_path) or hash(event.image_path) in threat_intel): alert
- question: Is a new kernel driver being loaded from an unusual or statistically rare directory?
  context: Legitimate drivers are almost always located in standard system directories like C:\Windows\System32\drivers. Adversaries may place malicious drivers in temporary or user-writable locations (e.g., C:\Temp, C:\Users\) to evade detection. This question identifies such outliers by comparing new driver paths against a historical baseline.
  answer_sources:
  - Windows Event ID 7045
  - Windows Sysmon Event ID 6
  - Windows endpoint and server fleet, including Domain Controllers and application servers; System driver directories (%SystemRoot%\System32\drivers) for baselining.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="WinEventLog:System", event_id=7045 or source="Sysmon", event_id=6) | baseline(directory(event.image_path), over=90d) | foreach(new_event): if (rarity(directory(new_event.image_path)) < 0.05): alert
- question: Can we classify a newly loaded kernel driver as malicious based on its characteristics?
  context: This question uses a machine learning approach to proactively identify malicious drivers. By combining features like digital signature status, file path rarity, service name entropy, and inclusion in a known-good corpus, a model can learn to distinguish legitimate drivers from malicious ones, even if the specific malware has not been seen before.
  answer_sources:
  - Windows Event ID 7045
  - Windows Event ID 4688
  - Windows Sysmon Event ID 6
  - Windows endpoint and server fleet, including Domain Controllers and application servers; System driver directories (%SystemRoot%\System32\drivers) for baselining.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: stream(source="Sysmon", event_id=6) | featurize(event.image_path, event.service_name) | predict(ml_model="driver_classifier") | if (prediction.score > 0.9): alert
- question: Did a host initiate network connections to a known malicious destination shortly after a new kernel driver was loaded?
  context: Malicious kernel drivers often serve as backdoors or implants that need to communicate with a command-and-control (C2) server. This question seeks to identify this behavior by correlating a driver load event with subsequent network traffic to destinations listed in threat intelligence feeds, such as known C2 servers or newly registered domains (NRDs).
  answer_sources:
  - Zeek conn.log
  - Zeek dns.log
  - Windows Event ID 7036
  - Windows Sysmon Event ID 3
  - Network egress points, DNS servers, and all Windows hosts.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: join(type=outer, on=hostname, time_window=5m) [search(source="Sysmon", event_id=6)] [search(source="zeek_conn")] | if (conn.dest_ip in threat_intel or conn.dest_domain is NRD): alert
- question: Does a host's network traffic exhibit anomalous characteristics (e.g., high-entropy domains, unusual outbound data ratios) within an hour of a new kernel driver being loaded?
  context: Even if a destination isn't on a known threat list, C2 communication can have distinct patterns. This question looks for statistical anomalies like connections to algorithmically generated domains (high entropy) or unusual data exfiltration patterns (high outbound/inbound ratio) that may indicate malicious activity following a driver load.
  answer_sources:
  - Zeek conn.log
  - Zeek dns.log
  - Windows Event ID 7036
  - Windows Sysmon Event ID 3
  - Network egress points, DNS servers, and all Windows hosts.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="Sysmon", event_id=6) | for_each(event): analyze_network_traffic(host=event.hostname, start_time=event.time, duration=1h) | compare_to_baseline(host=event.hostname, over=30d) | if (entropy > 3*std_dev or outbound_ratio > 3*std_dev): alert
- question: Did a host's outbound data volume significantly deviate from its predicted forecast after a new kernel driver was loaded?
  context: This question uses time-series analysis to detect subtle changes in network behavior. A malicious driver might initiate data exfiltration or beaconing that, while not immediately obvious, creates a statistically significant spike in outbound traffic compared to the host's normal, learned behavior.
  answer_sources:
  - Zeek conn.log
  - Zeek dns.log
  - Windows Event ID 7036
  - Windows Sysmon Event ID 3
  - Network egress points, DNS servers, and all Windows hosts.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="Sysmon", event_id=6) | for_each(event): get_actual_traffic(host=event.hostname, time=event.time) | get_predicted_traffic(model="ARIMA", host=event.hostname, time=event.time) | if (abs(actual - predicted) > threshold): alert
- question: Was a Linux kernel module loaded using `insmod` or `modprobe` from a non-standard directory like /tmp or a user's home directory?
  context: Legitimate kernel modules are managed by the system and reside in standard paths. An adversary loading a module from a temporary or user-writable directory is highly suspicious and often indicates the introduction of a rootkit for persistence.
  answer_sources:
  - Linux auditd logs (type=EXECVE, type=SYSCALL for init_module)
  - Package manager logs (/var/log/apt/history.log, /var/log/yum.log)
  - Zeek conn.log
  - Critical Linux server fleet (e.g., web servers, database servers, container hosts); Linux file systems, specifically /tmp, /var/tmp, user home directories, and standard module paths like /lib/modules.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="auditd", type="EXECVE", command in ["insmod", "modprobe"]) | if (argument_path in ["/tmp/*", "/dev/shm/*", "/home/*"]): alert
- question: Is a kernel module loaded on a Linux host that is statistically rare or unique across the entire server fleet?
  context: In a managed environment, servers with similar roles should have similar sets of loaded kernel modules. This question identifies outliers by baselining module usage across the fleet. A module that is present on only one or a very small number of hosts could be an unauthorized or malicious implant.
  answer_sources:
  - Linux auditd logs (type=EXECVE, type=SYSCALL for init_module)
  - Package manager logs (/var/log/apt/history.log, /var/log/yum.log)
  - Zeek conn.log
  - Critical Linux server fleet (e.g., web servers, database servers, container hosts); Linux file systems, specifically /tmp, /var/tmp, user home directories, and standard module paths like /lib/modules.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: run_command("lsmod") on all hosts | aggregate(module_name) | calculate_prevalence | foreach(module): if (module.prevalence < 0.01): alert
- question: Can we classify a kernel module loading event on Linux as suspicious based on its execution context?
  context: The context of a module load provides crucial clues. Legitimate loads are typically performed by package managers during updates, while malicious loads might be initiated by an interactive shell or a compromised service. This question uses a model to analyze features like the parent process and command-line arguments to distinguish between these scenarios.
  answer_sources:
  - Linux auditd logs (type=EXECVE, type=SYSCALL for init_module)
  - Package manager logs (/var/log/apt/history.log, /var/log/yum.log)
  - Zeek conn.log
  - Critical Linux server fleet (e.g., web servers, database servers, container hosts); Linux file systems, specifically /tmp, /var/tmp, user home directories, and standard module paths like /lib/modules.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: stream(source="auditd", type="EXECVE", command in ["insmod", "modprobe"]) | featurize(event.parent_process, event.arguments, event.is_interactive) | predict(ml_model="module_load_classifier") | if (prediction == "suspicious"): alert
- question: Was a kernel extension loaded on macOS using `kextload` that is either unsigned or signed by a developer ID not on our approved allow-list?
  context: macOS enforces strict code signing requirements for kernel extensions (kexts). An unsigned kext or one signed by an unknown or untrusted developer is a major security risk and a strong indicator of a malicious attempt to gain deep system access.
  answer_sources:
  - macOS Unified Logs (process == 'kextload')
  - Zeek conn.log
  - Zeek dns.log
  - macOS endpoint fleet, especially developer and executive workstations; Network egress points and DNS servers.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="macOS_unified_logs", process="kextload") | for_each(event): get_signature(event.kext_path) | if (signature.is_valid == false or signature.developer_id not in allow_list): alert
- question: Has a kernel extension been loaded on a macOS host that has never been seen on that specific host before?
  context: While new software installations are common, the set of kernel extensions on a stable machine changes infrequently. This question establishes a per-host baseline of known kexts and alerts on the first appearance of a new one, providing an opportunity to investigate potentially unwanted or malicious software.
  answer_sources:
  - macOS Unified Logs (process == 'kextload')
  - Zeek conn.log
  - Zeek dns.log
  - macOS endpoint fleet, especially developer and executive workstations; Network egress points and DNS servers.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="macOS_unified_logs", process="kextload") | stateful_lookup(key=hostname, field=event.bundle_id) | if (event.bundle_id is new for hostname): alert
- question: Is there a statistically anomalous spike in the number of `kextload` events on a macOS host?
  context: Legitimate software installations might load one or two kexts. A sudden flurry of `kextload` events could indicate a malicious installer or a script attempting to load multiple components of a rootkit. This question uses time-series analysis to detect such unusual bursts of activity.
  answer_sources:
  - macOS Unified Logs (process == 'kextload')
  - Zeek conn.log
  - Zeek dns.log
  - macOS endpoint fleet, especially developer and executive workstations; Network egress points and DNS servers.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="macOS_unified_logs", process="kextload") | time_bucket(1d, by=hostname) | count() | predict_anomaly(model="LSTM", series=count) | if (is_anomaly): alert
- question: Did a non-administrative user attempt to load a kernel driver whose hash matches a known vulnerable driver?
  context: The "Bring Your Own Vulnerable Driver" (BYOVD) technique allows a low-privileged attacker to load a legitimate but vulnerable driver to exploit it and gain kernel-level access. This question directly hunts for this activity by checking if low-privileged users are interacting with drivers on a known-vulnerable watchlist (e.g., loldrivers.io).
  answer_sources:
  - Windows Event ID 4688
  - Windows Event ID 7045
  - Windows Sysmon Event ID 1
  - Multi-user Windows workstations and servers (e.g., Remote Desktop Session Hosts).
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="Sysmon", event_id=1, process in ["sc.exe", "fltmc.exe"]) | if (user.is_admin == false and hash(event.argument_file) in vulnerable_driver_list): alert
- question: Has a non-administrative user account executed `sc.exe` to create or load a kernel service?
  context: Standard users have no legitimate reason to create system services, especially kernel drivers. This activity is almost always unauthorized and a strong indicator of a privilege escalation attempt. This question establishes a zero-tolerance baseline for this behavior.
  answer_sources:
  - Windows Event ID 4688
  - Windows Event ID 7045
  - Windows Sysmon Event ID 1
  - Multi-user Windows workstations and servers (e.g., Remote Desktop Session Hosts).
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="Sysmon", event_id=1, process="sc.exe", command_line contains ["create", "type=kernel", "load"]) | if (user.is_admin == false): alert
- question: Has a non-administrative user session exhibited a sequence of actions characteristic of a BYOVD attack, such as downloading a driver, creating a service for it, and then spawning a system-level shell?
  context: BYOVD attacks follow a predictable pattern. This question uses sequence analysis to detect the entire attack chain within a single user session, providing higher confidence than looking at any single event in isolation.
  answer_sources:
  - Windows Event ID 4688
  - Windows Event ID 7045
  - Windows Sysmon Event ID 1
  - Multi-user Windows workstations and servers (e.g., Remote Desktop Session Hosts).
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: stream(source="Sysmon", event_id=1) | group_by(session_id) | find_sequence([event="download .sys", user.is_admin=false], [event="sc.exe create", user.is_admin=false], [event="cmd.exe", integrity="System"]) | if (sequence_found): alert
- question: Did a process running at a 'Medium' or 'Low' integrity level spawn a child process running at a 'High' or 'System' integrity level?
  context: Windows Integrity Levels are a security mechanism to contain processes. A direct jump from a lower to a higher integrity level (outside of normal, brokered UAC prompts via processes like consent.exe) is a classic sign of privilege escalation, often resulting from a successful exploit involving kernel drivers.
  answer_sources:
  - Windows Event ID 4688
  - Windows Sysmon Event ID 1
  - All Windows endpoints and servers.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="Sysmon", event_id=1) | if (parent.integrity_level in ["Medium", "Low"] and child.integrity_level in ["High", "System"] and parent.process not in uac_broker_list): alert
- question: Did a common parent process (e.g., `powershell.exe`) spawn a child process with 'System' integrity, when it has historically never done so?
  context: Most applications run at a standard integrity level and never spawn system-level children. This question baselines the normal behavior of every parent process and alerts on statistically improbable escalations, which can uncover novel exploitation techniques.
  answer_sources:
  - Windows Event ID 4688
  - Windows Sysmon Event ID 1
  - All Windows endpoints and servers.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="Sysmon", event_id=1) | baseline(parent_process, child_integrity_level, over=90d) | if (new_event.child_integrity_level == "System" and historical_probability(parent=new_event.parent, child_integrity="System") < 0.0001): alert
- question: Does a process creation event represent a rare or anomalous edge in the graph of parent-child relationships and their integrity levels?
  context: This question models the entire system's process creation activity as a large graph. By applying graph theory, we can identify highly unusual relationships (edges), such as a web browser spawning a system-level command prompt, that represent a likely privilege escalation and would be missed by simple rule-based alerts.
  answer_sources:
  - Windows Event ID 4688
  - Windows Sysmon Event ID 1
  - All Windows endpoints and servers.
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: stream(source="Sysmon", event_id=1) | build_graph(nodes=[process], edges=[parent, child, integrity_transition]) | find_anomalous_edges(graph) | if (is_anomaly): alert
- question: Did a non-root user session load a kernel module and then, shortly after, spawn a process with root privileges (EUID 0)?
  context: This is a direct hunt for a Linux privilege escalation chain. A non-root user loading a kernel module is suspicious; if that action is immediately followed by that same user gaining root, it is highly probable the module contained an exploit or backdoor.
  answer_sources:
  - Linux auditd logs (type=EXECVE, type=USER_START, type=SYSCALL for init_module)
  - Shared Linux environments (e.g., developer shell servers, multi-user systems).
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="auditd") | group_by(session_id) | find_sequence([event="insmod", euid!=0], [event="*", euid=0], time_window=5m) | if (sequence_found): alert
- question: Was a process created with an effective UID of 0 (root) by a parent process that was not running as root?
  context: Similar to Windows Integrity Levels, a change in Effective User ID (EUID) from a non-zero value to zero is a direct indicator of privilege escalation on Linux. This should only happen through legitimate, well-known mechanisms like `sudo`. This question flags all other unexpected transitions for review.
  answer_sources:
  - Linux auditd logs (type=EXECVE, type=USER_START, type=SYSCALL for init_module)
  - Shared Linux environments (e.g., developer shell servers, multi-user systems).
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: search(source="auditd", type="EXECVE") | if (parent.euid != 0 and child.euid == 0 and parent.process not in ["sudo", "su"]): alert
- question: Did a user's command sequence transition from a 'standard user' state to a 'root activity' state in a statistically improbable way, particularly after a rare command like `insmod`?
  context: This question uses a stateful model (e.g., a Hidden Markov Model) to understand the "grammar" of a user's session. The model learns normal patterns of behavior. A sequence that violates this learned grammar, such as using a rare command (`insmod`) and then immediately transitioning to a root state without a legitimate mechanism like `sudo`, is flagged as a highly suspicious anomaly.
  answer_sources:
  - Linux auditd logs (type=EXECVE, type=USER_START, type=SYSCALL for init_module)
  - Shared Linux environments (e.g., developer shell servers, multi-user systems).
  range: last 90 days
  queries:
  - search technology: pseudocode
    query: stream(source="auditd", type="EXECVE") | group_by(session_id) | analyze_sequence(model="HMM") | if (sequence_probability is low and state_transition == "user_to_root"): alert