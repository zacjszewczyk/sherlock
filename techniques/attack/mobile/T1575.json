[
  {
    "information_requirement": "Is an adversary using native code to obscure malicious activity on our mobile devices? (PIR)",
    "tactic_id": "TA0030",
    "tactic_name": "Defense Evasion",
    "indicators": [
      {
        "technique_id": "T1575",
        "name": "Native API",
        "evidence": [
          {
            "description": "An APK's native library (.so file) exhibits characteristics of packing or obfuscation, defined as: 1) a calculated Shannon entropy value greater than the 95th percentile for libraries of a comparable file size (+/- 10%), or 2) the library exports three or fewer JNI functions, with 'JNI_OnLoad' being one of them.",
            "data_sources": [
              "APK static analysis reports (JSON/XML)",
              "MDM application inventory logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate application vetting system (static analysis sandbox), MDM server application inventory database, and file systems of enrolled mobile devices.",
            "action": "1. (Symbolic) Query the application inventory for all native library (.so file) SHA256 hashes. Match these hashes against a threat intelligence feed of known malicious or packed libraries. Generate a critical alert for any match, including device and user details. 2. (Statistical) For each library with no IOC match, parse static analysis reports to extract its Shannon entropy and list of exported JNI functions. Compare the library's entropy to a pre-calculated 95th percentile baseline for libraries within the same file size bin (e.g., 0-100KB, 100-500KB, etc.). Additionally, flag any library that exports three or fewer JNI functions where 'JNI_OnLoad' is present. A finding on either metric warrants investigation. 3. (Machine Learning) Score all new or updated native libraries using a pre-trained binary classification model (e.g., Gradient Boosting). The model should use features such as file size, Shannon entropy, the count of imported and exported functions, and the presence of specific JNI functions. Escalate any library with a predicted malicious probability score greater than 0.85 for manual reverse engineering."
          },
          {
            "description": "A process associated with an Android application is observed loading a library from a non-standard, writable directory (e.g., /data/data/[app_name]/files, /sdcard/downloads) within 120 seconds after the device downloaded a file with a .so, .dex, or .jar extension from a low-reputation domain.",
            "data_sources": [
              "Android Logcat streams from MDM",
              "Zeek conn.log",
              "Zeek files.log",
              "Zeek dns.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Enterprise wireless and VPN network traffic inspection points, DNS resolvers, and real-time log streams from enrolled mobile endpoints.",
            "action": "1. (Symbolic) In the SIEM, create a correlation rule that joins Zeek dns.log, files.log, and Android Logcat data by device IP address and a 120-second time window. Generate a high-severity alert if a DNS query to a domain on a threat intelligence blocklist is followed by a download of a file ending in .so, .dex, or .jar, and a subsequent 'System.load' or 'System.loadLibrary' event from a path outside of the standard '/data/app/' directory. 2. (Statistical) For each application package name, establish a historical baseline of library load paths from Android Logcat data. Calculate the frequency of loads originating from non-standard, world-writable directories (e.g., '/sdcard/', '/data/local/tmp'). Alert if an application's rate of loading from non-standard paths exceeds the 99th percentile of its own 30-day behavioral baseline. 3. (Machine Learning) Implement a sequence analysis model (e.g., a Hidden Markov Model) trained on labeled event chains. Feed the model sequences of events per device, such as [DNS Query to new TLD -> File Download .so -> Library Load from /data/data/.../files]. Flag event sequences that have a high probability of matching a trained malicious pattern for analyst review."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "1.3",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is an adversary executing malicious commands or binaries on mobile devices via native code? (PIR)",
    "tactic_id": "TA0041",
    "tactic_name": "Execution",
    "indicators": [
      {
        "technique_id": "T1575",
        "name": "Native API",
        "evidence": [
          {
            "description": "A native library (.so file) from an APK contains evidence of command execution capabilities, defined as: 1) importing common execution-related C functions such as 'system', 'execve', 'execl', or 'execvp', or 2) containing embedded strings indicative of shell commands, such as '/system/bin/sh', 'su', 'pm install', 'am start', 'reboot', or 'setprop'.",
            "data_sources": [
              "APK static analysis reports (JSON/XML)",
              "MDM application inventory logs",
              "Mobile EDR process event logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate application vetting system (static analysis sandbox), Mobile EDR/MTP agent data, and MDM application inventory.",
            "action": "1. (Symbolic) During static analysis of an APK, scan all included native libraries for a blocklist of imported C functions ('system', 'execve') and embedded strings ('/bin/sh', 'su'). Compare the parent application's package name against an allowlist of approved tools that legitimately use these functions. Generate a medium-severity alert for any non-allowlisted application that contains these indicators. 2. (Statistical) Across the entire mobile application inventory, calculate the prevalence (as a percentage) of each suspicious imported function and embedded string. Assign a risk score to each library based on the inverse frequency of the indicators it contains (rarer indicators receive a higher score). Flag applications whose total risk score exceeds 3 standard deviations above the mean score for all applications in the enterprise. 3. (Machine Learning) Train a supervised classification model (e.g., Random Forest) to classify applications as 'potential native executor' or 'benign'. Use features from static analysis reports, including a binary flag for each suspicious function import, the count of shell-like strings, and the set of requested Android permissions. Escalate applications classified as a 'potential native executor' with high confidence (>0.90) to a dynamic analysis sandbox for behavioral observation."
          },
          {
            "description": "An application with one or more native libraries generates network traffic consistent with C2 beaconing. This is defined as repeated connections to the same destination IP address or domain with a low standard deviation in time intervals (jitter), small and consistent packet sizes (e.g., < 2KB), and a destination that is not on a known-good service allowlist.",
            "data_sources": [
              "Zeek conn.log",
              "Zeek dns.log",
              "MDM application inventory logs",
              "Mobile EDR network connection logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Network egress points (Firewall/Proxy), Enterprise DNS servers, VPN concentrators",
            "action": "1. (Symbolic) Ingest Zeek conn.log and dns.log into the SIEM and enrich with threat intelligence feeds. Generate a high-severity alert for any connection from a mobile device IP to a destination IP, domain, or JA3/JA4S hash on a known C2 blocklist. Correlate the device IP and timestamp with Mobile EDR logs to identify the responsible process and application. 2. (Statistical) For each source IP and destination IP pair in Zeek conn.log over a 24-hour window, calculate the standard deviation of the time delta between connections and the standard deviation of the 'orig_bytes' field. Create an alert for connections that exhibit low standard deviation in both metrics (e.g., time delta stddev < 1.5s, byte count stddev < 100 bytes), indicating programmatic regularity, and where the destination IP is not on an established commercial service allowlist (e.g., Google, Apple, AWS). 3. (Machine Learning) Apply an unsupervised clustering algorithm (e.g., DBSCAN) to network flow data from Zeek conn.log. Use features such as connection duration, total bytes, protocol, destination port, and the statistical measures from the previous step (jitter, size deviation). Isolate and investigate small, dense clusters of activity that are distinct from large clusters of benign traffic, as these often represent unidentified C2 channels. Correlate IPs in these anomalous clusters back to devices and applications."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "1.3",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]