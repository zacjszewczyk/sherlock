[
  {
    "information_requirement": "Is an adversary hiding malicious applications on our mobile devices by suppressing their icons? (TA0030 - Defense Evasion)",
    "tactic_id": "TA0030",
    "tactic_name": "Defense Evasion",
    "indicators": [
      {
        "technique_id": "T1628.001",
        "name": "Suppress Application Icon",
        "evidence": [
          {
            "description": "An application package is present in MDM application inventory logs but has no corresponding LAUNCHER intent activity in mobile EDR logs for the same device, indicating its icon is hidden.",
            "data_sources": [
              "MDM ApplicationInventory",
              "MobileEDR LauncherIntents",
              "ThreatIntel PackageNameFeeds",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate-owned and BYOD mobile endpoints, MDM/MTD Management Servers, SIEM Platform, Network Gateway",
            "action": "1. Symbolic: Execute a scheduled query to perform a left join from `MDM ApplicationInventory` logs (table A) to `MobileEDR LauncherIntents` logs (table B) on `device_id` and `package_name`. Alert on any `package_name` from table A where the join to table B is null. Before alerting, filter out packages on an allowlist of known legitimate non-launcher applications (e.g., system services, keyboard extensions). Enrich any remaining matches by checking the `package_name` against threat intelligence feeds. 2. Statistical: For all applications identified as lacking a launcher intent and not on the system allowlist, calculate their fleet-wide installation prevalence (count of unique devices). Maintain a distribution of prevalence scores for legitimate, non-launcher helper apps (e.g., plugins). Flag any new non-launcher application whose installation count exceeds the 99th percentile of this baseline distribution, as this indicates an anomalously widespread deployment. 3. Machine Learning: Deploy a logistic regression model to score the risk of non-launcher applications. Engineer features such as: count of dangerous permissions requested (from MDM logs), installation source (sideloaded vs. app store), and application age. For network features, correlate the `device_id` with internal IP addresses in `Zeek conn.log` to analyze traffic associated with the package. Calculate the Shannon entropy of destination IP addresses, $$ H(X) = -\\sum p(x) \\log_2 p(x) $$, and the ratio of connections to low-reputation domains. Flag applications with a predicted malice probability $$ P(malicious) > 0.8 $$ for analyst review."
          },
          {
            "description": "On an Android 10+ device, a mobile EDR process event shows a launcher process (e.g., 'com.google.android.apps.nexuslauncher') spawning the system settings process ('com.android.settings') with command-line arguments that directly open a specific application's details page.",
            "data_sources": [
              "MobileEDR ProcessEvents",
              "Android Logcat ActivityManager",
              "HelpDesk Tickets"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Managed mobile endpoints (Android 10+), EDR/SIEM log aggregation platform, IT Help Desk System",
            "action": "1. Symbolic: Create a SIEM correlation rule that triggers when a `MobileEDR ProcessEvents` log shows a `parent_process_name` matching a known launcher and `process_name` is 'com.android.settings' on the same `device_id` within a 1-second window. The rule must also validate that the `process_cmdline` contains strings like 'am start', 'com.android.settings.ApplicationDetailsPages', and 'package:'. Extract the package name from the command line and escalate for investigation. 2. Statistical: For each `package_name` identified via the symbolic rule, aggregate a daily count of these 'launcher -> settings page' redirection events. Calculate a 30-day moving average ($$ MA_{30} $$) and standard deviation ($$ \\sigma_{30} $$) for this event count. Generate an alert whenever the daily count for a specific application exceeds its historical baseline, defined as $$ MA_{30} + 3\\sigma_{30} $$, indicating a statistically significant increase in this behavior. 3. Machine Learning: Implement a sequence analysis model, such as a Hidden Markov Model (HMM), using `MobileEDR` process and UI event logs as input. Define states as distinct application activities (e.g., 'Launcher', 'Settings', 'Browser'). Train the model on event sequences from a baseline period to learn normal user navigation pathways and their transition probabilities. Identify the state transition from 'Launcher' directly to 'Application_Details_Settings' as a low-probability anomaly. If the anomaly score for this sequence surpasses a dynamically tuned threshold, create an alert."
          },
          {
            "description": "A static analysis report for an APK file shows the use of the `PackageManager.setComponentEnabledSetting` API call combined with the `COMPONENT_ENABLED_STATE_DISABLED` flag, where the target component in the AndroidManifest.xml is defined with both `android.intent.action.MAIN` and `android.intent.category.LAUNCHER` intents.",
            "data_sources": [
              "APK File Hashes",
              "Static Analysis Sandbox Reports",
              "Mobile App Reputation Service Logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Organizational application stores, Application vetting sandboxes, Developer CI/CD pipelines",
            "action": "1. Symbolic: Integrate a YARA rule into the application vetting pipeline that scans submitted APK files. The rule must identify the bytecode sequence for the `setComponentEnabledSetting` method call and the integer constant for `COMPONENT_ENABLED_STATE_DISABLED` (value: 2). If a match is found, the analysis engine must then parse the `AndroidManifest.xml` to confirm the targeted component has a LAUNCHER intent filter. A confirmed match automatically flags the application as malicious. 2. Statistical: For each new APK, extract a feature vector of all API calls and manifest permissions. For the new APK's feature set $$ A $$ and a baseline feature set from a corpus of known-benign apps $$ B $$, calculate the Jaccard distance $$ d_J(A, B) = 1 - \\frac{|A \\cap B|}{|A \\cup B|} $$. Separately, calculate the Shannon entropy of the `classes.dex` file. Flag an application as anomalous if it contains icon-hiding APIs, its Jaccard distance is in the top 5th percentile (highly dissimilar), and its code entropy is in the top 5th percentile (highly obfuscated). 3. Machine Learning: Train a gradient boosting classifier (e.g., XGBoost) on a labeled dataset of benign and malicious APKs. Use features including: presence of specific API calls (like `setComponentEnabledSetting`), count of dangerous permissions, presence of obfuscation markers, and reputation of embedded URLs. Deploy this model in the application vetting sandbox. Automatically reject any application with a malice score $$ > 0.9 $$ and quarantine any app with a score between $$ 0.7 $$ and $$ 0.9 $$ for manual analyst review."
          }
        ]
      }
    ],
    "version": "1.3",
    "date_created": "2025-09-26",
    "last_updated": "2025-09-29",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]