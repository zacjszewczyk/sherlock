[
  {
    "information_requirement": "Is an adversary collecting sensitive information from mobile device clipboards?",
    "tactic_id": "TA0035",
    "tactic_name": "Collection",
    "indicators": [
      {
        "technique_id": "T1414",
        "name": "Clipboard Data",
        "evidence": [
          {
            "description": "An Android application's disassembled code contains calls to `ClipboardManager.addPrimaryClipChangedListener`, but its `AndroidManifest.xml` file lacks the <intent-filter> for `android.view.inputmethod.InputMethod`, indicating it is not a legitimate input method editor (IME).",
            "data_sources": [
              "Static analysis output of APK (parsed AndroidManifest.xml, disassembled DEX files)",
              "MTD/MDM behavioral event logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Managed Android devices, Corporate application vetting pipeline, Mobile Device Management (MDM) server",
            "action": "Symbolic: During automated application vetting, parse the `AndroidManifest.xml` file to check for `<service>` declarations with an `<intent-filter>` for `android.view.inputmethod.InputMethod`. If this is absent, statically scan the application's DEX files for invocations of the `android.content.ClipboardManager.addPrimaryClipChangedListener` method. Generate an alert if a non-IME application contains this API call. Statistical: Using MTD logs, query to count clipboard access events per application package name over a 30-day window. Group applications by their functional category (e.g., social, finance, games). For each category, calculate the 95th percentile of daily clipboard access counts. Generate an alert for any application whose daily access count exceeds this peer-group-based threshold. Machine Learning: Train a supervised classification model (e.g., Random Forest) on a labeled dataset of benign and malicious APKs. Extract features during static analysis, including: boolean for `addPrimaryClipChangedListener` presence, count of dangerous permissions in the manifest, string obfuscation metrics (e.g., entropy of string constants), and the presence of dynamic code loading APIs (e.g., `DexClassLoader`). Use the trained model to assign a risk score to newly submitted applications during the vetting process."
          },
          {
            "description": "An iOS application programmatically accesses `UIPasteboard` properties (e.g., `UIPasteboard.general.string`) more than twice per second, or within 100 milliseconds of an `applicationWillEnterForeground` event, indicating automated, non-user-driven access.",
            "data_sources": [
              "Instrumented API call logs (e.g., Frida trace)",
              "MTD/MDM behavioral event logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Managed iOS devices, Corporate application vetting pipeline, Sandboxed analysis environment",
            "action": "Symbolic: In a sandboxed environment, use instrumentation tools (e.g., Frida) to hook the `UIPasteboard` class and log all access to its `string` and `items` properties. Generate an alert if an application accesses the clipboard more than twice per second. Additionally, search MTD/MDM logs for the literal string 'pasted from' to inventory all cross-app paste events for manual review, as this is an OS-generated notification. Statistical: From dynamic analysis or MTD logs, calculate the time delta between the `applicationWillEnterForeground` event and the first `UIPasteboard` access for each application session. Compute the median of these deltas per application. Flag any application whose median delta is in the lowest 5th percentile (e.g., < 100ms) across all monitored apps. Separately, calculate the Shannon entropy of inter-access timings for the clipboard by a single app; a very low entropy score suggests programmatic polling. Machine Learning: Model the sequence of API calls (including `UIPasteboard` access) made by an application as a time series. Train an LSTM-based autoencoder on call sequences from a large corpus of vetted, benign applications. During dynamic analysis of a new app, if the reconstruction error of its API call sequence exceeds a predetermined threshold, flag it as anomalous, indicating a significant deviation from normal application behavior."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "1.3",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  },
  {
    "information_requirement": "Is an adversary capturing credentials copied from password managers or other sensitive applications on mobile devices?",
    "tactic_id": "TA0031",
    "tactic_name": "Credential Access",
    "indicators": [
      {
        "technique_id": "T1414",
        "name": "Clipboard Data",
        "evidence": [
          {
            "description": "A clipboard access event is logged from an application not on the approved browser or password manager list, occurring within 5 seconds after an `app_backgrounded` event is logged for an approved password manager application on the same device.",
            "data_sources": [
              "MTD/MDM behavioral event logs (app_focus, app_background, clipboard_access)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Managed mobile devices with corporate-approved password managers installed",
            "action": "Symbolic: Maintain an allowlist of approved password manager bundle IDs (e.g., `com.1password.1password`, `com.agilebits.onepassword`). In a SIEM, create a correlation rule that triggers when, for the same `device_id`, an `app_backgrounded` event for an allowlisted bundle ID is followed within 5 seconds by a `clipboard_accessed` event from any bundle ID not on the allowlist or an approved browser list. Statistical: For each clipboard access event by a non-browser/non-password-manager application, query backwards in time to find the most recent `app_backgrounded` event for a known password manager on the same device. Calculate the time delta. Aggregate these deltas by application package name across the device fleet. Any application whose median delta is in the bottom 10th percentile (e.g., < 10 seconds) of all such calculated deltas should be investigated for potential credential scraping. Machine Learning: Create a labeled dataset of event sequences from MTD logs, where each sequence is a series of events (`app_focused`, `app_backgrounded`, `clipboard_accessed`) tagged with `device_id` and `timestamp`. Label sequences as malicious if they match known credential scraping patterns. Train a sequence classification model (e.g., RNN or Transformer) on these features to classify new, incoming event sequences in real-time."
          },
          {
            "description": "A network connection is initiated by an application within two minutes of that same application accessing the clipboard, where the destination is either a known-malicious IP/domain, a newly registered domain (NRD), or a domain with a calculated Shannon entropy score greater than 3.5.",
            "data_sources": [
              "MTD/MDM behavioral event logs",
              "Zeek dns.log",
              "Zeek conn.log",
              "Zeek ssl.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Managed mobile device endpoints, Corporate VPN concentrators, DNS resolvers, Network egress points",
            "action": "Symbolic: Using a SIEM, join MTD `clipboard_accessed` events with Zeek `conn.log` and `dns.log` events on `device_ip` and `timestamp`. Create a rule that alerts when an application's `bundle_id` from a clipboard access event makes a network connection within 2 minutes to a destination IP or domain present in a threat intelligence feed of known C2 servers. Statistical: For each network connection made within 2 minutes of a clipboard access event, perform the following checks using Zeek logs: 1) In `dns.log`, calculate the Shannon entropy of the queried domain name; alert if the score is > 3.5. 2) In `ssl.log`, check the certificate's `validation_status`; alert on `invalid` or `self-signed`. 3) Perform a daily long-tail analysis by identifying domains contacted by fewer than 5 devices in the last 30 days and cross-reference these with applications that accessed the clipboard. Machine Learning: For all network flows in `conn.log` originating from a device within 5 minutes of a clipboard access event, extract a feature vector. Include features like destination port, protocol, `orig_bytes`, JA3/JA3S hash from `ssl.log`, TLS version, and domain name entropy from `dns.log`. Use an unsupervised clustering algorithm (e.g., DBSCAN) to find small, dense clusters of traffic that are distant from large, benign clusters. Manually investigate these anomalous clusters as potential exfiltration channels."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "1.3",
    "date_created": "2025-09-26",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]