[
  {
    "information_requirement": "Is an adversary maintaining persistence on our mobile devices through event-triggered execution? (PIR)",
    "tactic_id": "TA0028",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1624",
        "name": "Event Triggered Execution",
        "evidence": [
          {
            "description": "An installed application's manifest (e.g., AndroidManifest.xml) declares broadcast receivers for sensitive system events like 'android.intent.action.BOOT_COMPLETED' or 'android.provider.Telephony.SMS_RECEIVED', and also requests high-risk permissions like 'android.permission.RECEIVE_SMS' or 'android.permission.INTERNET', a combination that is inconsistent with the application's stated purpose or app store category.",
            "data_sources": [
              "MDM Application Inventory Logs",
              "Android Application Manifests (AndroidManifest.xml)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Managed mobile device fleet, Mobile Device Management (MDM) server, Application vetting/sandbox environment",
            "action": "1. (Symbolic) Step 1: In your SIEM, query MDM logs to identify all applications that register broadcast receivers for sensitive events (e.g., `android.intent.action.BOOT_COMPLETED`, `android.provider.Telephony.SMS_RECEIVED`). Step 2: For this set of applications, cross-reference their requested permissions for high-risk grants (e.g., `android.permission.RECEIVE_SMS`, `android.permission.READ_CALL_LOG`). Step 3: Compare the package names and signing certificates of any matches against a threat intelligence feed of known malicious mobile indicators. Alert on any match. 2. (Statistical) Step 1: Parse the manifests of all managed applications to extract all requested permissions and registered broadcast receivers. Step 2: Calculate the fleet-wide frequency of each permission, each receiver, and each unique permission-receiver pair. Step 3: For each application, calculate a rarity score by summing the inverse frequencies of its permission-receiver pairs. Step 4: Group applications by their app store category and establish a baseline rarity score distribution. Flag any application whose rarity score exceeds the 98th percentile for its category for manual review. 3. (Machine Learning) Step 1: Pre-process a labeled dataset of benign and malicious Android application manifests, creating feature vectors from one-hot encoded permissions and broadcast receivers. Step 2: Train a Gradient Boosting classifier to predict a malice probability score from $$ 0.0 $$ to $$ 1.0 $$. Step 3: Integrate the trained model into the application vetting pipeline. For any new or updated application with a predicted malice score above a tuned threshold (e.g., $$ 0.90 $$), generate an alert. Step 4: For each alert, generate and review SHAP (SHapley Additive exPlanations) values to identify the specific permissions and receivers that most influenced the high score, providing clear context for the analyst."
          },
          {
            "description": "A mobile device exhibits a burst of anomalous network activity, characterized by a measurable increase in connections, data volume, or high-entropy DNS queries, within a 5-minute window immediately following a system event logged by an MDM, such as 'device boot', 'network connection change', or 'application installed'.",
            "data_sources": [
              "Zeek conn.log",
              "Zeek dns.log",
              "MDM Event Logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Corporate Wi-Fi network gateways, VPN concentrators, Internal and external DNS resolvers",
            "action": "1. (Symbolic) Step 1: Correlate MDM event logs with network flow data (Zeek conn.log) using the device IP address and a 5-minute time window following the event timestamp. Step 2: Isolate all network connections from the device immediately following a system boot (`event_type='boot_complete'`) or network change event. Step 3: Compare all destination IP addresses, domains (from Zeek dns.log), and JA3/JA3S hashes against threat intelligence feeds for known C2 servers. Alert on any positive match. 2. (Statistical) Step 1: For each device, create a 30-day historical baseline of network activity metrics (e.g., total connections, bytes out, unique DNS queries) in the 5-minute window after a boot event. Step 2: Calculate the mean and standard deviation for each metric to establish a normal profile. Step 3: In real-time, compare post-boot activity against this profile and alert if any metric's Z-score exceeds a threshold of $$ 3.5 $$. Step 4: Concurrently, calculate the Shannon entropy of the subdomain labels in DNS queries (Zeek dns.log) within the same window and alert if the entropy score is anomalously high compared to the device's own baseline, indicating potential DGA activity. 3. (Machine Learning) Step 1: For each device, create a time series of feature vectors representing network activity (e.g., connection frequency, data volume, protocol mix) in the 5 minutes post-boot. Step 2: Train an LSTM (Long Short-Term Memory) autoencoder model on at least 30 days of this historical time-series data to learn the device's normal post-boot 'network heartbeat'. Step 3: Apply the trained model to live data. If the model's reconstruction error for a new post-boot window is significantly high (exceeds a statistically determined threshold), trigger an alert for analyst investigation, providing the reconstruction error score and the anomalous metrics."
          }
        ]
      }
    ],
    "version": "1.3",
    "date_created": "2025-09-26",
    "last_updated": "2025-09-29",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]