[
  {
    "information_requirement": "Is the adversary executing malicious code using container orchestration jobs?",
    "tactic_id": "TA0002",
    "tactic_name": "Execution",
    "indicators": [
      {
        "technique_id": "T1053.007",
        "name": "Container Orchestration Job",
        "evidence": [
          {
            "description": "A container orchestration job is created or executed where the container image hash, the command-line arguments, or the resulting outbound network connections have a direct match to a high-confidence threat intelligence feed.",
            "data_sources": [
              "Kubernetes API Server Audit Logs",
              "Zeek conn.log",
              "Windows Event ID 4688"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes API Server, Container Registries, Kubernetes Worker Nodes, Network Egress Points",
            "action": "First, use symbolic logic by querying Zeek conn.log for connections where the source IP address ('id.orig_h') is within a known container IP range and the destination IP ('id.resp_h') or domain matches a list of known C2 indicators. Concurrently, query Windows Event ID 4688 logs from worker nodes for new processes where the parent process is a container runtime (e.g., 'containerd-shim-runc-v2') and the new process image hash matches a malicious hash from a threat intelligence feed. Second, apply a statistical method by calculating the Jaccard similarity index between the set of destination FQDNs contacted by a new job and the historical baseline of FQDNs for that application type; a score below a percentile threshold (e.g., 10th percentile) indicates anomalous communication patterns. Third, leverage machine learning by training a Random Forest classifier on labeled process execution events (Windows Event ID 4688), using features such as command-line length, entropy, presence of special characters, parent process name, and process image path, to classify new processes from container jobs as malicious or benign."
          },
          {
            "description": "A process executed by a container orchestration job contains command-line arguments or process names that match regular expression patterns for known reconnaissance tools (e.g., 'whoami', 'netstat'), C2 frameworks (e.g., '-e /bin/bash'), or cryptocurrency miners (e.g., 'xmrig').",
            "data_sources": [
              "Windows Event ID 4688",
              "Zeek dns.log",
              "Kubernetes API Server Audit Logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes, Internal DNS Servers, Kubernetes API Server",
            "action": "First, for symbolic detection, create a SIEM rule to search Windows Event ID 4688 on worker nodes for process command lines originating from container runtimes that match a curated list of regular expressions for reconnaissance tools ('ipconfig', 'hostname', 'net user'), C2 stagers ('powershell -enc'), and cryptominer names ('kinsing', 'xmrig'). Second, for a statistical approach, calculate the character-level entropy of command lines from all container job processes. Establish a baseline entropy distribution for legitimate jobs and flag any command line whose entropy exceeds the 99th percentile of the baseline as potentially obfuscated or malicious. Third, apply machine learning by using a pre-trained Natural Language Processing (NLP) model, fine-tuned on shell commands, to classify the intent of commands executed by container jobs. Flag commands that the model classifies with high confidence as 'C2', 'Reconnaissance', or 'Payload Execution'."
          },
          {
            "description": "Within a short time window (e.g., 5 minutes) following the creation of a container orchestration job, the associated pod exhibits network or process behavior that deviates significantly from its historical baseline, such as a spike in CPU usage, connections to a geographically rare destination, or execution of a previously unseen process.",
            "data_sources": [
              "Zeek conn.log",
              "Windows Event ID 4688",
              "Node Performance Metrics"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes, Network Egress Points, Monitoring and Metrics Platform",
            "action": "First, use symbolic logic by correlating the creation of a new container job (via Kubernetes logs or inferred from a new pod IP) with a subsequent connection from that pod's IP (in Zeek conn.log) to an IP on a 'suspicious ASN' or 'TOR exit node' blocklist. Second, apply a statistical method by establishing a baseline of CPU and memory utilization for each worker node. Monitor for spikes in resource usage that exceed 3 standard deviations above the mean immediately following the inferred start of a new container job. Concurrently, analyze Zeek conn.log for connections from the new pod's IP to destination countries not seen in the last 30 days for that application profile. Third, leverage machine learning by applying a time-series anomaly detection model, such as ARIMA or LSTM, to the volume of outbound data ('orig_bytes' in Zeek conn.log) from pod IPs to flag anomalies that coincide with the execution of a new container job."
          },
          {
            "description": "A process spawned by a container job accesses file paths (e.g., service account tokens at '/var/run/secrets/kubernetes.io/serviceaccount/token') or initiates network connections to internal services (e.g., other pods, internal APIs) that are inconsistent with its documented function or defined Kubernetes Network Policies.",
            "data_sources": [
              "Windows Event ID 4688",
              "Zeek conn.log",
              "Windows Event ID 4663"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes, Internal Network Segments, Kubernetes API Server",
            "action": "First, for symbolic detection, create a rule that triggers when a process from a container job (identified by parent process in Windows Event ID 4688) attempts to access a critical file object (logged in Windows Event ID 4663) such as 'kubelet.conf' or cloud credential files, where the source process name is not on an allowlist. Second, apply a statistical method by building a baseline communication graph for each application (pod-to-pod, pod-to-service). For each new job, calculate the number of new, unseen internal network connections (east-west traffic) in Zeek conn.log. A count of new connections ('new graph edges') exceeding the 95th percentile of the baseline for that application type is anomalous. Third, use a machine learning approach by applying a clustering algorithm like DBSCAN on features from internal network flows (Zeek conn.log), such as destination port, protocol, and data volume, to group pods into behavioral profiles. Flag jobs whose pods are classified into a new, small cluster or are marked as noise, indicating they do not conform to existing communication patterns."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "2.2",
    "date_created": "2025-05-04",
    "contributors": [
      "Zachary Szewczyk"
    ]
  },
  {
    "information_requirement": "Is the adversary maintaining persistence using container orchestration jobs?",
    "tactic_id": "TA0003",
    "tactic_name": "Persistence",
    "indicators": [
      {
        "technique_id": "T1053.007",
        "name": "Container Orchestration Job",
        "evidence": [
          {
            "description": "A container job, identified by a recurring process or network signature, executes on a periodic schedule and establishes outbound connections to domains, IPs, or JA3/JA4 hashes associated with known C2 servers.",
            "data_sources": [
              "Zeek conn.log",
              "Zeek dns.log",
              "Zeek ssl.log",
              "Windows Event ID 4688"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Network Egress Points, Kubernetes Worker Nodes, Internal DNS Servers",
            "action": "First, use symbolic detection by creating a SIEM rule to search Zeek ssl.log for recurring connections from container IP ranges where the 'ja3' or 'ja4' hash matches a known malicious fingerprint from a threat feed. Correlate the source IP with recurring process creation events in Windows Event ID 4688 to identify the responsible job. Second, apply a statistical method by analyzing the periodicity of connections from container IPs in Zeek conn.log. Calculate the inter-arrival time for connections to the same destination IP. A low variance in inter-arrival time (e.g., beaconing every 60 +/- 2 seconds) suggests an automated, persistent mechanism; flag connections with a standard deviation of inter-arrival time below a set threshold. Third, use machine learning by applying a time-series decomposition model to network beaconing data (e.g., connection counts per minute to a specific external IP). Isolate the periodic component; if a strong periodic signal is detected that does not match any known legitimate job schedule, classify it as a potential persistence mechanism."
          },
          {
            "description": "A Kubernetes CronJob is configured with a high-frequency schedule (e.g., every minute) or a job template that specifies the execution of a known backdoor, reverse shell, or C2 agent.",
            "data_sources": [
              "Kubernetes API Server Audit Logs",
              "Windows Event ID 4688",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes API Server, Kubernetes Worker Nodes",
            "action": "First, use symbolic logic by querying Kubernetes audit logs for the creation or modification of CronJob objects where the 'schedule' field matches high-frequency patterns like '*/1 * * * *' or '*/5 * * * *'. Alert if the job's container command also contains suspicious strings like 'curl', 'wget', or 'bash -c'. Second, apply a statistical method by analyzing the frequency distribution of all CronJob schedules in the cluster and flagging schedules in the top percentile of frequency (e.g., 99th percentile) for manual review. Additionally, calculate the Levenshtein distance between new CronJob names and existing legitimate job names to detect potential typosquatting. Third, use machine learning to train a classifier on CronJob configurations, using features like schedule frequency, image registry source, command entropy, and presence of privileged flags. Use the model to score new CronJobs for their likelihood of being malicious persistence."
          },
          {
            "description": "A pattern of periodic network beaconing or process execution is observed originating from a container, but this activity cannot be correlated with any known legitimate application function or a configured CronJob in the cluster.",
            "data_sources": [
              "Zeek conn.log",
              "Windows Event ID 4688",
              "Kubernetes API Server Audit Logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes, Network Egress Points, Kubernetes API Server",
            "action": "First, use a symbolic approach by identifying a recurring network connection in Zeek conn.log (e.g., same source/dest IP/port pair every 5 minutes). Then, query Kubernetes audit logs and application logs to find a legitimate job scheduled for that interval. If no correlating job is found, flag the activity as suspicious and unattributed. Second, use a statistical method by applying autocorrelation to the time series of process creation events (Windows Event ID 4688) on a worker node for a specific process name. A high autocorrelation at a regular lag (e.g., 300 seconds) indicates periodicity. Compare this periodicity against known CronJob schedules; a mismatch is anomalous. Third, use machine learning by applying a clustering algorithm (e.g., K-Means) on network flow 5-tuples from containers. Identify tight clusters of periodic activity. For each cluster, attempt to attribute it to a known application or CronJob. Unattributed clusters represent potentially malicious persistence."
          },
          {
            "description": "A container job is configured with a restart policy (e.g., 'OnFailure') or is managed by a higher-level controller that causes it to be re-executed immediately after it is terminated, and the pod associated with this job exhibits other suspicious behaviors.",
            "data_sources": [
              "Kubernetes API Server Audit Logs",
              "Windows Event ID 4688",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes API Server, Kubernetes Worker Nodes",
            "action": "First, use symbolic logic to query Kubernetes audit logs for Jobs created with 'spec.backoffLimit' set to a high number and 'spec.template.spec.restartPolicy' set to 'OnFailure'. Cross-reference this with jobs whose pods are observed making connections to known malicious IPs in Zeek conn.log. Second, apply a statistical method by calculating the restart rate for all pods in the cluster. A pod whose restart count is in the 99th percentile and is associated with a Job object is a strong anomaly. Correlate high restart rates with suspicious process executions (e.g., high command line entropy) in Windows Event ID 4688 from that pod. Third, use a machine learning approach by training a decision tree model to predict pod failure based on features like image source and resource requests. Pods that are predicted to be stable but exhibit high restart rates are anomalies, indicating a malicious job may be being repeatedly terminated by security controls and restarted by its controller."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "2.2",
    "date_created": "2025-05-04",
    "contributors": [
      "Zachary Szewczyk"
    ]
  },
  {
    "information_requirement": "Is the adversary escalating privileges using container orchestration jobs?",
    "tactic_id": "TA0004",
    "tactic_name": "Privilege Escalation",
    "indicators": [
      {
        "technique_id": "T1053.007",
        "name": "Container Orchestration Job",
        "evidence": [
          {
            "description": "A container job is created with one or more high-privilege security context settings (`privileged: true`, `hostPID: true`, `hostNetwork: true`) and its resulting pod executes a known privilege escalation tool or connects to a C2 server.",
            "data_sources": [
              "Kubernetes API Server Audit Logs",
              "Windows Event ID 4688",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes API Server, Kubernetes Worker Nodes, Network Egress Points",
            "action": "First, implement a symbolic detection by creating an alert that triggers when a Kubernetes audit log event shows the creation of a Job with 'securityContext.privileged: true' AND a subsequent process creation event (Windows Event ID 4688) from that pod's context shows the execution of a process with a hash matching a known privilege escalation tool. Second, use a statistical method by maintaining a list of all container images that are approved to run with privileged settings. Flag any new, previously unseen image being run in a privileged job. Calculate the rarity of the image across the environment; an image run only once and in a privileged context is highly suspicious. Third, apply machine learning by using a graph-based anomaly detection algorithm on the Kubernetes object graph. A node representing a Job connected to nodes representing both a 'Privileged' security context and a 'Rare Image' (from statistical analysis) would be assigned a high anomaly score."
          },
          {
            "description": "A process executed by a container job includes command-line arguments indicative of an attempt to escape the container, such as interacting with the Docker socket ('docker.sock'), using 'nsenter' to change namespaces, or mounting and accessing sensitive host paths.",
            "data_sources": [
              "Windows Event ID 4688",
              "Kubernetes API Server Audit Logs"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes, Kubernetes API Server",
            "action": "First, use symbolic logic by monitoring Windows Event ID 4688 on worker nodes for process command lines from containers that contain strings like '/var/run/docker.sock', 'nsenter -t', or '/proc/1/root' using regular expression matching. Second, use a statistical method by profiling the file access patterns of legitimate container jobs. For a new job, count the number of accesses to paths outside of the container's expected filesystem (e.g., host paths mounted via 'hostPath'). If this count exceeds the 99th percentile for jobs of that type, flag it as anomalous. Third, apply machine learning by training an autoencoder on benign command-line sequences from container jobs. A command sequence that results in a high reconstruction error is anomalous and could detect novel or obfuscated breakout techniques that do not match simple regex patterns."
          },
          {
            "description": "A pod created by a container job initiates network connections to privileged services on the host node (e.g., Kubelet API on port 10250, etcd on port 2379) or other sensitive network segments (e.g., administrative subnets), where such access is not defined in a NetworkPolicy.",
            "data_sources": [
              "Zeek conn.log",
              "Windows Event ID 4663",
              "Windows Event ID 4688"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes, Kubernetes Control Plane Network, Internal Administrative Networks",
            "action": "First, use a symbolic rule that triggers if Zeek conn.log shows a connection where 'id.orig_h' is a pod IP, 'id.resp_h' is the hosting node's IP, and 'id.resp_p' is 10250 (Kubelet API), and there is no corresponding allow rule in a Kubernetes NetworkPolicy. Second, apply a statistical method by baselining pod-to-node-port communications. For each pod, count the number of unique node ports it connects to. Flag any pod that connects to a number of ports exceeding 2 standard deviations from the mean for its application profile, especially if those ports are unassigned or privileged. Third, use machine learning by training a One-Class SVM on legitimate pod-to-host and pod-to-service communication patterns (features: destination IP, destination port, protocol). Any new communication flow that the model classifies as an outlier is flagged as a potential unauthorized access attempt."
          },
          {
            "description": "Following the execution of a container job, a new user account is created on the worker node, a new privileged pod is deployed in the cluster, or a new ClusterRoleBinding is created, indicating the job successfully escalated privileges and is taking follow-on actions.",
            "data_sources": [
              "Windows Event ID 4720",
              "Windows Event ID 4688",
              "Kubernetes API Server Audit Logs",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Kubernetes Worker Nodes (Authentication Logs), Kubernetes API Server, Domain Controllers",
            "action": "First, use symbolic logic to correlate the execution of a process by a container job (Windows Event ID 4688) with the creation of a local user account on the same worker node within a 1-minute window (Windows Event ID 4720), where the source of the account creation is not a legitimate administrative tool. Second, use a statistical method to monitor the rate of creation for high-privilege Kubernetes objects (e.g., ClusterRoleBindings). A sudden spike in the creation rate that deviates from a moving average baseline indicates a potential escalation event; correlate the timing with recently executed jobs. Third, apply machine learning by using a sequence analysis model (e.g., Hidden Markov Model) to learn legitimate sequences of actions (e.g., job create -> pod running -> pod success). Flag sequences as anomalous if they include unexpected state transitions, such as 'job create -> pod running -> new ClusterRoleBinding created', indicating post-escalation activity."
          }
        ]
      }
    ],
    "last_updated": "2025-09-29",
    "version": "2.2",
    "date_created": "2025-05-04",
    "contributors": [
      "Zachary Szewczyk"
    ]
  }
]