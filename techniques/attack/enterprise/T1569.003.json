[
  {
    "information_requirement": "Is an adversary leveraging the systemctl utility for command execution or persistence on a Linux host?",
    "tactic_id": "TA0002",
    "tactic_name": "Execution",
    "indicators": [
      {
        "technique_id": "T1569.003",
        "name": "Systemctl",
        "evidence": [
          {
            "description": "A systemd service unit file (.service) is created or modified, and its content, specifically the `ExecStart` directive, contains a command string that is obfuscated, references a known malicious indicator (IP, domain, hash), or is otherwise anomalous.",
            "data_sources": [
              "Sysmon for Linux Event ID 11 (FileCreate)",
              "auditd logs (syscall=creat, openat)",
              "File content of .service files"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Systemd service file directories on all Linux hosts, including /etc/systemd/system/, /run/systemd/system/, /usr/lib/systemd/system/, and user-specific paths like ~/.config/systemd/user/.",
            "action": [
              "Symbolic: Create a rule to monitor file creation events for files ending in '.service' in common systemd directories. Upon creation, scan the file's content, particularly the `ExecStart` line, against a threat intelligence feed of known malicious file hashes, domains, IP addresses, and command patterns. Generate a high-severity alert on any match.",
              "Statistical: For each new or modified `.service` file, calculate the Shannon entropy of the command string within the `ExecStart` directive. Establish a baseline of entropy scores for all legitimate service commands in the environment by analyzing existing `.service` files. Flag any new command with an entropy score exceeding the 95th percentile of the established baseline for manual review, as this indicates potential obfuscation or packing.",
              "Machine Learning: Train a supervised classification model (e.g., Random Forest) using features extracted from the text of `.service` files. Use a labeled dataset of known benign and malicious service files. Features should include: command string length, presence of IP addresses or domains, ratio of special characters, use of encoding utilities (e.g., base64, hex), and n-gram analysis of the `ExecStart` command. Deploy the model to classify newly created `.service` files in near real-time."
            ]
          },
          {
            "description": "A file with a `.service` extension is created in a non-standard, world-writable directory (e.g., /tmp, /var/tmp, /dev/shm) and is subsequently loaded by a `systemctl start` or `systemctl enable` command within a 5-minute window.",
            "data_sources": [
              "Sysmon for Linux Event ID 1 (ProcessCreate)",
              "Sysmon for Linux Event ID 11 (FileCreate)",
              "auditd logs (syscall=execve, creat)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "File system and process execution logs from all Linux hosts, with a focus on world-writable directories such as /tmp, /var/tmp, and /dev/shm.",
            "action": [
              "Symbolic: Implement a correlation rule that triggers when a file creation event for a '*.service' file occurs in a directory from a blocklist (`/tmp`, `/dev/shm`, `/var/tmp`) and is followed within 5 minutes by a process creation event for `systemctl` with `start` or `enable` arguments targeting that same file path. This correlation is highly indicative of malicious activity.",
              "Statistical: Develop a frequency map of all directories where `.service` files are legitimately created across the enterprise over a 30-day baseline period. For each new `.service` file creation event, calculate the historical rarity of its parent directory. Generate an alert if a `.service` file is created in a directory that falls into the bottom 1% of the frequency distribution (i.e., is exceptionally rare).",
              "Machine Learning: Use a time-series anomaly detection model (e.g., SARIMA) to monitor the rate of `.service` file creations in non-standard directories (all directories not in the top 95% of standard locations). A sudden, anomalous spike in creation events that deviates significantly from the established baseline pattern should be flagged as a potential automated attack or mass deployment of a malicious service."
            ]
          },
          {
            "description": "The `systemctl` command is executed by a parent process that is not a standard interactive shell, administrative script engine, or orchestration tool. Anomalous parents include web server daemons, database services, or office applications.",
            "data_sources": [
              "Sysmon for Linux Event ID 1 (ProcessCreate)",
              "auditd logs (syscall=execve)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Process creation and process relationship logs from all Linux hosts, especially mission-critical servers (e.g., web servers running Apache/Nginx, application servers running Java/Node.js, database servers).",
            "action": [
              "Symbolic: Create a detection rule that generates a high-priority alert whenever a `systemctl` process is spawned and its direct parent process name is on a blocklist of non-interactive or suspicious parents, such as `nginx`, `httpd`, `apache2`, `php-fpm`, `java`, `node`, `python` (when not run from an interactive shell), or `sshd` (when parent is not a shell).",
              "Statistical: For each host, build a baseline of normal parent-child process relationships for `systemctl` over a 30-day period. Calculate the conditional probability P(Parent | Child='systemctl') for every observed parent process. Alert on any `systemctl` execution where the parent process has a historically low probability (e.g., <1%) of spawning `systemctl` on that specific host or within its designated server group (e.g., web servers).",
              "Machine Learning: Model process execution chains as a directed graph where nodes are processes (with attributes like name, user, command line) and edges represent parent-child relationships. Use a graph-based anomaly detection algorithm to identify rare or abnormal paths leading to `systemctl` execution. Flag execution chains that are topologically dissimilar to the vast majority of chains in the historical graph data."
            ]
          },
          {
            "description": "A `systemctl stop` or `systemctl disable` command is executed targeting a critical service required for security monitoring, logging, or endpoint protection (e.g., auditd.service, rsyslog.service, osqueryd.service, falcon-sensor.service).",
            "data_sources": [
              "Sysmon for Linux Event ID 1 (ProcessCreate)",
              "auditd logs (syscall=execve)",
              "SIEM ingestion logs",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Process execution logs from all Linux hosts. Log ingestion health metrics from the SIEM. Network traffic logs from network gateways and core switches.",
            "action": [
              "Symbolic: Maintain a watchlist of critical service names (e.g., `auditd.service`, `osqueryd.service`, `rsyslog.service`, `syslog.service`, `filebeat.service`, `nxlog.service`, `falcon-sensor.service`, `cb-enterprise.service`). Create a critical alert that triggers immediately if a process creation event is observed for `systemctl` with the arguments `stop` or `disable` targeting any service on this list.",
              "Statistical: Monitor the health of critical security agents by tracking their log ingestion timestamps in the SIEM. For each agent/host, calculate the mean and standard deviation of the time between log events (heartbeat). If an agent's telemetry stops for a period exceeding a dynamic threshold (e.g., mean interval + 3 standard deviations), generate an alert for a potential outage. Correlate this loss with any `systemctl` commands on the host just prior to the outage.",
              "Machine Learning: Apply a time-series anomaly detection model (e.g., Prophet) to the volume of security logs (e.g., auditd, EDR) ingested into the SIEM from each host. The model can account for known seasonality (e.g., lower weekend/overnight activity). An alert is generated for any sudden, unexplained drop in log volume not associated with a planned maintenance window. This can be correlated with `systemctl` process logs from the same host to pinpoint defense evasion."
            ]
          },
          {
            "description": "An unusually high number of `systemctl` commands used for enumeration (e.g., `status`, `list-units`, `list-unit-files`, `is-enabled`) are executed by a single user or process in a short time window, suggesting automated reconnaissance.",
            "data_sources": [
              "Sysmon for Linux Event ID 1 (ProcessCreate)",
              "auditd logs (syscall=execve)",
              "Shell history logs (e.g., .bash_history, .zsh_history)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Process execution logs and shell command history logs from all interactive Linux sessions, including bastion hosts, developer workstations, and administrative servers.",
            "action": [
              "Symbolic: Implement a sliding-window rule that counts `systemctl` executions containing reconnaissance subcommands (`status`, `list-units`, `list-unit-files`, `list-timers`, `is-enabled`) grouped by `user_id` and `hostname`. If the count exceeds a hard threshold (e.g., >15 commands in 1 minute), generate an alert for potential automated discovery scripting.",
              "Statistical: For each user account, establish a baseline of their typical hourly rate of `systemctl` reconnaissance command usage over a 30-day period. Generate an alert if a user's command rate in a given hour exceeds their personal 99th percentile, indicating a significant behavioral deviation from their normal administrative activities.",
              "Machine Learning: Use a density-based clustering algorithm like DBSCAN on `systemctl` command executions. Use features such as the time delta between consecutive commands, the user, the source host, and the command type. The algorithm can automatically group tightly packed, rapidly executed command sequences (indicative of automation) into clusters, separating them from sparse, manually-typed administrative commands. Any identified dense cluster should be flagged as suspicious."
            ]
          }
        ]
      }
    ],
    "version": "2.3",
    "date_created": "2025-05-04",
    "last_updated": "2025-09-30",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]