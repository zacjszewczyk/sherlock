[
  {
    "information_requirement": "Has the adversary executed commands using systemctl for persistence or execution?",
    "tactic_id": "TA0002",
    "tactic_name": "Execution",
    "indicators": [
      {
        "technique_id": "T1569.003",
        "name": "Systemctl",
        "evidence": [
          {
            "description": "A systemd service unit file (.service) is created or modified, and its content (e.g., `ExecStart` directive) or filename contains a string matching a known malicious indicator (IP address, domain, hash, or filename) from threat intelligence feeds.",
            "data_sources": [
              "Linux: Sysmon for Linux Event ID 11 (FileCreate)",
              "Linux: auditd logs (syscall=creat, open, openat)",
              "File content of .service files"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Critical Linux servers (e.g., web servers, database servers, authentication servers); User workstations running Linux; Systemd service file directories (/etc/systemd/system/, /run/systemd/system/, /usr/lib/systemd/system/, ~/.config/systemd/user/)",
            "action": [
              "Symbolic: Query file creation events (e.g., Sysmon for Linux Event ID 11) for files ending in '.service'. For each new file, scan its contents against a threat intelligence database of known malicious domains, IPs, file hashes, and commands. Alert on any match.",
              "Statistical: For all `ExecStart` commands in new or modified `.service` files, calculate the command's string entropy. Establish a baseline of entropy scores for legitimate service commands in the environment. Flag commands with entropy scores exceeding the 95th percentile, as this may indicate obfuscated or packed commands.",
              "Machine Learning: Train a classification model (e.g., Logistic Regression, Random Forest) on the text content of known benign and malicious systemd service files. Features could include command-line arguments, file paths, and string characteristics (length, special characters). Use the model to classify newly created service files as suspicious or benign in near real-time."
            ]
          },
          {
            "description": "A file with a `.service` extension is created in a world-writable or temporary directory (e.g., /tmp, /var/tmp, /dev/shm) and is subsequently referenced by a `systemctl start` or `systemctl enable` command within a short time window (e.g., < 5 minutes).",
            "data_sources": [
              "Linux: auditd logs (syscall=execve, creat)",
              "Linux: Sysmon for Linux Event ID 1 (ProcessCreate)",
              "Linux: Sysmon for Linux Event ID 11 (FileCreate)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "World-writable directories on all Linux hosts (/tmp, /var/tmp, /dev/shm); Process execution logs from all Linux hosts.",
            "action": [
              "Symbolic: Create a rule that triggers when a file creation event for a `.service` file occurs in a directory from a blocklist (`/tmp`, `/dev/shm`, `/var/tmp`) and is followed within 5 minutes by a process creation event for `systemctl` with `start` or `enable` arguments targeting that same file path. Alert on this correlation.",
              "Statistical: Maintain a historical frequency map of directories where `.service` files are created across the enterprise. Calculate the rarity of the parent directory for each new `.service` file creation event. Flag any creation event in a directory that falls below a 1% frequency threshold (i.e., is exceptionally rare) for investigation.",
              "Machine Learning: Use a time-series anomaly detection model (e.g., ARIMA) to monitor the rate of `.service` file creation in non-standard directories. A sudden, anomalous spike in creation events in these locations, which deviates significantly from the established baseline, should be flagged as a potential mass deployment or automated attack."
            ]
          },
          {
            "description": "The systemctl command is executed by an anomalous parent process, such as a web server daemon or document application, indicating a post-exploitation execution chain.",
            "data_sources": [
              "Linux: auditd logs (syscall=execve)",
              "Linux: Sysmon for Linux Event ID 1 (ProcessCreate)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Process execution logs from all Linux hosts, particularly web servers (e.g., Apache, Nginx), application servers, and container environments.",
            "action": [
              "Symbolic: Create a detection rule that alerts whenever a `systemctl` process is created and its parent process is on a blocklist of non-interactive or typically non-administrative processes (e.g., `nginx`, `httpd`, `apache2`, `php-fpm`, `java`, `node`).",
              "Statistical: For each host, build a baseline of normal parent-child process relationships for `systemctl`. Calculate the conditional probability of each observed parent process for `systemctl`. Alert on any execution where the parent process has a historically low probability (e.g., < 0.01%) of spawning `systemctl` on that host or host group.",
              "Machine Learning: Develop a graph-based anomaly detection model where nodes are processes and edges are parent-child relationships. Analyze subgraphs representing process execution chains leading to `systemctl` execution. Flag chains that are topologically rare or contain anomalous node sequences compared to the historical graph data of the environment."
            ]
          },
          {
            "description": "A `systemctl stop` or `systemctl disable` command is executed targeting a service essential for security monitoring or system logging (e.g., auditd.service, rsyslog.service, osqueryd.service, filebeat.service, or a commercial EDR agent service).",
            "data_sources": [
              "Linux: auditd logs (syscall=execve)",
              "Linux: Sysmon for Linux Event ID 1 (ProcessCreate)",
              "Zeek conn.log"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Process execution logs from all Linux hosts; Network gateway and core switch traffic monitoring points; Security tool health status logs.",
            "action": [
              "Symbolic: Maintain a list of critical service names (e.g., `auditd.service`, `osqueryd.service`, `falcon-sensor.service`). Create a high-priority alert that triggers immediately if a process creation event is observed for `systemctl` with arguments `stop` or `disable` followed by any service name on this list.",
              "Statistical: Monitor the heartbeat or health status of critical agents. Calculate the expected reporting interval for each agent. If an agent's telemetry stops for a period exceeding a statistically defined threshold (e.g., mean interval + 3 standard deviations), generate an alert. Correlate this telemetry loss with any `systemctl` activity on the affected host just prior to the outage.",
              "Machine Learning: Use a time-series model to monitor the volume of security logs (e.g., auditd, syslog) being ingested into the SIEM from each host. Anomaly detection algorithms can identify a sudden, sharp drop in log volume that is not associated with a planned maintenance window. Correlate this drop with `systemctl` commands on the host to identify potential defense evasion."
            ]
          },
          {
            "description": "A high frequency of `systemctl` commands associated with reconnaissance (`status`, `list-units`, `list-unit-files`, `list-timers`, `is-enabled`) are executed by a single user or from a single parent process within a short time window (e.g., >10 commands in 1 minute).",
            "data_sources": [
              "Linux: auditd logs (syscall=execve)",
              "Linux: Sysmon for Linux Event ID 1 (ProcessCreate)",
              "Shell history logs (e.g., .bash_history)"
            ],
            "data_platforms": [
              "TBD"
            ],
            "nai": "Process execution logs and shell command history logs from all interactive Linux sessions; Logs from automation and orchestration servers (e.g., Ansible, SaltStack).",
            "action": [
              "Symbolic: Create a rule that counts `systemctl` executions containing reconnaissance subcommands (`status`, `list-units`, etc.) grouped by `user_id` and `host` over a 1-minute window. If the count exceeds a hard threshold of 10, generate an alert for potential automated discovery.",
              "Statistical: For each user, establish a baseline of their average `systemctl` reconnaissance command usage rate per hour. Alert if a user's command rate in a given hour exceeds a dynamic threshold, such as their personal 99th percentile, indicating a significant deviation from their normal administrative behavior.",
              "Machine Learning: Apply a clustering algorithm (e.g., DBSCAN) to `systemctl` command executions based on features like command frequency, inter-command timing, and command diversity. This can distinguish between sparse, manual administrative activity and dense, automated clusters of reconnaissance activity, which can then be flagged for review."
            ]
          }
        ]
      }
    ],
    "version": "2.2",
    "date_created": "2025-05-04",
    "last_updated": "2025-09-30",
    "contributors": [
      "Zachary Szewczyk",
      "Ask Sage"
    ]
  }
]